
IFKOR_FOC_DRIVE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001e08  10001000  10001000  00001000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000474  10002e08  10002e08  00002e08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .VENEER_Code  00000138  2000000c  10003280  0000800c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 Stack         00000404  20000144  00000000  00000144  2**0
                  ALLOC
  4 .data         00000114  20000548  100033b8  00008548  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .ram_code     00000998  20000660  100034cc  00008660  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .bss          00000378  20000ff8  10003e64  00008ff8  2**2
                  ALLOC
  7 .no_init      00000004  20003ffc  10006e68  00008ff8  2**2
                  ALLOC
  8 .debug_aranges 00000ca0  00000000  00000000  00008ff8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00016de3  00000000  00000000  00009c98  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00003cf6  00000000  00000000  00020a7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00007169  00000000  00000000  00024771  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001e00  00000000  00000000  0002b8dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000094d5  00000000  00000000  0002d6dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00006a09  00000000  00000000  00036bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001410  00000000  00000000  0003d5c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 000007ec  00000000  00000000  0003e9d0  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

10001000 <__Vectors>:
10001000:	48 05 00 20 19 10 00 10 00 00 00 00 99 10 00 10     H.. ............
10001010:	00 04 01 00 00 01 00 00                             ........

10001018 <Reset_Handler>:
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001018:	4911      	ldr	r1, [pc, #68]	; (10001060 <__copy_data+0xe>)
	ldr	r2, =VeneerStart
1000101a:	4a12      	ldr	r2, [pc, #72]	; (10001064 <__copy_data+0x12>)
	ldr	r3, =VeneerEnd
1000101c:	4b12      	ldr	r3, [pc, #72]	; (10001068 <__copy_data+0x16>)
	bl  __copy_data
1000101e:	f000 f818 	bl	10001052 <__copy_data>

    ldr  r0, =SystemInit
10001022:	4812      	ldr	r0, [pc, #72]	; (1000106c <__copy_data+0x1a>)
    blx  r0
10001024:	4780      	blx	r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001026:	4912      	ldr	r1, [pc, #72]	; (10001070 <__copy_data+0x1e>)
	ldr	r2, =__data_start
10001028:	4a12      	ldr	r2, [pc, #72]	; (10001074 <__copy_data+0x22>)
	ldr	r3, =__data_end
1000102a:	4b13      	ldr	r3, [pc, #76]	; (10001078 <__copy_data+0x26>)
	bl  __copy_data
1000102c:	f000 f811 	bl	10001052 <__copy_data>

/* RAM code */
	ldr	r1, =__ram_code_load
10001030:	4912      	ldr	r1, [pc, #72]	; (1000107c <__copy_data+0x2a>)
	ldr	r2, =__ram_code_start
10001032:	4a13      	ldr	r2, [pc, #76]	; (10001080 <__copy_data+0x2e>)
	ldr	r3, =__ram_code_end
10001034:	4b13      	ldr	r3, [pc, #76]	; (10001084 <__copy_data+0x32>)
	bl  __copy_data
10001036:	f000 f80c 	bl	10001052 <__copy_data>
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
1000103a:	4913      	ldr	r1, [pc, #76]	; (10001088 <__copy_data+0x36>)
	ldr	r2, =__bss_end
1000103c:	4a13      	ldr	r2, [pc, #76]	; (1000108c <__copy_data+0x3a>)

	movs	r0, 0
1000103e:	2000      	movs	r0, #0

	subs	r2, r1
10001040:	1a52      	subs	r2, r2, r1
	ble	.L_loop3_done
10001042:	dd02      	ble.n	1000104a <Reset_Handler+0x32>

.L_loop3:
	subs	r2, #4
10001044:	3a04      	subs	r2, #4
	str	r0, [r1, r2]
10001046:	5088      	str	r0, [r1, r2]
	bgt	.L_loop3
10001048:	dcfc      	bgt.n	10001044 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
1000104a:	4811      	ldr	r0, [pc, #68]	; (10001090 <__copy_data+0x3e>)
    blx  r0
1000104c:	4780      	blx	r0
#endif

    ldr  r0, =main
1000104e:	4811      	ldr	r0, [pc, #68]	; (10001094 <__copy_data+0x42>)
    blx  r0
10001050:	4780      	blx	r0

10001052 <__copy_data>:
 *    r3: end of the section to copy to
 *
 *  All addresses must be aligned to 4 bytes boundary.
 *  Uses r0
 */
	subs	r3, r2
10001052:	1a9b      	subs	r3, r3, r2
	ble	.L_loop_done
10001054:	dd03      	ble.n	1000105e <__copy_data+0xc>

.L_loop:
	subs	r3, #4
10001056:	3b04      	subs	r3, #4
	ldr	r0, [r1,r3]
10001058:	58c8      	ldr	r0, [r1, r3]
	str	r0, [r2,r3]
1000105a:	50d0      	str	r0, [r2, r3]
	bgt	.L_loop
1000105c:	dcfb      	bgt.n	10001056 <__copy_data+0x4>

.L_loop_done:
	bx  lr
1000105e:	4770      	bx	lr
    .thumb_func 
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler: 
/* Initialize interrupt veneer */
	ldr	r1, =eROData
10001060:	10003280 	.word	0x10003280
	ldr	r2, =VeneerStart
10001064:	2000000c 	.word	0x2000000c
	ldr	r3, =VeneerEnd
10001068:	20000144 	.word	0x20000144
	bl  __copy_data

    ldr  r0, =SystemInit
1000106c:	1000111d 	.word	0x1000111d
    blx  r0
	
/* Initialize data */
	ldr	r1, =DataLoadAddr
10001070:	100033b8 	.word	0x100033b8
	ldr	r2, =__data_start
10001074:	20000548 	.word	0x20000548
	ldr	r3, =__data_end
10001078:	2000065c 	.word	0x2000065c
	bl  __copy_data

/* RAM code */
	ldr	r1, =__ram_code_load
1000107c:	100034cc 	.word	0x100034cc
	ldr	r2, =__ram_code_start
10001080:	20000660 	.word	0x20000660
	ldr	r3, =__ram_code_end
10001084:	20000ff8 	.word	0x20000ff8
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
#ifndef __SKIP_BSS_CLEAR
	ldr	r1, =__bss_start
10001088:	20000ff8 	.word	0x20000ff8
	ldr	r2, =__bss_end
1000108c:	2000136c 	.word	0x2000136c
	bgt	.L_loop3
.L_loop3_done:
#endif /* __SKIP_BSS_CLEAR */

#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
10001090:	10002d4d 	.word	0x10002d4d
    blx  r0
#endif

    ldr  r0, =main
10001094:	100029e1 	.word	0x100029e1

10001098 <BCCU0_0_IRQHandler>:
    
    .thumb_func
    .weak Default_handler
    .type Default_handler, %function
Default_handler:
    b  .
10001098:	e7fe      	b.n	10001098 <BCCU0_0_IRQHandler>
	...

1000109c <SystemCoreSetup>:
  SystemCoreClockSetup();
}

__WEAK void SystemCoreSetup(void)
{
}
1000109c:	4770      	bx	lr
1000109e:	46c0      	nop			; (mov r8, r8)

100010a0 <SystemCoreClockUpdate>:

__WEAK void SystemCoreClockUpdate(void)
{
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010a0:	4a0c      	ldr	r2, [pc, #48]	; (100010d4 <SystemCoreClockUpdate+0x34>)

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
100010a2:	b508      	push	{r3, lr}
  static uint32_t IDIV, FDIV;

  IDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
100010a4:	6813      	ldr	r3, [r2, #0]
100010a6:	490c      	ldr	r1, [pc, #48]	; (100010d8 <SystemCoreClockUpdate+0x38>)
100010a8:	041b      	lsls	r3, r3, #16
100010aa:	0e1b      	lsrs	r3, r3, #24
100010ac:	600b      	str	r3, [r1, #0]
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
100010ae:	21ff      	movs	r1, #255	; 0xff
100010b0:	6812      	ldr	r2, [r2, #0]
100010b2:	4011      	ands	r1, r2
100010b4:	4a09      	ldr	r2, [pc, #36]	; (100010dc <SystemCoreClockUpdate+0x3c>)
100010b6:	6011      	str	r1, [r2, #0]
  
  if (IDIV != 0)
100010b8:	2b00      	cmp	r3, #0
100010ba:	d103      	bne.n	100010c4 <SystemCoreClockUpdate+0x24>
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
  }
  else
  {
    /* Fractional divider bypassed. Simply divide DCO_DCLK by 2 */
    SystemCoreClock = DCO1_FREQUENCY >> 1U;
100010bc:	4808      	ldr	r0, [pc, #32]	; (100010e0 <SystemCoreClockUpdate+0x40>)
100010be:	4b09      	ldr	r3, [pc, #36]	; (100010e4 <SystemCoreClockUpdate+0x44>)
  }
}
100010c0:	6018      	str	r0, [r3, #0]
100010c2:	bd08      	pop	{r3, pc}
  FDIV = ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_FDIV_Msk) >> SCU_CLK_CLKCR_FDIV_Pos;
  
  if (IDIV != 0)
  {
    /* Fractional divider is enabled and used */
    SystemCoreClock = ((DCO1_FREQUENCY << 6U) / ((IDIV << 8) + FDIV)) << 1U;
100010c4:	021b      	lsls	r3, r3, #8
100010c6:	1859      	adds	r1, r3, r1
100010c8:	4807      	ldr	r0, [pc, #28]	; (100010e8 <SystemCoreClockUpdate+0x48>)
100010ca:	f001 fb0b 	bl	100026e4 <__aeabi_uidiv>
100010ce:	0040      	lsls	r0, r0, #1
100010d0:	e7f5      	b.n	100010be <SystemCoreClockUpdate+0x1e>
100010d2:	46c0      	nop			; (mov r8, r8)
100010d4:	40010300 	.word	0x40010300
100010d8:	20000ff8 	.word	0x20000ff8
100010dc:	20000ffc 	.word	0x20000ffc
100010e0:	01e84800 	.word	0x01e84800
100010e4:	20003ffc 	.word	0x20003ffc
100010e8:	f4240000 	.word	0xf4240000

100010ec <SystemCoreClockSetup>:
__WEAK void SystemCoreClockSetup(void)
{
  /* Override values of CLOCK_VAL1 and CLOCK_VAL2 defined in vector table */
  /* MCLK = 32MHz, PCLK = 64MHz */
  
  SCU_GENERAL->PASSWD = 0x000000C0UL; /* disable bit protection */
100010ec:	22c0      	movs	r2, #192	; 0xc0
  SCU_CLK->CLKCR = 0x3FF10100UL;
  while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
100010ee:	2180      	movs	r1, #128	; 0x80
__WEAK void SystemCoreSetup(void)
{
}

__WEAK void SystemCoreClockSetup(void)
{
100010f0:	b508      	push	{r3, lr}
  /* Override values of CLOCK_VAL1 and CLOCK_VAL2 defined in vector table */
  /* MCLK = 32MHz, PCLK = 64MHz */
  
  SCU_GENERAL->PASSWD = 0x000000C0UL; /* disable bit protection */
100010f2:	4b07      	ldr	r3, [pc, #28]	; (10001110 <SystemCoreClockSetup+0x24>)
  SCU_CLK->CLKCR = 0x3FF10100UL;
  while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
100010f4:	05c9      	lsls	r1, r1, #23
__WEAK void SystemCoreClockSetup(void)
{
  /* Override values of CLOCK_VAL1 and CLOCK_VAL2 defined in vector table */
  /* MCLK = 32MHz, PCLK = 64MHz */
  
  SCU_GENERAL->PASSWD = 0x000000C0UL; /* disable bit protection */
100010f6:	625a      	str	r2, [r3, #36]	; 0x24
  SCU_CLK->CLKCR = 0x3FF10100UL;
100010f8:	4a06      	ldr	r2, [pc, #24]	; (10001114 <SystemCoreClockSetup+0x28>)
100010fa:	4b07      	ldr	r3, [pc, #28]	; (10001118 <SystemCoreClockSetup+0x2c>)
100010fc:	6013      	str	r3, [r2, #0]
  while((SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk));
100010fe:	6813      	ldr	r3, [r2, #0]
10001100:	420b      	tst	r3, r1
10001102:	d1fc      	bne.n	100010fe <SystemCoreClockSetup+0x12>
  SCU_GENERAL->PASSWD = 0x000000C3UL; /* enable bit protection */
10001104:	22c3      	movs	r2, #195	; 0xc3
10001106:	4b02      	ldr	r3, [pc, #8]	; (10001110 <SystemCoreClockSetup+0x24>)
10001108:	625a      	str	r2, [r3, #36]	; 0x24

  SystemCoreClockUpdate();
1000110a:	f7ff ffc9 	bl	100010a0 <SystemCoreClockUpdate>
}
1000110e:	bd08      	pop	{r3, pc}
10001110:	40010000 	.word	0x40010000
10001114:	40010300 	.word	0x40010300
10001118:	3ff10100 	.word	0x3ff10100

1000111c <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{    
1000111c:	b508      	push	{r3, lr}
  SystemCoreSetup();
1000111e:	f7ff ffbd 	bl	1000109c <SystemCoreSetup>
  SystemCoreClockSetup();
10001122:	f7ff ffe3 	bl	100010ec <SystemCoreClockSetup>
}
10001126:	bd08      	pop	{r3, pc}

10001128 <Get_Current_Bias>:

/* API to initialize value of 12-bit VADC bias, external amplifiers bias at about 2.5V */
void Get_Current_Bias(void)
{
	/* Init ADC bias */
	ADC.ADC_Bias = INIT_ADC_BIAS;
10001128:	2280      	movs	r2, #128	; 0x80
1000112a:	4b05      	ldr	r3, [pc, #20]	; (10001140 <Get_Current_Bias+0x18>)
1000112c:	0112      	lsls	r2, r2, #4
1000112e:	62da      	str	r2, [r3, #44]	; 0x2c

	ADC.ADC_Bias_Iu = INIT_ADC_BIAS;
10001130:	609a      	str	r2, [r3, #8]
	ADC.ADC_Bias_Iv = INIT_ADC_BIAS;
10001132:	60da      	str	r2, [r3, #12]
	ADC.ADC_Bias_Iw = INIT_ADC_BIAS;
10001134:	611a      	str	r2, [r3, #16]

	ADC.ADC_Iu = INIT_ADC_BIAS;
10001136:	801a      	strh	r2, [r3, #0]
	ADC.ADC_Iv = INIT_ADC_BIAS;
10001138:	805a      	strh	r2, [r3, #2]
	ADC.ADC_Iw = INIT_ADC_BIAS;
1000113a:	809a      	strh	r2, [r3, #4]


}
1000113c:	4770      	bx	lr
1000113e:	46c0      	nop			; (mov r8, r8)
10001140:	20001050 	.word	0x20001050

10001144 <UART_Set_POT_ADC>:
  #if(UART_ENABLE == USIC_DISABLED_ALL)
  uint16_t pot_adc_result;
  #endif

  /* EMPTY = 0, receive buffer is not empty.*/
  if ((USIC0_CHX_TRBSR & 0x00000008) == 0)
10001144:	228a      	movs	r2, #138	; 0x8a
/* Use UART to set POT ADC, and hence target motor speed
   ** Execution time: ?? executed from RAM (O3 - Optimize most).
     * ----------------------------------------------------------*/
#if(UART_ENABLE != USIC_DISABLED_ALL)
void UART_Set_POT_ADC(void)
{
10001146:	b538      	push	{r3, r4, r5, lr}
  #if(UART_ENABLE == USIC_DISABLED_ALL)
  uint16_t pot_adc_result;
  #endif

  /* EMPTY = 0, receive buffer is not empty.*/
  if ((USIC0_CHX_TRBSR & 0x00000008) == 0)
10001148:	4b85      	ldr	r3, [pc, #532]	; (10001360 <UART_Set_POT_ADC+0x21c>)
1000114a:	0052      	lsls	r2, r2, #1
1000114c:	589a      	ldr	r2, [r3, r2]
1000114e:	0712      	lsls	r2, r2, #28
10001150:	d53a      	bpl.n	100011c8 <UART_Set_POT_ADC+0x84>
    {


    }

    Motor.UART_Debug_Counter++;
10001152:	4c84      	ldr	r4, [pc, #528]	; (10001364 <UART_Set_POT_ADC+0x220>)
10001154:	6d63      	ldr	r3, [r4, #84]	; 0x54
10001156:	3301      	adds	r3, #1
    if (Motor.UART_Debug_Counter > UART_SPEED_UPDATE_RATE)
10001158:	2b5a      	cmp	r3, #90	; 0x5a
1000115a:	d933      	bls.n	100011c4 <UART_Set_POT_ADC+0x80>
    {
      Motor.UART_Debug_Counter = 0;
1000115c:	2300      	movs	r3, #0
1000115e:	6563      	str	r3, [r4, #84]	; 0x54

      switch (Motor.State)
10001160:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10001162:	2b02      	cmp	r3, #2
10001164:	d04e      	beq.n	10001204 <UART_Set_POT_ADC+0xc0>
10001166:	2b09      	cmp	r3, #9
10001168:	d048      	beq.n	100011fc <UART_Set_POT_ADC+0xb8>

          break;

        default:
          /* Process for all other cases. Normal operation. */
          UART_TX_String("\r\n rpm:");
1000116a:	487f      	ldr	r0, [pc, #508]	; (10001368 <UART_Set_POT_ADC+0x224>)
1000116c:	f000 fca6 	bl	10001abc <UART_TX_String>


          Speed_in_rpm = (Motor.Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM;
10001170:	68a3      	ldr	r3, [r4, #8]
10001172:	4d7e      	ldr	r5, [pc, #504]	; (1000136c <UART_Set_POT_ADC+0x228>)
10001174:	00d8      	lsls	r0, r3, #3
10001176:	18c0      	adds	r0, r0, r3
10001178:	0183      	lsls	r3, r0, #6
1000117a:	18c0      	adds	r0, r0, r3
1000117c:	0ac0      	lsrs	r0, r0, #11
1000117e:	6028      	str	r0, [r5, #0]
          Motor.speed_in_rpm = Speed_in_rpm;
10001180:	6120      	str	r0, [r4, #16]
          /* Debug information, showing rotor speed in rpm. */
          UART_TX_uint16_t(Speed_in_rpm);
10001182:	b280      	uxth	r0, r0
10001184:	f000 fcc0 	bl	10001b08 <UART_TX_uint16_t>

          Speed_in_rpm -= ((Motor.Ref_Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM);
10001188:	6863      	ldr	r3, [r4, #4]
          UART_TX_String("\t\t Ref");
1000118a:	4879      	ldr	r0, [pc, #484]	; (10001370 <UART_Set_POT_ADC+0x22c>)
          Speed_in_rpm = (Motor.Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM;
          Motor.speed_in_rpm = Speed_in_rpm;
          /* Debug information, showing rotor speed in rpm. */
          UART_TX_uint16_t(Speed_in_rpm);

          Speed_in_rpm -= ((Motor.Ref_Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM);
1000118c:	00da      	lsls	r2, r3, #3
1000118e:	18d2      	adds	r2, r2, r3
10001190:	0193      	lsls	r3, r2, #6
10001192:	18d3      	adds	r3, r2, r3
10001194:	682a      	ldr	r2, [r5, #0]
10001196:	0adb      	lsrs	r3, r3, #11
10001198:	1ad3      	subs	r3, r2, r3
1000119a:	602b      	str	r3, [r5, #0]
          UART_TX_String("\t\t Ref");
1000119c:	f000 fc8e 	bl	10001abc <UART_TX_String>
          if (Speed_in_rpm < 0)
100011a0:	682b      	ldr	r3, [r5, #0]
100011a2:	2b00      	cmp	r3, #0
100011a4:	da00      	bge.n	100011a8 <UART_Set_POT_ADC+0x64>
100011a6:	e0c8      	b.n	1000133a <UART_Set_POT_ADC+0x1f6>
            Speed_in_rpm = -Speed_in_rpm;
            UART_TX_String(" -");
          }
          else
          {
            UART_TX_String(" +");
100011a8:	4872      	ldr	r0, [pc, #456]	; (10001374 <UART_Set_POT_ADC+0x230>)
100011aa:	f000 fc87 	bl	10001abc <UART_TX_String>
          }
          /* Debug information, showing speed error in rpm. */
          UART_TX_uint16_t(Speed_in_rpm);
100011ae:	8828      	ldrh	r0, [r5, #0]
100011b0:	f000 fcaa 	bl	10001b08 <UART_TX_uint16_t>

          UART_TX_String("\t POT");
100011b4:	4870      	ldr	r0, [pc, #448]	; (10001378 <UART_Set_POT_ADC+0x234>)
100011b6:	f000 fc81 	bl	10001abc <UART_TX_String>
          UART_TX_uint16_t(ADC.ADC_POT);
100011ba:	4b70      	ldr	r3, [pc, #448]	; (1000137c <UART_Set_POT_ADC+0x238>)
100011bc:	8c18      	ldrh	r0, [r3, #32]
100011be:	f000 fca3 	bl	10001b08 <UART_TX_uint16_t>

          break;
100011c2:	e000      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
    {


    }

    Motor.UART_Debug_Counter++;
100011c4:	6563      	str	r3, [r4, #84]	; 0x54

          break;
      }
    }
  }
}
100011c6:	bd38      	pop	{r3, r4, r5, pc}

  /* EMPTY = 0, receive buffer is not empty.*/
  if ((USIC0_CHX_TRBSR & 0x00000008) == 0)
  {
    /*Data received via UART.*/
    UART_Received_Data = (USIC0_CHX_OUTR & 0x0000FFFF);
100011c8:	228e      	movs	r2, #142	; 0x8e
100011ca:	0052      	lsls	r2, r2, #1
100011cc:	589b      	ldr	r3, [r3, r2]
100011ce:	4c6c      	ldr	r4, [pc, #432]	; (10001380 <UART_Set_POT_ADC+0x23c>)

    /* Send carriage return, and new line.*/
    UART_TX_Return_NewLine(0x02);
100011d0:	2002      	movs	r0, #2

  /* EMPTY = 0, receive buffer is not empty.*/
  if ((USIC0_CHX_TRBSR & 0x00000008) == 0)
  {
    /*Data received via UART.*/
    UART_Received_Data = (USIC0_CHX_OUTR & 0x0000FFFF);
100011d2:	8023      	strh	r3, [r4, #0]

    /* Send carriage return, and new line.*/
    UART_TX_Return_NewLine(0x02);
100011d4:	f000 fc86 	bl	10001ae4 <UART_TX_Return_NewLine>
    /* Debug information.*/
    UART_TX_String("Speed Ref (rpm)");
100011d8:	486a      	ldr	r0, [pc, #424]	; (10001384 <UART_Set_POT_ADC+0x240>)
100011da:	f000 fc6f 	bl	10001abc <UART_TX_String>

    if ((UART_Received_Data == 'x') || (UART_Received_Data == 'X'))
100011de:	8823      	ldrh	r3, [r4, #0]
100011e0:	2220      	movs	r2, #32
100011e2:	1c19      	adds	r1, r3, #0
100011e4:	4391      	bics	r1, r2
100011e6:	2958      	cmp	r1, #88	; 0x58
100011e8:	d01a      	beq.n	10001220 <UART_Set_POT_ADC+0xdc>
      UART_TX_String(" by POT ADC");
    }
    else
    {
      /* Use UART to adjust POT ADC, and hence target motor speed.*/
      switch (UART_Received_Data)
100011ea:	3b20      	subs	r3, #32
100011ec:	b29b      	uxth	r3, r3
100011ee:	2b41      	cmp	r3, #65	; 0x41
100011f0:	d900      	bls.n	100011f4 <UART_Set_POT_ADC+0xb0>
100011f2:	e09e      	b.n	10001332 <UART_Set_POT_ADC+0x1ee>
100011f4:	4a64      	ldr	r2, [pc, #400]	; (10001388 <UART_Set_POT_ADC+0x244>)
100011f6:	009b      	lsls	r3, r3, #2
100011f8:	58d3      	ldr	r3, [r2, r3]
100011fa:	469f      	mov	pc, r3

      switch (Motor.State)
      {
        /* CCU8 TRAP has occurred.*/
        case TRAP_PROTECTION:
          UART_TX_String("\r\n\n\nCCU8 Trap!, key in 0");
100011fc:	4863      	ldr	r0, [pc, #396]	; (1000138c <UART_Set_POT_ADC+0x248>)
100011fe:	f000 fc5d 	bl	10001abc <UART_TX_String>
          break;
10001202:	e7e0      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case BRAKE_BOOTSTRAP:
          UART_TX_String("\r\n ADC Bias:");
10001204:	4862      	ldr	r0, [pc, #392]	; (10001390 <UART_Set_POT_ADC+0x24c>)
10001206:	f000 fc59 	bl	10001abc <UART_TX_String>
          /* Bias of ADC Iu.*/
          UART_TX_uint16_t(ADC.ADC_Bias_Iu);
1000120a:	4c5c      	ldr	r4, [pc, #368]	; (1000137c <UART_Set_POT_ADC+0x238>)
1000120c:	8920      	ldrh	r0, [r4, #8]
1000120e:	f000 fc7b 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_uint16_t(ADC.ADC_Bias_Iv);
10001212:	89a0      	ldrh	r0, [r4, #12]
10001214:	f000 fc78 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_uint16_t(ADC.ADC_Bias_Iw);
10001218:	8a20      	ldrh	r0, [r4, #16]
1000121a:	f000 fc75 	bl	10001b08 <UART_TX_uint16_t>

          break;
1000121e:	e7d2      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
    UART_TX_String("Speed Ref (rpm)");

    if ((UART_Received_Data == 'x') || (UART_Received_Data == 'X'))
    {
      /* Motor speed adjusted by POT ADC. */
      UART_TX_String(" by POT ADC");
10001220:	485c      	ldr	r0, [pc, #368]	; (10001394 <UART_Set_POT_ADC+0x250>)
10001222:	f000 fc4b 	bl	10001abc <UART_TX_String>
10001226:	e7ce      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
          UART_TX_uint16_t(MOTOR_SPEED_9);
          UART_TX_String(" ->90%");
          break;

        case 'a':
          ADC.ADC_POT = FOR_MOTOR_SPEED_A;
10001228:	2280      	movs	r2, #128	; 0x80
1000122a:	4b54      	ldr	r3, [pc, #336]	; (1000137c <UART_Set_POT_ADC+0x238>)
1000122c:	0152      	lsls	r2, r2, #5
          /* 100% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_A);
1000122e:	485a      	ldr	r0, [pc, #360]	; (10001398 <UART_Set_POT_ADC+0x254>)
          UART_TX_uint16_t(MOTOR_SPEED_9);
          UART_TX_String(" ->90%");
          break;

        case 'a':
          ADC.ADC_POT = FOR_MOTOR_SPEED_A;
10001230:	621a      	str	r2, [r3, #32]
          /* 100% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_A);
10001232:	f000 fc69 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->100%");
10001236:	4859      	ldr	r0, [pc, #356]	; (1000139c <UART_Set_POT_ADC+0x258>)
10001238:	f000 fc40 	bl	10001abc <UART_TX_String>
          break;
1000123c:	e7c3      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
      switch (UART_Received_Data)
      {
        /* '0', or space bar (or blank or space key).*/
        case '0':
        case ' ':
          ADC.ADC_POT = FOR_MOTOR_SPEED_0;
1000123e:	2200      	movs	r2, #0
10001240:	4b4e      	ldr	r3, [pc, #312]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* Speed 0rpm. Stop motor. */
          UART_TX_uint16_t(MOTOR_SPEED_0);
10001242:	2000      	movs	r0, #0
      switch (UART_Received_Data)
      {
        /* '0', or space bar (or blank or space key).*/
        case '0':
        case ' ':
          ADC.ADC_POT = FOR_MOTOR_SPEED_0;
10001244:	621a      	str	r2, [r3, #32]
          /* Speed 0rpm. Stop motor. */
          UART_TX_uint16_t(MOTOR_SPEED_0);
10001246:	f000 fc5f 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->Stop");
1000124a:	4855      	ldr	r0, [pc, #340]	; (100013a0 <UART_Set_POT_ADC+0x25c>)
1000124c:	f000 fc36 	bl	10001abc <UART_TX_String>
          break;
10001250:	e7b9      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
          UART_TX_String(" ->100%");
          break;

        case '=':
        case '+':
          if (ADC.ADC_POT <= (FOR_MOTOR_SPEED_A - ADC_FOR_STEP_50_RPM ))
10001252:	2280      	movs	r2, #128	; 0x80
10001254:	4b49      	ldr	r3, [pc, #292]	; (1000137c <UART_Set_POT_ADC+0x238>)
10001256:	0152      	lsls	r2, r2, #5
10001258:	6a19      	ldr	r1, [r3, #32]
1000125a:	4291      	cmp	r1, r2
1000125c:	d873      	bhi.n	10001346 <UART_Set_POT_ADC+0x202>
          {
            ADC.ADC_POT += ADC_FOR_STEP_50_RPM;
            /* Speed + 50rpm */
            UART_TX_String(" +50 rpm");
1000125e:	4851      	ldr	r0, [pc, #324]	; (100013a4 <UART_Set_POT_ADC+0x260>)
10001260:	f000 fc2c 	bl	10001abc <UART_TX_String>
10001264:	e7af      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
            UART_TX_uint16_t(MOTOR_SPEED_A);
          }
          break;

        case '-':                 // '-'.
          if (ADC.ADC_POT >= (FOR_MOTOR_SPEED_1 + ADC_FOR_STEP_50_RPM ))
10001266:	22cc      	movs	r2, #204	; 0xcc
10001268:	4b44      	ldr	r3, [pc, #272]	; (1000137c <UART_Set_POT_ADC+0x238>)
1000126a:	0052      	lsls	r2, r2, #1
1000126c:	6a19      	ldr	r1, [r3, #32]
1000126e:	4291      	cmp	r1, r2
10001270:	d96e      	bls.n	10001350 <UART_Set_POT_ADC+0x20c>
          {
            ADC.ADC_POT -= ADC_FOR_STEP_50_RPM;
            /* Speed - 50rpm. */
            UART_TX_String(" -50 rpm");
10001272:	484d      	ldr	r0, [pc, #308]	; (100013a8 <UART_Set_POT_ADC+0x264>)
10001274:	f000 fc22 	bl	10001abc <UART_TX_String>
10001278:	e7a5      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
          UART_TX_uint16_t(MOTOR_SPEED_0);
          UART_TX_String(" ->Stop");
          break;

        case '1':
          ADC.ADC_POT = FOR_MOTOR_SPEED_1;
1000127a:	229a      	movs	r2, #154	; 0x9a
1000127c:	4b3f      	ldr	r3, [pc, #252]	; (1000137c <UART_Set_POT_ADC+0x238>)
1000127e:	32ff      	adds	r2, #255	; 0xff
          /* 10% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_1);
10001280:	484a      	ldr	r0, [pc, #296]	; (100013ac <UART_Set_POT_ADC+0x268>)
          UART_TX_uint16_t(MOTOR_SPEED_0);
          UART_TX_String(" ->Stop");
          break;

        case '1':
          ADC.ADC_POT = FOR_MOTOR_SPEED_1;
10001282:	621a      	str	r2, [r3, #32]
          /* 10% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_1);
10001284:	f000 fc40 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->10%");
10001288:	4849      	ldr	r0, [pc, #292]	; (100013b0 <UART_Set_POT_ADC+0x26c>)
1000128a:	f000 fc17 	bl	10001abc <UART_TX_String>
          break;
1000128e:	e79a      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '2':
          ADC.ADC_POT = FOR_MOTOR_SPEED_2;
10001290:	4a48      	ldr	r2, [pc, #288]	; (100013b4 <UART_Set_POT_ADC+0x270>)
10001292:	4b3a      	ldr	r3, [pc, #232]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /*  20% of max speed.*/
          UART_TX_uint16_t(MOTOR_SPEED_2);
10001294:	4848      	ldr	r0, [pc, #288]	; (100013b8 <UART_Set_POT_ADC+0x274>)
          UART_TX_uint16_t(MOTOR_SPEED_1);
          UART_TX_String(" ->10%");
          break;

        case '2':
          ADC.ADC_POT = FOR_MOTOR_SPEED_2;
10001296:	621a      	str	r2, [r3, #32]
          /*  20% of max speed.*/
          UART_TX_uint16_t(MOTOR_SPEED_2);
10001298:	f000 fc36 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->20%");
1000129c:	4847      	ldr	r0, [pc, #284]	; (100013bc <UART_Set_POT_ADC+0x278>)
1000129e:	f000 fc0d 	bl	10001abc <UART_TX_String>
          break;
100012a2:	e790      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '3':
          ADC.ADC_POT = FOR_MOTOR_SPEED_3;
100012a4:	4a46      	ldr	r2, [pc, #280]	; (100013c0 <UART_Set_POT_ADC+0x27c>)
100012a6:	4b35      	ldr	r3, [pc, #212]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* 30% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_3);
100012a8:	4846      	ldr	r0, [pc, #280]	; (100013c4 <UART_Set_POT_ADC+0x280>)
          UART_TX_uint16_t(MOTOR_SPEED_2);
          UART_TX_String(" ->20%");
          break;

        case '3':
          ADC.ADC_POT = FOR_MOTOR_SPEED_3;
100012aa:	621a      	str	r2, [r3, #32]
          /* 30% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_3);
100012ac:	f000 fc2c 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->30%");
100012b0:	4845      	ldr	r0, [pc, #276]	; (100013c8 <UART_Set_POT_ADC+0x284>)
100012b2:	f000 fc03 	bl	10001abc <UART_TX_String>
          break;
100012b6:	e786      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '4':
          ADC.ADC_POT = FOR_MOTOR_SPEED_4;
100012b8:	4a44      	ldr	r2, [pc, #272]	; (100013cc <UART_Set_POT_ADC+0x288>)
100012ba:	4b30      	ldr	r3, [pc, #192]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /*  40% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_4);
100012bc:	4844      	ldr	r0, [pc, #272]	; (100013d0 <UART_Set_POT_ADC+0x28c>)
          UART_TX_uint16_t(MOTOR_SPEED_3);
          UART_TX_String(" ->30%");
          break;

        case '4':
          ADC.ADC_POT = FOR_MOTOR_SPEED_4;
100012be:	621a      	str	r2, [r3, #32]
          /*  40% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_4);
100012c0:	f000 fc22 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->40%");
100012c4:	4843      	ldr	r0, [pc, #268]	; (100013d4 <UART_Set_POT_ADC+0x290>)
100012c6:	f000 fbf9 	bl	10001abc <UART_TX_String>
          break;
100012ca:	e77c      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '5':
          ADC.ADC_POT = FOR_MOTOR_SPEED_5;
100012cc:	2280      	movs	r2, #128	; 0x80
100012ce:	4b2b      	ldr	r3, [pc, #172]	; (1000137c <UART_Set_POT_ADC+0x238>)
100012d0:	0112      	lsls	r2, r2, #4
          /* 50% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_5);
100012d2:	4841      	ldr	r0, [pc, #260]	; (100013d8 <UART_Set_POT_ADC+0x294>)
          UART_TX_uint16_t(MOTOR_SPEED_4);
          UART_TX_String(" ->40%");
          break;

        case '5':
          ADC.ADC_POT = FOR_MOTOR_SPEED_5;
100012d4:	621a      	str	r2, [r3, #32]
          /* 50% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_5);
100012d6:	f000 fc17 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->50%");
100012da:	4840      	ldr	r0, [pc, #256]	; (100013dc <UART_Set_POT_ADC+0x298>)
100012dc:	f000 fbee 	bl	10001abc <UART_TX_String>
          break;
100012e0:	e771      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '6':
          ADC.ADC_POT = FOR_MOTOR_SPEED_6;
100012e2:	4a3f      	ldr	r2, [pc, #252]	; (100013e0 <UART_Set_POT_ADC+0x29c>)
100012e4:	4b25      	ldr	r3, [pc, #148]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* 60% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_6);
100012e6:	483f      	ldr	r0, [pc, #252]	; (100013e4 <UART_Set_POT_ADC+0x2a0>)
          UART_TX_uint16_t(MOTOR_SPEED_5);
          UART_TX_String(" ->50%");
          break;

        case '6':
          ADC.ADC_POT = FOR_MOTOR_SPEED_6;
100012e8:	621a      	str	r2, [r3, #32]
          /* 60% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_6);
100012ea:	f000 fc0d 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->60%");
100012ee:	483e      	ldr	r0, [pc, #248]	; (100013e8 <UART_Set_POT_ADC+0x2a4>)
100012f0:	f000 fbe4 	bl	10001abc <UART_TX_String>
          break;
100012f4:	e767      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '7':
          ADC.ADC_POT = FOR_MOTOR_SPEED_7;
100012f6:	4a3d      	ldr	r2, [pc, #244]	; (100013ec <UART_Set_POT_ADC+0x2a8>)
100012f8:	4b20      	ldr	r3, [pc, #128]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* 70% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_7);
100012fa:	483d      	ldr	r0, [pc, #244]	; (100013f0 <UART_Set_POT_ADC+0x2ac>)
          UART_TX_uint16_t(MOTOR_SPEED_6);
          UART_TX_String(" ->60%");
          break;

        case '7':
          ADC.ADC_POT = FOR_MOTOR_SPEED_7;
100012fc:	621a      	str	r2, [r3, #32]
          /* 70% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_7);
100012fe:	f000 fc03 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->70%");
10001302:	483c      	ldr	r0, [pc, #240]	; (100013f4 <UART_Set_POT_ADC+0x2b0>)
10001304:	f000 fbda 	bl	10001abc <UART_TX_String>
          break;
10001308:	e75d      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '8':
          ADC.ADC_POT = FOR_MOTOR_SPEED_8;
1000130a:	4a3b      	ldr	r2, [pc, #236]	; (100013f8 <UART_Set_POT_ADC+0x2b4>)
1000130c:	4b1b      	ldr	r3, [pc, #108]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* 80% of max speed.*/
          UART_TX_uint16_t(MOTOR_SPEED_8);
1000130e:	483b      	ldr	r0, [pc, #236]	; (100013fc <UART_Set_POT_ADC+0x2b8>)
          UART_TX_uint16_t(MOTOR_SPEED_7);
          UART_TX_String(" ->70%");
          break;

        case '8':
          ADC.ADC_POT = FOR_MOTOR_SPEED_8;
10001310:	621a      	str	r2, [r3, #32]
          /* 80% of max speed.*/
          UART_TX_uint16_t(MOTOR_SPEED_8);
10001312:	f000 fbf9 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->80%");
10001316:	483a      	ldr	r0, [pc, #232]	; (10001400 <UART_Set_POT_ADC+0x2bc>)
10001318:	f000 fbd0 	bl	10001abc <UART_TX_String>
          break;
1000131c:	e753      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

        case '9':
          ADC.ADC_POT = FOR_MOTOR_SPEED_9;
1000131e:	4a39      	ldr	r2, [pc, #228]	; (10001404 <UART_Set_POT_ADC+0x2c0>)
10001320:	4b16      	ldr	r3, [pc, #88]	; (1000137c <UART_Set_POT_ADC+0x238>)
          /* 90% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_9);
10001322:	4839      	ldr	r0, [pc, #228]	; (10001408 <UART_Set_POT_ADC+0x2c4>)
          UART_TX_uint16_t(MOTOR_SPEED_8);
          UART_TX_String(" ->80%");
          break;

        case '9':
          ADC.ADC_POT = FOR_MOTOR_SPEED_9;
10001324:	621a      	str	r2, [r3, #32]
          /* 90% of max speed. */
          UART_TX_uint16_t(MOTOR_SPEED_9);
10001326:	f000 fbef 	bl	10001b08 <UART_TX_uint16_t>
          UART_TX_String(" ->90%");
1000132a:	4838      	ldr	r0, [pc, #224]	; (1000140c <UART_Set_POT_ADC+0x2c8>)
1000132c:	f000 fbc6 	bl	10001abc <UART_TX_String>
          break;
10001330:	e749      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
          }
          break;

        default:
          /* Process for all other cases, no update of POT ADC. */
          UART_TX_String(" no change");
10001332:	4837      	ldr	r0, [pc, #220]	; (10001410 <UART_Set_POT_ADC+0x2cc>)
10001334:	f000 fbc2 	bl	10001abc <UART_TX_String>
          break;
10001338:	e745      	b.n	100011c6 <UART_Set_POT_ADC+0x82>

          Speed_in_rpm -= ((Motor.Ref_Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM);
          UART_TX_String("\t\t Ref");
          if (Speed_in_rpm < 0)
          {
            Speed_in_rpm = -Speed_in_rpm;
1000133a:	425b      	negs	r3, r3
            UART_TX_String(" -");
1000133c:	4835      	ldr	r0, [pc, #212]	; (10001414 <UART_Set_POT_ADC+0x2d0>)

          Speed_in_rpm -= ((Motor.Ref_Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM);
          UART_TX_String("\t\t Ref");
          if (Speed_in_rpm < 0)
          {
            Speed_in_rpm = -Speed_in_rpm;
1000133e:	602b      	str	r3, [r5, #0]
            UART_TX_String(" -");
10001340:	f000 fbbc 	bl	10001abc <UART_TX_String>
10001344:	e733      	b.n	100011ae <UART_Set_POT_ADC+0x6a>
          }
          else
          {
            ADC.ADC_POT = FOR_MOTOR_SPEED_A;
            /* 100% of max speed. */
            UART_TX_uint16_t(MOTOR_SPEED_A);
10001346:	4814      	ldr	r0, [pc, #80]	; (10001398 <UART_Set_POT_ADC+0x254>)
            /* Speed + 50rpm */
            UART_TX_String(" +50 rpm");
          }
          else
          {
            ADC.ADC_POT = FOR_MOTOR_SPEED_A;
10001348:	621a      	str	r2, [r3, #32]
            /* 100% of max speed. */
            UART_TX_uint16_t(MOTOR_SPEED_A);
1000134a:	f000 fbdd 	bl	10001b08 <UART_TX_uint16_t>
1000134e:	e73a      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
            /* Speed - 50rpm. */
            UART_TX_String(" -50 rpm");
          }
          else
          {
            ADC.ADC_POT = FOR_MOTOR_SPEED_1;
10001350:	229a      	movs	r2, #154	; 0x9a
            /*  10% of max speed. */
            UART_TX_uint16_t(MOTOR_SPEED_1);
10001352:	4816      	ldr	r0, [pc, #88]	; (100013ac <UART_Set_POT_ADC+0x268>)
            /* Speed - 50rpm. */
            UART_TX_String(" -50 rpm");
          }
          else
          {
            ADC.ADC_POT = FOR_MOTOR_SPEED_1;
10001354:	32ff      	adds	r2, #255	; 0xff
10001356:	621a      	str	r2, [r3, #32]
            /*  10% of max speed. */
            UART_TX_uint16_t(MOTOR_SPEED_1);
10001358:	f000 fbd6 	bl	10001b08 <UART_TX_uint16_t>
1000135c:	e733      	b.n	100011c6 <UART_Set_POT_ADC+0x82>
1000135e:	46c0      	nop			; (mov r8, r8)
10001360:	48000200 	.word	0x48000200
10001364:	20001244 	.word	0x20001244
10001368:	10002fd4 	.word	0x10002fd4
1000136c:	20001010 	.word	0x20001010
10001370:	10002fdc 	.word	0x10002fdc
10001374:	10002fe8 	.word	0x10002fe8
10001378:	10002fec 	.word	0x10002fec
1000137c:	20001050 	.word	0x20001050
10001380:	20000548 	.word	0x20000548
10001384:	10002f10 	.word	0x10002f10
10001388:	10002e08 	.word	0x10002e08
1000138c:	10002fa8 	.word	0x10002fa8
10001390:	10002fc4 	.word	0x10002fc4
10001394:	10002f20 	.word	0x10002f20
10001398:	0000b7ae 	.word	0x0000b7ae
1000139c:	10002f7c 	.word	0x10002f7c
100013a0:	10002f2c 	.word	0x10002f2c
100013a4:	10002f84 	.word	0x10002f84
100013a8:	10002f90 	.word	0x10002f90
100013ac:	0000125e 	.word	0x0000125e
100013b0:	10002f34 	.word	0x10002f34
100013b4:	00000333 	.word	0x00000333
100013b8:	000024bc 	.word	0x000024bc
100013bc:	10002f3c 	.word	0x10002f3c
100013c0:	000004cc 	.word	0x000004cc
100013c4:	0000371a 	.word	0x0000371a
100013c8:	10002f44 	.word	0x10002f44
100013cc:	00000666 	.word	0x00000666
100013d0:	00004978 	.word	0x00004978
100013d4:	10002f4c 	.word	0x10002f4c
100013d8:	00005bd7 	.word	0x00005bd7
100013dc:	10002f54 	.word	0x10002f54
100013e0:	00000999 	.word	0x00000999
100013e4:	00006e35 	.word	0x00006e35
100013e8:	10002f5c 	.word	0x10002f5c
100013ec:	00000b33 	.word	0x00000b33
100013f0:	00008093 	.word	0x00008093
100013f4:	10002f64 	.word	0x10002f64
100013f8:	00000ccc 	.word	0x00000ccc
100013fc:	000092f1 	.word	0x000092f1
10001400:	10002f6c 	.word	0x10002f6c
10001404:	00000e66 	.word	0x00000e66
10001408:	0000a54f 	.word	0x0000a54f
1000140c:	10002f74 	.word	0x10002f74
10001410:	10002f9c 	.word	0x10002f9c
10001414:	10002fe4 	.word	0x10002fe4

10001418 <ADC_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/
#if (CURRENT_SENSING ==  USER_THREE_SHUNT_SYNC_CONV)
/* API to initialize VADC module for 3-shunt phase current sensing */
void ADC_Init(void)
{
10001418:	b5f0      	push	{r4, r5, r6, r7, lr}
1000141a:	4647      	mov	r7, r8
  #if(INTERNAL_OP_GAIN == ENABLED)
  uint32_t gain_factor;
  #endif

	XMC_VADC_GLOBAL_Init(VADC, &VADC_global_config);
1000141c:	4c44      	ldr	r4, [pc, #272]	; (10001530 <ADC_Init+0x118>)
	XMC_VADC_GROUP_Init(VADC_G0, &VADC_grp0_init);
1000141e:	4e45      	ldr	r6, [pc, #276]	; (10001534 <ADC_Init+0x11c>)
 * API IMPLEMENTATION
 ********************************************************************************************************************/
#if (CURRENT_SENSING ==  USER_THREE_SHUNT_SYNC_CONV)
/* API to initialize VADC module for 3-shunt phase current sensing */
void ADC_Init(void)
{
10001420:	b480      	push	{r7}
  uint32_t gain_factor;
  #endif

	XMC_VADC_GLOBAL_Init(VADC, &VADC_global_config);
	XMC_VADC_GROUP_Init(VADC_G0, &VADC_grp0_init);
	XMC_VADC_GROUP_Init(VADC_G1, &VADC_grp1_init);
10001422:	4d45      	ldr	r5, [pc, #276]	; (10001538 <ADC_Init+0x120>)
{
  #if(INTERNAL_OP_GAIN == ENABLED)
  uint32_t gain_factor;
  #endif

	XMC_VADC_GLOBAL_Init(VADC, &VADC_global_config);
10001424:	1c20      	adds	r0, r4, #0
10001426:	4945      	ldr	r1, [pc, #276]	; (1000153c <ADC_Init+0x124>)
10001428:	f001 f966 	bl	100026f8 <XMC_VADC_GLOBAL_Init>
	XMC_VADC_GROUP_Init(VADC_G0, &VADC_grp0_init);
1000142c:	1c30      	adds	r0, r6, #0
1000142e:	4944      	ldr	r1, [pc, #272]	; (10001540 <ADC_Init+0x128>)
10001430:	f001 f9a8 	bl	10002784 <XMC_VADC_GROUP_Init>
	XMC_VADC_GROUP_Init(VADC_G1, &VADC_grp1_init);
10001434:	1c28      	adds	r0, r5, #0
10001436:	4943      	ldr	r1, [pc, #268]	; (10001544 <ADC_Init+0x12c>)
10001438:	f001 f9a4 	bl	10002784 <XMC_VADC_GROUP_Init>

	/* Configuration of VADC_G1/0,  Turn on ADC modules */
	XMC_VADC_GROUP_SetPowerMode(VADC_G0, XMC_VADC_GROUP_POWERMODE_NORMAL);
1000143c:	1c30      	adds	r0, r6, #0
1000143e:	2103      	movs	r1, #3
10001440:	f001 fa0a 	bl	10002858 <XMC_VADC_GROUP_SetPowerMode>
	XMC_VADC_GROUP_SetPowerMode(VADC_G1, XMC_VADC_GROUP_POWERMODE_NORMAL);
10001444:	1c28      	adds	r0, r5, #0
10001446:	2103      	movs	r1, #3
10001448:	f001 fa06 	bl	10002858 <XMC_VADC_GROUP_SetPowerMode>

	/* Trigger Start-up Calibration */
	XMC_VADC_GLOBAL_StartupCalibration(VADC);
1000144c:	1c20      	adds	r0, r4, #0
1000144e:	f001 f975 	bl	1000273c <XMC_VADC_GLOBAL_StartupCalibration>

__STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uint32_t group_number)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
10001452:	2380      	movs	r3, #128	; 0x80
10001454:	2180      	movs	r1, #128	; 0x80
10001456:	58e2      	ldr	r2, [r4, r3]
10001458:	0249      	lsls	r1, r1, #9
1000145a:	430a      	orrs	r2, r1
1000145c:	2180      	movs	r1, #128	; 0x80
1000145e:	50e2      	str	r2, [r4, r3]
10001460:	58e2      	ldr	r2, [r4, r3]
10001462:	0289      	lsls	r1, r1, #10
10001464:	430a      	orrs	r2, r1
10001466:	50e2      	str	r2, [r4, r3]
	XMC_VADC_GLOBAL_DisablePostCalibration(VADC, 0U);
	XMC_VADC_GLOBAL_DisablePostCalibration(VADC, 1U);

	/* Configuration of VADC_G1 - Q source */
	/* External trigger	1,  refill 1 */
	XMC_VADC_GROUP_QueueInit(VADC_G1, &VADC_grp_queue_config);
10001468:	1c28      	adds	r0, r5, #0
1000146a:	4937      	ldr	r1, [pc, #220]	; (10001548 <ADC_Init+0x130>)
1000146c:	f001 fa2a 	bl	100028c4 <XMC_VADC_GROUP_QueueInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
10001470:	2382      	movs	r3, #130	; 0x82
10001472:	2103      	movs	r1, #3
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
10001474:	2701      	movs	r7, #1
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
10001476:	005b      	lsls	r3, r3, #1
10001478:	58ea      	ldr	r2, [r5, r3]
1000147a:	4688      	mov	r8, r1
1000147c:	438a      	bics	r2, r1
1000147e:	50ea      	str	r2, [r5, r3]
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
10001480:	58ea      	ldr	r2, [r5, r3]
    XMC_VADC_GROUP_ChannelInit(VADC_IDC_GROUP, VADC_IDC_CHANNEL, &VADC_channel_idc_init);

  }
	/* Master group - G1 for Synchronous ADC */
	/* I1, Result Register RES0 */
	XMC_VADC_GROUP_ChannelInit(VADC_I1_GROUP, VADC_I1_CHANNEL, &VADC_grp1_ch0_init);
10001482:	1c28      	adds	r0, r5, #0
10001484:	433a      	orrs	r2, r7
10001486:	50ea      	str	r2, [r5, r3]
10001488:	4b30      	ldr	r3, [pc, #192]	; (1000154c <ADC_Init+0x134>)
1000148a:	2100      	movs	r1, #0
1000148c:	681a      	ldr	r2, [r3, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
1000148e:	2388      	movs	r3, #136	; 0x88
10001490:	005b      	lsls	r3, r3, #1
10001492:	50ea      	str	r2, [r5, r3]
10001494:	4a2e      	ldr	r2, [pc, #184]	; (10001550 <ADC_Init+0x138>)

  if(VADC_IDC_GROUP_NO == 0)
  {
    XMC_VADC_GROUP_ScanAddChannelToSequence(VADC_IDC_GROUP,VADC_IDC_CHANNEL);
  }
}
10001496:	6812      	ldr	r2, [r2, #0]
10001498:	50ea      	str	r2, [r5, r3]
    XMC_VADC_GROUP_ChannelInit(VADC_IDC_GROUP, VADC_IDC_CHANNEL, &VADC_channel_idc_init);

  }
	/* Master group - G1 for Synchronous ADC */
	/* I1, Result Register RES0 */
	XMC_VADC_GROUP_ChannelInit(VADC_I1_GROUP, VADC_I1_CHANNEL, &VADC_grp1_ch0_init);
1000149a:	4a2e      	ldr	r2, [pc, #184]	; (10001554 <ADC_Init+0x13c>)
1000149c:	f001 fa52 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>

	/* I3, Result Register RES1 */
	XMC_VADC_GROUP_ChannelInit(VADC_I3_GROUP, VADC_I3_CHANNEL, &VADC_grp1_ch1_init);
100014a0:	1c28      	adds	r0, r5, #0
100014a2:	2101      	movs	r1, #1
100014a4:	4a2c      	ldr	r2, [pc, #176]	; (10001558 <ADC_Init+0x140>)
100014a6:	f001 fa4d 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>

	/* I2, Result Register RES0 */
	XMC_VADC_GROUP_ChannelInit(VADC_I2_GROUP, VADC_I2_CHANNEL, &VADC_grp0_ch0_init);
100014aa:	1c30      	adds	r0, r6, #0
100014ac:	2100      	movs	r1, #0
100014ae:	4a2b      	ldr	r2, [pc, #172]	; (1000155c <ADC_Init+0x144>)
100014b0:	f001 fa48 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>

	/* Idc, Result Register RES1 */
	XMC_VADC_GROUP_ChannelInit(VADC_I4_GROUP, VADC_I4_CHANNEL, &VADC_grp0_ch1_init);
100014b4:	1c30      	adds	r0, r6, #0
100014b6:	4a2a      	ldr	r2, [pc, #168]	; (10001560 <ADC_Init+0x148>)
100014b8:	2101      	movs	r1, #1
100014ba:	f001 fa43 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>
  {
    XMC_VADC_GLOBAL_SHS_SetGainFactor(SHS0, gain_factor,XMC_VADC_GROUP_INDEX_1, VADC_IW_G1_CHANNEL);
  }
  #endif

	XMC_VADC_GROUP_SetPowerMode(VADC_G0, XMC_VADC_GROUP_POWERMODE_OFF);
100014be:	1c30      	adds	r0, r6, #0
100014c0:	2100      	movs	r1, #0
100014c2:	f001 f9c9 	bl	10002858 <XMC_VADC_GROUP_SetPowerMode>
	XMC_VADC_GROUP_SetPowerMode(VADC_G1, XMC_VADC_GROUP_POWERMODE_OFF);
100014c6:	1c28      	adds	r0, r5, #0
100014c8:	2100      	movs	r1, #0
100014ca:	f001 f9c5 	bl	10002858 <XMC_VADC_GROUP_SetPowerMode>

	/* G0: synchronization slave */
	XMC_VADC_GROUP_SetSyncSlave(VADC_G0, 1U, 0U);
100014ce:	2200      	movs	r2, #0
100014d0:	1c30      	adds	r0, r6, #0
100014d2:	2101      	movs	r1, #1
100014d4:	f001 f9c8 	bl	10002868 <XMC_VADC_GROUP_SetSyncSlave>

	/* Ready input R1 is considered */
	XMC_VADC_GROUP_CheckSlaveReadiness(VADC_G0, 0U);
100014d8:	1c30      	adds	r0, r6, #0
100014da:	2100      	movs	r1, #0
100014dc:	f001 f9d6 	bl	1000288c <XMC_VADC_GROUP_CheckSlaveReadiness>

	/* G1: synchronization master */
	XMC_VADC_GROUP_SetSyncMaster(VADC_G1);
100014e0:	1c28      	adds	r0, r5, #0
100014e2:	f001 f9cd 	bl	10002880 <XMC_VADC_GROUP_SetSyncMaster>

	/* ANONS = 11B: Normal Operation */
	XMC_VADC_GROUP_SetPowerMode(VADC_G1, XMC_VADC_GROUP_POWERMODE_NORMAL);
100014e6:	1c28      	adds	r0, r5, #0
100014e8:	2103      	movs	r1, #3
100014ea:	f001 f9b5 	bl	10002858 <XMC_VADC_GROUP_SetPowerMode>
 *  XMC_VADC_GROUP_BackgroundDisableContinuousMode()<BR>
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundEnableContinuousMode(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundEnableContinuousMode:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_SCAN_Msk;
100014ee:	2381      	movs	r3, #129	; 0x81
100014f0:	2210      	movs	r2, #16
100014f2:	009b      	lsls	r3, r3, #2
100014f4:	58e1      	ldr	r1, [r4, r3]
  XMC_VADC_GLOBAL_BackgroundEnableContinuousMode(VADC);
  XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);
  XMC_VADC_GLOBAL_BackgroundSetGatingMode(VADC,XMC_VADC_GATEMODE_IGNORE);


  XMC_VADC_GLOBAL_SHS_SetGainFactor(SHS0, SHS_GAIN_FACTOR_1,VADC_IDC_GROUP_NO, VADC_IDC_CHANNEL);
100014f6:	481b      	ldr	r0, [pc, #108]	; (10001564 <ADC_Init+0x14c>)
100014f8:	430a      	orrs	r2, r1
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerConversion(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerConversion:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
100014fa:	2180      	movs	r1, #128	; 0x80
 *  XMC_VADC_GROUP_BackgroundDisableContinuousMode()<BR>
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundEnableContinuousMode(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundEnableContinuousMode:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_SCAN_Msk;
100014fc:	50e2      	str	r2, [r4, r3]
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerConversion(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerConversion:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
100014fe:	58e2      	ldr	r2, [r4, r3]
10001500:	0089      	lsls	r1, r1, #2
10001502:	430a      	orrs	r2, r1
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  global_ptr->BRSMR &= (uint32_t)(~((uint32_t)VADC_BRSMR_ENGT_Msk));
10001504:	4641      	mov	r1, r8
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerConversion(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerConversion:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
10001506:	50e2      	str	r2, [r4, r3]
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  global_ptr->BRSMR &= (uint32_t)(~((uint32_t)VADC_BRSMR_ENGT_Msk));
10001508:	58e2      	ldr	r2, [r4, r3]
1000150a:	438a      	bics	r2, r1
1000150c:	50e2      	str	r2, [r4, r3]
  /* Configure the new gating mode*/
  global_ptr->BRSMR |= (uint32_t)((uint32_t)mode_sel << VADC_BRSMR_ENGT_Pos);
1000150e:	58e2      	ldr	r2, [r4, r3]
10001510:	2100      	movs	r1, #0
10001512:	4317      	orrs	r7, r2
10001514:	50e7      	str	r7, [r4, r3]
10001516:	2200      	movs	r2, #0
10001518:	2301      	movs	r3, #1
1000151a:	f001 f9bd 	bl	10002898 <XMC_VADC_GLOBAL_SHS_SetGainFactor>
__STATIC_INLINE void XMC_VADC_GROUP_ScanAddChannelToSequence(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num)
{
  XMC_ASSERT("VADC_GSCAN_AddSingleChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanAddChannelToSequence:Wrong Channel Number", 
             ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  group_ptr->ASSEL |= (uint32_t)((uint32_t)1 << ch_num);
1000151e:	2294      	movs	r2, #148	; 0x94
10001520:	2302      	movs	r3, #2
10001522:	0052      	lsls	r2, r2, #1
10001524:	58b1      	ldr	r1, [r6, r2]
10001526:	430b      	orrs	r3, r1
10001528:	50b3      	str	r3, [r6, r2]

  if(VADC_IDC_GROUP_NO == 0)
  {
    XMC_VADC_GROUP_ScanAddChannelToSequence(VADC_IDC_GROUP,VADC_IDC_CHANNEL);
  }
}
1000152a:	bc04      	pop	{r2}
1000152c:	4690      	mov	r8, r2
1000152e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10001530:	48030000 	.word	0x48030000
10001534:	48030400 	.word	0x48030400
10001538:	48030800 	.word	0x48030800
1000153c:	20000594 	.word	0x20000594
10001540:	200005b0 	.word	0x200005b0
10001544:	2000056c 	.word	0x2000056c
10001548:	200005ec 	.word	0x200005ec
1000154c:	200005e8 	.word	0x200005e8
10001550:	200005ac 	.word	0x200005ac
10001554:	200005d8 	.word	0x200005d8
10001558:	2000055c 	.word	0x2000055c
1000155c:	2000054c 	.word	0x2000054c
10001560:	20000580 	.word	0x20000580
10001564:	48034000 	.word	0x48034000

10001568 <ADC_Pot_Init>:
}
#endif

/* API to initialize VADC channel for potentiameter voltage sensing that is used to set user speed */
void ADC_Pot_Init(void)
{
10001568:	b510      	push	{r4, lr}
  /* Initializes the POT VADC channel for conversion */
  XMC_VADC_GROUP_ChannelInit(VADC_POT_GROUP, VADC_POT_CHANNEL, &VADC_channel_pot_init);
1000156a:	4c06      	ldr	r4, [pc, #24]	; (10001584 <ADC_Pot_Init+0x1c>)
1000156c:	2107      	movs	r1, #7
1000156e:	1c20      	adds	r0, r4, #0
10001570:	4a05      	ldr	r2, [pc, #20]	; (10001588 <ADC_Pot_Init+0x20>)
10001572:	f001 f9e7 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>
10001576:	4b05      	ldr	r3, [pc, #20]	; (1000158c <ADC_Pot_Init+0x24>)
  {
    /* Request to insert the channel to the queue source */
    XMC_VADC_GROUP_QueueInsertChannel(VADC_POT_GROUP, VADC_grp1_queue_entry_pot);
  }
#endif
}
10001578:	681a      	ldr	r2, [r3, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
1000157a:	2388      	movs	r3, #136	; 0x88
1000157c:	005b      	lsls	r3, r3, #1
1000157e:	50e2      	str	r2, [r4, r3]
10001580:	bd10      	pop	{r4, pc}
10001582:	46c0      	nop			; (mov r8, r8)
10001584:	48030800 	.word	0x48030800
10001588:	200005c4 	.word	0x200005c4
1000158c:	20000590 	.word	0x20000590

10001590 <ADC_DCLink_Init>:

/* API to initialize VADC channel for DC link voltage sensing */
void ADC_DCLink_Init(void)
{
10001590:	b510      	push	{r4, lr}
  /* Initializes the DC Link VADC channel for conversion */
  XMC_VADC_GROUP_ChannelInit(VADC_VDC_GROUP, VADC_VDC_CHANNEL, &VADC_channel_vdc_init);
10001592:	4c06      	ldr	r4, [pc, #24]	; (100015ac <ADC_DCLink_Init+0x1c>)
10001594:	2106      	movs	r1, #6
10001596:	1c20      	adds	r0, r4, #0
10001598:	4a05      	ldr	r2, [pc, #20]	; (100015b0 <ADC_DCLink_Init+0x20>)
1000159a:	f001 f9d3 	bl	10002944 <XMC_VADC_GROUP_ChannelInit>
1000159e:	4b05      	ldr	r3, [pc, #20]	; (100015b4 <ADC_DCLink_Init+0x24>)
#endif
  #ifdef USER_VOLTAGE_PROTECTION
  XMC_VADC_GROUP_SetIndividualBoundary(VADC_VDC_GROUP,XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND0,VDC_MIN_LIMIT);
  XMC_VADC_GROUP_SetIndividualBoundary(VADC_VDC_GROUP,XMC_VADC_CHANNEL_BOUNDARY_GROUP_BOUND1,VDC_OVER_LIMIT);
  #endif
}
100015a0:	681a      	ldr	r2, [r3, #0]
100015a2:	2388      	movs	r3, #136	; 0x88
100015a4:	005b      	lsls	r3, r3, #1
100015a6:	50e2      	str	r2, [r4, r3]
100015a8:	bd10      	pop	{r4, pc}
100015aa:	46c0      	nop			; (mov r8, r8)
100015ac:	48030800 	.word	0x48030800
100015b0:	200005f8 	.word	0x200005f8
100015b4:	200005d4 	.word	0x200005d4

100015b8 <CCU4_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize CCU4 module to outputs debug information. Outputs P1. 0, P0.4, P1.2, P1.3 */
void CCU4_Init(void)
{
100015b8:	b510      	push	{r4, lr}

  /* Init CCU40 */
  XMC_CCU4_Init(DEBUG_PWM_CCU4_MODULE, XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
100015ba:	4c07      	ldr	r4, [pc, #28]	; (100015d8 <CCU4_Init+0x20>)
100015bc:	2100      	movs	r1, #0
100015be:	1c20      	adds	r0, r4, #0
100015c0:	f000 ffa0 	bl	10002504 <XMC_CCU4_Init>
  XMC_CCU4_SetModuleClock(DEBUG_PWM_CCU4_MODULE, XMC_CCU4_CLOCK_SCU);
100015c4:	1c20      	adds	r0, r4, #0
100015c6:	2100      	movs	r1, #0
100015c8:	f000 ffb6 	bl	10002538 <XMC_CCU4_SetModuleClock>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
100015cc:	2280      	movs	r2, #128	; 0x80
100015ce:	68e3      	ldr	r3, [r4, #12]
100015d0:	0052      	lsls	r2, r2, #1
100015d2:	4313      	orrs	r3, r2
100015d4:	60e3      	str	r3, [r4, #12]

  XMC_CCU4_SLICE_StartTimer(DEBUG_PWM_1_SLICE);
  #endif /* (DEBUG_PWM_1_ENABLE == 1) */

  XMC_CCU4_StartPrescaler(DEBUG_PWM_CCU4_MODULE);
}
100015d6:	bd10      	pop	{r4, pc}
100015d8:	48040000 	.word	0x48040000

100015dc <CCU8_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize CCU8 module for 3 phase pwm generation. Trap functionality enable */
void CCU8_Init(void)
{
100015dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100015de:	465f      	mov	r7, fp
100015e0:	4656      	mov	r6, sl
100015e2:	464d      	mov	r5, r9
100015e4:	4644      	mov	r4, r8
100015e6:	b4f0      	push	{r4, r5, r6, r7}

	XMC_CCU8_Init(CCU8_MODULE, XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
100015e8:	27a0      	movs	r7, #160	; 0xa0
100015ea:	05ff      	lsls	r7, r7, #23
100015ec:	1c38      	adds	r0, r7, #0
100015ee:	2100      	movs	r1, #0
100015f0:	f000 ffaa 	bl	10002548 <XMC_CCU8_Init>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
100015f4:	2280      	movs	r2, #128	; 0x80
100015f6:	68fb      	ldr	r3, [r7, #12]
100015f8:	0052      	lsls	r2, r2, #1
100015fa:	4313      	orrs	r3, r2
100015fc:	60fb      	str	r3, [r7, #12]
	/* Set Prescaler run bit */
	XMC_CCU8_StartPrescaler(CCU8_MODULE);

	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_U, &CCU8_PhaseInit);
100015fe:	4b6b      	ldr	r3, [pc, #428]	; (100017ac <CCU8_Init+0x1d0>)
10001600:	4c6b      	ldr	r4, [pc, #428]	; (100017b0 <CCU8_Init+0x1d4>)
10001602:	4698      	mov	r8, r3
	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_V, &CCU8_PhaseInit);
10001604:	4e6b      	ldr	r6, [pc, #428]	; (100017b4 <CCU8_Init+0x1d8>)
	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_W, &CCU8_PhaseInit);
10001606:	4d6c      	ldr	r5, [pc, #432]	; (100017b8 <CCU8_Init+0x1dc>)

	XMC_CCU8_Init(CCU8_MODULE, XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
	/* Set Prescaler run bit */
	XMC_CCU8_StartPrescaler(CCU8_MODULE);

	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_U, &CCU8_PhaseInit);
10001608:	1c19      	adds	r1, r3, #0
1000160a:	1c20      	adds	r0, r4, #0
1000160c:	f000 ffb4 	bl	10002578 <XMC_CCU8_SLICE_CompareInit>
	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_V, &CCU8_PhaseInit);
10001610:	1c30      	adds	r0, r6, #0
10001612:	4641      	mov	r1, r8
10001614:	f000 ffb0 	bl	10002578 <XMC_CCU8_SLICE_CompareInit>
	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_PHASE_W, &CCU8_PhaseInit);
10001618:	1c28      	adds	r0, r5, #0
1000161a:	4641      	mov	r1, r8
1000161c:	f000 ffac 	bl	10002578 <XMC_CCU8_SLICE_CompareInit>
	XMC_CCU8_SLICE_CompareInit(CCU8_MODULE_ADC_TR, &CCU8_ADC_TriggerInit);
10001620:	4b66      	ldr	r3, [pc, #408]	; (100017bc <CCU8_Init+0x1e0>)
10001622:	4967      	ldr	r1, [pc, #412]	; (100017c0 <CCU8_Init+0x1e4>)
10001624:	1c18      	adds	r0, r3, #0
10001626:	4699      	mov	r9, r3
10001628:	f000 ffa6 	bl	10002578 <XMC_CCU8_SLICE_CompareInit>


	/* Timer Period Shadow Value */
	XMC_CCU8_SLICE_SetTimerPeriodMatch(CCU8_MODULE_PHASE_U, PERIOD_REG);
1000162c:	4b65      	ldr	r3, [pc, #404]	; (100017c4 <CCU8_Init+0x1e8>)
1000162e:	1c20      	adds	r0, r4, #0
10001630:	4698      	mov	r8, r3
10001632:	1c19      	adds	r1, r3, #0
10001634:	f001 f820 	bl	10002678 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
	XMC_CCU8_SLICE_SetTimerPeriodMatch(CCU8_MODULE_PHASE_V, PERIOD_REG);
10001638:	1c30      	adds	r0, r6, #0
1000163a:	4641      	mov	r1, r8
1000163c:	f001 f81c 	bl	10002678 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
	XMC_CCU8_SLICE_SetTimerPeriodMatch(CCU8_MODULE_PHASE_W, PERIOD_REG);
10001640:	1c28      	adds	r0, r5, #0
10001642:	4641      	mov	r1, r8
10001644:	f001 f818 	bl	10002678 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel1:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR1S = (uint32_t) compare_val;
10001648:	2200      	movs	r2, #0
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel2:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR2S = (uint32_t) compare_val;
1000164a:	4b5f      	ldr	r3, [pc, #380]	; (100017c8 <CCU8_Init+0x1ec>)
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel1:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR1S = (uint32_t) compare_val;
1000164c:	63e2      	str	r2, [r4, #60]	; 0x3c
  /* For ADCTz2 trigger. */
  XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(CCU8_MODULE_ADC_TR, (TZ_PZV + TRIGGER_POINT));

#else

  XMC_CCU8_SLICE_SetTimerPeriodMatch(CCU8_MODULE_ADC_TR, PERIOD_REG);
1000164e:	4648      	mov	r0, r9
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel2:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR2S = (uint32_t) compare_val;
10001650:	6463      	str	r3, [r4, #68]	; 0x44
10001652:	4641      	mov	r1, r8
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel1:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR1S = (uint32_t) compare_val;
10001654:	63f2      	str	r2, [r6, #60]	; 0x3c
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel2:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR2S = (uint32_t) compare_val;
10001656:	6473      	str	r3, [r6, #68]	; 0x44
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel1:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR1S = (uint32_t) compare_val;
10001658:	63ea      	str	r2, [r5, #60]	; 0x3c
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel2:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR2S = (uint32_t) compare_val;
1000165a:	646b      	str	r3, [r5, #68]	; 0x44
1000165c:	f001 f80c 	bl	10002678 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel1(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel1:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR1S = (uint32_t) compare_val;
10001660:	464a      	mov	r2, r9
10001662:	4b5a      	ldr	r3, [pc, #360]	; (100017cc <CCU8_Init+0x1f0>)
	/* Dead time enabled, No prescaler for the dead time counters */
	/* Dead time could cause motor phase current distortion, especially at low motor speed */
	CCU8_PWM_Deadtime_config.dc1r = DEAD_TIME;
	CCU8_PWM_Deadtime_config.dc2r = DEAD_TIME;

	XMC_CCU8_SLICE_DeadTimeInit(CCU8_MODULE_PHASE_U, &CCU8_PWM_Deadtime_config);
10001664:	1c20      	adds	r0, r4, #0
10001666:	63d3      	str	r3, [r2, #60]	; 0x3c
 *  XMC_CCU8_EnableShadowTransfer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(XMC_CCU8_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatchChannel2:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->CR2S = (uint32_t) compare_val;
10001668:	4b59      	ldr	r3, [pc, #356]	; (100017d0 <CCU8_Init+0x1f4>)
1000166a:	6453      	str	r3, [r2, #68]	; 0x44
	XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(CCU8_MODULE_ADC_TR, ((PERIOD_REG) /2) + 1);
#endif

	/* Dead time enabled, No prescaler for the dead time counters */
	/* Dead time could cause motor phase current distortion, especially at low motor speed */
	CCU8_PWM_Deadtime_config.dc1r = DEAD_TIME;
1000166c:	4b59      	ldr	r3, [pc, #356]	; (100017d4 <CCU8_Init+0x1f8>)
1000166e:	4698      	mov	r8, r3
10001670:	4642      	mov	r2, r8
10001672:	4b59      	ldr	r3, [pc, #356]	; (100017d8 <CCU8_Init+0x1fc>)
	CCU8_PWM_Deadtime_config.dc2r = DEAD_TIME;

	XMC_CCU8_SLICE_DeadTimeInit(CCU8_MODULE_PHASE_U, &CCU8_PWM_Deadtime_config);
10001674:	4641      	mov	r1, r8
	XMC_CCU8_SLICE_SetTimerCompareMatchChannel2(CCU8_MODULE_ADC_TR, ((PERIOD_REG) /2) + 1);
#endif

	/* Dead time enabled, No prescaler for the dead time counters */
	/* Dead time could cause motor phase current distortion, especially at low motor speed */
	CCU8_PWM_Deadtime_config.dc1r = DEAD_TIME;
10001676:	6053      	str	r3, [r2, #4]
	CCU8_PWM_Deadtime_config.dc2r = DEAD_TIME;
10001678:	6093      	str	r3, [r2, #8]

	XMC_CCU8_SLICE_DeadTimeInit(CCU8_MODULE_PHASE_U, &CCU8_PWM_Deadtime_config);
1000167a:	f001 f819 	bl	100026b0 <XMC_CCU8_SLICE_DeadTimeInit>
	XMC_CCU8_SLICE_DeadTimeInit(CCU8_MODULE_PHASE_V, &CCU8_PWM_Deadtime_config);
1000167e:	1c30      	adds	r0, r6, #0
10001680:	4641      	mov	r1, r8
10001682:	f001 f815 	bl	100026b0 <XMC_CCU8_SLICE_DeadTimeInit>
	XMC_CCU8_SLICE_DeadTimeInit(CCU8_MODULE_PHASE_W, &CCU8_PWM_Deadtime_config);
10001686:	1c28      	adds	r0, r5, #0
10001688:	4641      	mov	r1, r8
1000168a:	f001 f811 	bl	100026b0 <XMC_CCU8_SLICE_DeadTimeInit>
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS |= (uint32_t)shadow_transfer_msk;  
1000168e:	693b      	ldr	r3, [r7, #16]
10001690:	4a52      	ldr	r2, [pc, #328]	; (100017dc <CCU8_Init+0x200>)
	                                            (uint32_t)XMC_CCU8_SHADOW_TRANSFER_SLICE_2 |
	                                            (uint32_t)XMC_CCU8_SHADOW_TRANSFER_SLICE_3));

	/*  Enable interrupt for CCU80 Period Match Enable */
	XMC_CCU8_SLICE_EnableEvent(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
	XMC_CCU8_SLICE_SetInterruptNode(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU8_SLICE_SR_ID_0);
10001692:	1c20      	adds	r0, r4, #0
10001694:	4313      	orrs	r3, r2
10001696:	613b      	str	r3, [r7, #16]
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
10001698:	23a4      	movs	r3, #164	; 0xa4
1000169a:	469a      	mov	sl, r3
1000169c:	58e2      	ldr	r2, [r4, r3]
1000169e:	3ba3      	subs	r3, #163	; 0xa3
100016a0:	4313      	orrs	r3, r2
100016a2:	4652      	mov	r2, sl
100016a4:	2100      	movs	r1, #0
100016a6:	50a3      	str	r3, [r4, r2]
100016a8:	2200      	movs	r2, #0
100016aa:	f000 ffe7 	bl	1000267c <XMC_CCU8_SLICE_SetInterruptNode>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100016ae:	22c6      	movs	r2, #198	; 0xc6
100016b0:	4b4b      	ldr	r3, [pc, #300]	; (100017e0 <CCU8_Init+0x204>)
100016b2:	0092      	lsls	r2, r2, #2
100016b4:	4698      	mov	r8, r3
100016b6:	589a      	ldr	r2, [r3, r2]
100016b8:	4b4a      	ldr	r3, [pc, #296]	; (100017e4 <CCU8_Init+0x208>)
100016ba:	21c6      	movs	r1, #198	; 0xc6
100016bc:	4013      	ands	r3, r2
100016be:	2280      	movs	r2, #128	; 0x80
100016c0:	0212      	lsls	r2, r2, #8
100016c2:	4313      	orrs	r3, r2
100016c4:	4642      	mov	r2, r8
100016c6:	0089      	lsls	r1, r1, #2
100016c8:	5053      	str	r3, [r2, r1]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
100016ca:	2380      	movs	r3, #128	; 0x80
100016cc:	049b      	lsls	r3, r3, #18
100016ce:	6013      	str	r3, [r2, #0]
	NVIC_EnableIRQ(CCU80_0_IRQn);

	/* Configuring CCU80 CC8xINS - Input Selector Configuration to SCU.GSC80 */
	/* Event0 -> INyH (SCU.GSC80, Global Start Control CCU80) for EV0IS */
	/* INyH for EV0IS */
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, &CCU8_Input_event0_config);
100016d0:	4b45      	ldr	r3, [pc, #276]	; (100017e8 <CCU8_Init+0x20c>)
100016d2:	1c20      	adds	r0, r4, #0
100016d4:	469b      	mov	fp, r3
100016d6:	1c1a      	adds	r2, r3, #0
100016d8:	2101      	movs	r1, #1
100016da:	f000 ff9d 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_0, &CCU8_Input_event0_config);
100016de:	1c30      	adds	r0, r6, #0
100016e0:	465a      	mov	r2, fp
100016e2:	2101      	movs	r1, #1
100016e4:	f000 ff98 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_0, &CCU8_Input_event0_config);
100016e8:	1c28      	adds	r0, r5, #0
100016ea:	465a      	mov	r2, fp
100016ec:	2101      	movs	r1, #1
100016ee:	f000 ff93 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_ADC_TR, XMC_CCU8_SLICE_EVENT_0, &CCU8_Input_event0_config);
100016f2:	4648      	mov	r0, r9
100016f4:	465a      	mov	r2, fp
100016f6:	2101      	movs	r1, #1
100016f8:	f000 ff8e 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
{
  SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
100016fc:	4a3b      	ldr	r2, [pc, #236]	; (100017ec <CCU8_Init+0x210>)
100016fe:	4b3c      	ldr	r3, [pc, #240]	; (100017f0 <CCU8_Init+0x214>)
10001700:	6b11      	ldr	r1, [r2, #48]	; 0x30
	XMC_CCU8_EnableMultipleClocks(CCU8_MODULE, XMC_CCU8_GIDLC_CLOCK_MASK);

	/* Trap functionality enable */
	/* LPF2M = 11b, Event2 LPF -> 7 clock cycles of fCCU8 */
	/* EV2LM = 1b, Event2 (active LOW) -> TRAP -> CCU8x.INyA -> P0.12. Note trap function is level active */
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_2, &CCU8_Input_trap_config);
10001702:	1c20      	adds	r0, r4, #0
10001704:	400b      	ands	r3, r1
10001706:	6313      	str	r3, [r2, #48]	; 0x30
__STATIC_INLINE void XMC_CCU8_EnableMultipleClocks(XMC_CCU8_MODULE_t *const module, const uint8_t clock_mask)
{
  XMC_ASSERT("XMC_CCU8_EnableMultipleClocks:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableMultipleClocks:Invalid clock mask", (clock_mask < 16U));

  module->GIDLC |= (uint32_t) clock_mask;
10001708:	230f      	movs	r3, #15
1000170a:	68fa      	ldr	r2, [r7, #12]
1000170c:	2103      	movs	r1, #3
1000170e:	4313      	orrs	r3, r2
10001710:	60fb      	str	r3, [r7, #12]
10001712:	4f38      	ldr	r7, [pc, #224]	; (100017f4 <CCU8_Init+0x218>)
10001714:	1c3a      	adds	r2, r7, #0
10001716:	f000 ff7f 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_2, &CCU8_Input_trap_config);
1000171a:	1c30      	adds	r0, r6, #0
1000171c:	1c3a      	adds	r2, r7, #0
1000171e:	2103      	movs	r1, #3
10001720:	f000 ff7a 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>
	XMC_CCU8_SLICE_ConfigureEvent(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_2, &CCU8_Input_trap_config);
10001724:	1c3a      	adds	r2, r7, #0
 *  XMC_CCU8_SLICE_SetInput().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableTrap(XMC_CCU8_SLICE_t *const slice, const uint32_t out_mask)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableTrap:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TC |= (uint32_t)out_mask << CCU8_CC8_TC_TRAPE0_Pos;
10001726:	27f0      	movs	r7, #240	; 0xf0
10001728:	1c28      	adds	r0, r5, #0
1000172a:	2103      	movs	r1, #3
1000172c:	f000 ff74 	bl	10002618 <XMC_CCU8_SLICE_ConfigureEvent>

		/* CCU8 TRAP functionality enabled so PWM outputs react on state of an input pin. For over-current protection */
	/* TS = 1, TRAP function enabled and connected to CCU80-CC8x Event2 */
	/* TRPSW = TRPSE = 1b, TRAP state only exited by SW, synch with PWM */
	/* TRAPE3/2/1/0 = 1b, TRAP affects CCU8x.OUTy0/1/2/3 */
	XMC_CCU8_SLICE_TrapConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW, true);
10001730:	1c20      	adds	r0, r4, #0
10001732:	2101      	movs	r1, #1
10001734:	2201      	movs	r2, #1
10001736:	f000 ff51 	bl	100025dc <XMC_CCU8_SLICE_TrapConfig>
1000173a:	6963      	ldr	r3, [r4, #20]
1000173c:	037f      	lsls	r7, r7, #13
1000173e:	433b      	orrs	r3, r7
	XMC_CCU8_SLICE_EnableTrap(CCU8_MODULE_PHASE_U, XMC_CCU8_TC_TRAPSE_MASK);

	XMC_CCU8_SLICE_TrapConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW, true);
10001740:	1c30      	adds	r0, r6, #0
10001742:	6163      	str	r3, [r4, #20]
10001744:	2101      	movs	r1, #1
10001746:	2201      	movs	r2, #1
10001748:	f000 ff48 	bl	100025dc <XMC_CCU8_SLICE_TrapConfig>
1000174c:	6973      	ldr	r3, [r6, #20]
	XMC_CCU8_SLICE_EnableTrap(CCU8_MODULE_PHASE_V, XMC_CCU8_TC_TRAPSE_MASK);

	XMC_CCU8_SLICE_TrapConfig(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW, true);
1000174e:	1c28      	adds	r0, r5, #0
10001750:	433b      	orrs	r3, r7
10001752:	6173      	str	r3, [r6, #20]
10001754:	2101      	movs	r1, #1
10001756:	2201      	movs	r2, #1
10001758:	f000 ff40 	bl	100025dc <XMC_CCU8_SLICE_TrapConfig>
1000175c:	696b      	ldr	r3, [r5, #20]
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
1000175e:	2280      	movs	r2, #128	; 0x80
 *  XMC_CCU8_SLICE_SetInput().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableTrap(XMC_CCU8_SLICE_t *const slice, const uint32_t out_mask)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableTrap:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TC |= (uint32_t)out_mask << CCU8_CC8_TC_TRAPE0_Pos;
10001760:	433b      	orrs	r3, r7
10001762:	616b      	str	r3, [r5, #20]
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
10001764:	4653      	mov	r3, sl
10001766:	58e3      	ldr	r3, [r4, r3]
10001768:	00d2      	lsls	r2, r2, #3
1000176a:	4313      	orrs	r3, r2
1000176c:	4652      	mov	r2, sl

	/* Enable interrupt for CCU80-CC80 Event2 */
	XMC_CCU8_SLICE_EnableEvent(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_IRQ_ID_EVENT2);

	/* Event2 interrupt forward to CC8ySR1 */
	XMC_CCU8_SLICE_SetInterruptNode(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_IRQ_ID_EVENT2, XMC_CCU8_SLICE_SR_ID_1);
1000176e:	1c20      	adds	r0, r4, #0
10001770:	50a3      	str	r3, [r4, r2]
10001772:	210a      	movs	r1, #10
10001774:	3aa3      	subs	r2, #163	; 0xa3
10001776:	f000 ff81 	bl	1000267c <XMC_CCU8_SLICE_SetInterruptNode>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1000177a:	22c6      	movs	r2, #198	; 0xc6
1000177c:	4643      	mov	r3, r8
1000177e:	0092      	lsls	r2, r2, #2
10001780:	589a      	ldr	r2, [r3, r2]
10001782:	4b1d      	ldr	r3, [pc, #116]	; (100017f8 <CCU8_Init+0x21c>)
10001784:	21c6      	movs	r1, #198	; 0xc6
10001786:	4013      	ands	r3, r2
10001788:	4642      	mov	r2, r8
1000178a:	0089      	lsls	r1, r1, #2
1000178c:	5053      	str	r3, [r2, r1]

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
1000178e:	2380      	movs	r3, #128	; 0x80
10001790:	04db      	lsls	r3, r3, #19
10001792:	6013      	str	r3, [r2, #0]
	/* CCU80_1_IRQn = 26. Trap protection interrupt. CCU80_1_IRQHandler Trap protection interrupt has highest priority */
	NVIC_SetPriority(CCU80_1_IRQn, 0U);
	NVIC_EnableIRQ(CCU80_1_IRQn);

	/* Interrupt Status Clear, for interrupts of Period Match, Trap Flag, and Event2 */
	CCU8_MODULE_PHASE_U->SWR |= 0x00000C01U;
10001794:	22b0      	movs	r2, #176	; 0xb0
10001796:	4919      	ldr	r1, [pc, #100]	; (100017fc <CCU8_Init+0x220>)
10001798:	58a3      	ldr	r3, [r4, r2]
1000179a:	430b      	orrs	r3, r1
1000179c:	50a3      	str	r3, [r4, r2]

}
1000179e:	bc3c      	pop	{r2, r3, r4, r5}
100017a0:	4690      	mov	r8, r2
100017a2:	4699      	mov	r9, r3
100017a4:	46a2      	mov	sl, r4
100017a6:	46ab      	mov	fp, r5
100017a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
100017aa:	46c0      	nop			; (mov r8, r8)
100017ac:	20000624 	.word	0x20000624
100017b0:	50000100 	.word	0x50000100
100017b4:	50000200 	.word	0x50000200
100017b8:	50000300 	.word	0x50000300
100017bc:	50000400 	.word	0x50000400
100017c0:	20000608 	.word	0x20000608
100017c4:	000010aa 	.word	0x000010aa
100017c8:	000010ab 	.word	0x000010ab
100017cc:	00000855 	.word	0x00000855
100017d0:	00000856 	.word	0x00000856
100017d4:	20000618 	.word	0x20000618
100017d8:	00003535 	.word	0x00003535
100017dc:	00001111 	.word	0x00001111
100017e0:	e000e100 	.word	0xe000e100
100017e4:	ffff00ff 	.word	0xffff00ff
100017e8:	20000634 	.word	0x20000634
100017ec:	40010000 	.word	0x40010000
100017f0:	fffffeff 	.word	0xfffffeff
100017f4:	20000638 	.word	0x20000638
100017f8:	ff00ffff 	.word	0xff00ffff
100017fc:	00000c01 	.word	0x00000c01

10001800 <CCUx_SynStart>:

/* API to enable synchronous start of CAPCOM modules. */
void CCUx_SynStart(void)
{
10001800:	b5f0      	push	{r4, r5, r6, r7, lr}
10001802:	4647      	mov	r7, r8
	/* Setup Event0 for external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
10001804:	4b1d      	ldr	r3, [pc, #116]	; (1000187c <CCUx_SynStart+0x7c>)

}

/* API to enable synchronous start of CAPCOM modules. */
void CCUx_SynStart(void)
{
10001806:	b480      	push	{r7}
	/* Setup Event0 for external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
10001808:	4f1d      	ldr	r7, [pc, #116]	; (10001880 <CCUx_SynStart+0x80>)

/* API to enable synchronous start of CAPCOM modules. */
void CCUx_SynStart(void)
{
	/* Setup Event0 for external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
1000180a:	1c18      	adds	r0, r3, #0
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
1000180c:	4e1d      	ldr	r6, [pc, #116]	; (10001884 <CCUx_SynStart+0x84>)

/* API to enable synchronous start of CAPCOM modules. */
void CCUx_SynStart(void)
{
	/* Setup Event0 for external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
1000180e:	2101      	movs	r1, #1
10001810:	2201      	movs	r2, #1
10001812:	4698      	mov	r8, r3
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_ADC_TR, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
10001814:	4d1c      	ldr	r5, [pc, #112]	; (10001888 <CCUx_SynStart+0x88>)

/* API to enable synchronous start of CAPCOM modules. */
void CCUx_SynStart(void)
{
	/* Setup Event0 for external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
10001816:	f000 fecd 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
1000181a:	1c38      	adds	r0, r7, #0
1000181c:	2101      	movs	r1, #1
1000181e:	2201      	movs	r2, #1
10001820:	f000 fec8 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
10001824:	1c30      	adds	r0, r6, #0
10001826:	2101      	movs	r1, #1
10001828:	2201      	movs	r2, #1
1000182a:	f000 fec3 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_ADC_TR, XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
1000182e:	1c28      	adds	r0, r5, #0
10001830:	2101      	movs	r1, #1
10001832:	2201      	movs	r2, #1
10001834:	f000 febe 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerLow()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerHigh(const uint32_t trigger)
{
  SCU_GENERAL->CCUCON |= (uint32_t)trigger;
10001838:	2280      	movs	r2, #128	; 0x80
1000183a:	4c14      	ldr	r4, [pc, #80]	; (1000188c <CCUx_SynStart+0x8c>)
1000183c:	0052      	lsls	r2, r2, #1
1000183e:	6b23      	ldr	r3, [r4, #48]	; 0x30

	/* Enable Global Start Control CCU80 */
	XMC_SCU_SetCcuTriggerHigh(SCU_GENERAL_CCUCON_GSC80_Msk);

	/* Disable external start trigger */
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_U, XMC_CCU8_SLICE_EVENT_NONE, XMC_CCU8_SLICE_START_MODE_TIMER_START);
10001840:	4640      	mov	r0, r8
10001842:	4313      	orrs	r3, r2
10001844:	6323      	str	r3, [r4, #48]	; 0x30
10001846:	2100      	movs	r1, #0
10001848:	2200      	movs	r2, #0
1000184a:	f000 feb3 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_V, XMC_CCU8_SLICE_EVENT_NONE, XMC_CCU8_SLICE_START_MODE_TIMER_START);
1000184e:	1c38      	adds	r0, r7, #0
10001850:	2100      	movs	r1, #0
10001852:	2200      	movs	r2, #0
10001854:	f000 feae 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_PHASE_W, XMC_CCU8_SLICE_EVENT_NONE, XMC_CCU8_SLICE_START_MODE_TIMER_START);
10001858:	1c30      	adds	r0, r6, #0
1000185a:	2100      	movs	r1, #0
1000185c:	2200      	movs	r2, #0
1000185e:	f000 fea9 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
	XMC_CCU8_SLICE_StartConfig(CCU8_MODULE_ADC_TR, XMC_CCU8_SLICE_EVENT_NONE, XMC_CCU8_SLICE_START_MODE_TIMER_START);
10001862:	1c28      	adds	r0, r5, #0
10001864:	2100      	movs	r1, #0
10001866:	2200      	movs	r2, #0
10001868:	f000 fea4 	bl	100025b4 <XMC_CCU8_SLICE_StartConfig>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
{
  SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
1000186c:	6b22      	ldr	r2, [r4, #48]	; 0x30
1000186e:	4b08      	ldr	r3, [pc, #32]	; (10001890 <CCUx_SynStart+0x90>)
10001870:	4013      	ands	r3, r2
10001872:	6323      	str	r3, [r4, #48]	; 0x30

	/* Disable Global Start Control CCU80 */
	XMC_SCU_SetCcuTriggerLow(SCU_GENERAL_CCUCON_GSC80_Msk);
}
10001874:	bc04      	pop	{r2}
10001876:	4690      	mov	r8, r2
10001878:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000187a:	46c0      	nop			; (mov r8, r8)
1000187c:	50000100 	.word	0x50000100
10001880:	50000200 	.word	0x50000200
10001884:	50000300 	.word	0x50000300
10001888:	50000400 	.word	0x50000400
1000188c:	40010000 	.word	0x40010000
10001890:	fffffeff 	.word	0xfffffeff

10001894 <Reset_Clock_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize clock module and read reset status */
void Reset_Clock_Init(void)
{
10001894:	b508      	push	{r3, lr}
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_RESET_ClearDeviceResetReason() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_RESET_GetDeviceResetReason(void)
{
  return ((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_RSTSTAT_Msk);
10001896:	4b09      	ldr	r3, [pc, #36]	; (100018bc <Reset_Clock_Init+0x28>)

	/* Reset status, get reason of last reset */
	Reset_Status = XMC_SCU_RESET_GetDeviceResetReason();

	/* Record MCU Reset Status Information by a global variable */
	g_mcu_reset_status = Reset_Status;
10001898:	4909      	ldr	r1, [pc, #36]	; (100018c0 <Reset_Clock_Init+0x2c>)
1000189a:	681a      	ldr	r2, [r3, #0]
	XMC_SCU_RESET_EnableResetRequest((uint32_t)XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR |
	                                 (uint32_t)XMC_SCU_RESET_REQUEST_CLOCK_LOSS |
	                                 (uint32_t)XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR);

	/* 32MHz MCLK, PCLK = 2 x MCLK = 64MHz, RTC clock is standby clock, Counter Adjustment = 1024 clock cycles */
	XMC_SCU_CLOCK_Init(&clock_config);
1000189c:	4809      	ldr	r0, [pc, #36]	; (100018c4 <Reset_Clock_Init+0x30>)
1000189e:	0592      	lsls	r2, r2, #22
100018a0:	0d92      	lsrs	r2, r2, #22

	/* Reset status, get reason of last reset */
	Reset_Status = XMC_SCU_RESET_GetDeviceResetReason();

	/* Record MCU Reset Status Information by a global variable */
	g_mcu_reset_status = Reset_Status;
100018a2:	600a      	str	r2, [r1, #0]
 * XMC_SCU_RESET_GetDeviceResetReason() \n\n\n
 */
__STATIC_INLINE void XMC_SCU_RESET_ClearDeviceResetReason(void)
{
  /* Clear RSTSTAT.RSTSTAT bitfield */
  SCU_RESET->RSTCLR |= (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
100018a4:	2201      	movs	r2, #1
100018a6:	6899      	ldr	r1, [r3, #8]
100018a8:	430a      	orrs	r2, r1
100018aa:	609a      	str	r2, [r3, #8]
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_RESET_AssertMasterReset() \n\n\n
 */
__STATIC_INLINE void XMC_SCU_RESET_EnableResetRequest(uint32_t request)
{
  SCU_RESET->RSTCON |= request;
100018ac:	2207      	movs	r2, #7
100018ae:	68d9      	ldr	r1, [r3, #12]
100018b0:	430a      	orrs	r2, r1
100018b2:	60da      	str	r2, [r3, #12]
	XMC_SCU_RESET_EnableResetRequest((uint32_t)XMC_SCU_RESET_REQUEST_FLASH_ECC_ERROR |
	                                 (uint32_t)XMC_SCU_RESET_REQUEST_CLOCK_LOSS |
	                                 (uint32_t)XMC_SCU_RESET_REQUEST_SRAM_PARITY_ERROR);

	/* 32MHz MCLK, PCLK = 2 x MCLK = 64MHz, RTC clock is standby clock, Counter Adjustment = 1024 clock cycles */
	XMC_SCU_CLOCK_Init(&clock_config);
100018b4:	f000 fe06 	bl	100024c4 <XMC_SCU_CLOCK_Init>

}
100018b8:	bd08      	pop	{r3, pc}
100018ba:	46c0      	nop			; (mov r8, r8)
100018bc:	40010400 	.word	0x40010400
100018c0:	20001020 	.word	0x20001020
100018c4:	2000063c 	.word	0x2000063c

100018c8 <GPIO_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize GPIO pins used */
void GPIO_Init(void)
{
100018c8:	b510      	push	{r4, lr}
	/* P0.11 as gate driver enable pin */
	XMC_GPIO_Init(INVERTER_EN_PIN, &IO_PadConfig_Pushpull);
100018ca:	4c17      	ldr	r4, [pc, #92]	; (10001928 <GPIO_Init+0x60>)
100018cc:	210b      	movs	r1, #11
100018ce:	1c20      	adds	r0, r4, #0
100018d0:	4a16      	ldr	r2, [pc, #88]	; (1000192c <GPIO_Init+0x64>)
100018d2:	f000 fd39 	bl	10002348 <XMC_GPIO_Init>

	/* P0.0	ALT5 CCU80.OUT00 */
	XMC_GPIO_SetMode(PHASE_U_HS_PIN, PHASE_U_HS_ALT_SELECT);
100018d6:	1c20      	adds	r0, r4, #0
100018d8:	2100      	movs	r1, #0
100018da:	22a8      	movs	r2, #168	; 0xa8
100018dc:	f000 fef0 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.1 ALT5 CCU80.OUT01 */
	XMC_GPIO_SetMode(PHASE_U_LS_PIN, PHASE_U_LS_ALT_SELECT);
100018e0:	1c20      	adds	r0, r4, #0
100018e2:	2101      	movs	r1, #1
100018e4:	22a8      	movs	r2, #168	; 0xa8
100018e6:	f000 feeb 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.2 ALT7 CCU80.OUT10 */
	XMC_GPIO_SetMode(PHASE_V_HS_PIN, PHASE_V_HS_ALT_SELECT);
100018ea:	1c20      	adds	r0, r4, #0
100018ec:	2102      	movs	r1, #2
100018ee:	22b8      	movs	r2, #184	; 0xb8
100018f0:	f000 fee6 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.3 ALT7 CCU80.OUT11 */
	XMC_GPIO_SetMode(PHASE_V_LS_PIN, PHASE_V_LS_ALT_SELECT);
100018f4:	1c20      	adds	r0, r4, #0
100018f6:	2103      	movs	r1, #3
100018f8:	22b8      	movs	r2, #184	; 0xb8
100018fa:	f000 fee1 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.8 ALT5 CCU80.OUT20 */
	XMC_GPIO_SetMode(PHASE_W_HS_PIN, PHASE_W_HS_ALT_SELECT);
100018fe:	1c20      	adds	r0, r4, #0
10001900:	2108      	movs	r1, #8
10001902:	22a8      	movs	r2, #168	; 0xa8
10001904:	f000 fedc 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.9 ALT5 CCU80.OUT21 */
	XMC_GPIO_SetMode(PHASE_W_LS_PIN, PHASE_W_LS_ALT_SELECT);
10001908:	1c20      	adds	r0, r4, #0
1000190a:	2109      	movs	r1, #9
1000190c:	22a8      	movs	r2, #168	; 0xa8
1000190e:	f000 fed7 	bl	100026c0 <XMC_GPIO_SetMode>

	/* P0.12 as CCU80 Trap input, internal pull-up */
	XMC_GPIO_SetMode(TRAP_PIN, XMC_GPIO_MODE_INPUT_PULL_UP);
10001912:	1c20      	adds	r0, r4, #0
10001914:	210c      	movs	r1, #12
10001916:	2210      	movs	r2, #16
10001918:	f000 fed2 	bl	100026c0 <XMC_GPIO_SetMode>

	XMC_GPIO_SetMode (TEST_PIN,XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
1000191c:	4804      	ldr	r0, [pc, #16]	; (10001930 <GPIO_Init+0x68>)
1000191e:	2104      	movs	r1, #4
10001920:	2280      	movs	r2, #128	; 0x80
10001922:	f000 fecd 	bl	100026c0 <XMC_GPIO_SetMode>

}
10001926:	bd10      	pop	{r4, pc}
10001928:	40040000 	.word	0x40040000
1000192c:	20000648 	.word	0x20000648
10001930:	40040100 	.word	0x40040100

10001934 <MATH_Init>:
 *
 */
__STATIC_INLINE void XMC_MATH_Enable(void)
{
  /* Un-gates clock to the MATH kernel */
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MATH);
10001934:	2080      	movs	r0, #128	; 0x80
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* API to initialize MATH Module */
void MATH_Init(void)
{
10001936:	b508      	push	{r3, lr}
10001938:	0040      	lsls	r0, r0, #1
1000193a:	f000 fd43 	bl	100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>
  /* Disable bit protection */
  XMC_MATH_Enable();

  /* Default CORDIC setting so far. No result chaining is selected */
  MATH->GLBCON = 0x00U;
1000193e:	2200      	movs	r2, #0

  /* Setting to Vector Mode */
  MATH->CON = VECTORING_MODE;
10001940:	2162      	movs	r1, #98	; 0x62
{
  /* Disable bit protection */
  XMC_MATH_Enable();

  /* Default CORDIC setting so far. No result chaining is selected */
  MATH->GLBCON = 0x00U;
10001942:	4b02      	ldr	r3, [pc, #8]	; (1000194c <MATH_Init+0x18>)
10001944:	605a      	str	r2, [r3, #4]

  /* Setting to Vector Mode */
  MATH->CON = VECTORING_MODE;
10001946:	6459      	str	r1, [r3, #68]	; 0x44

  /* Data control: No Keep*/
  MATH->STATC = 0x00U; /* Data control: No Keep.*/
10001948:	641a      	str	r2, [r3, #64]	; 0x40

}
1000194a:	bd08      	pop	{r3, pc}
1000194c:	40030000 	.word	0x40030000

10001950 <PMSM_FOC_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize MCU and peripherals for motor control */
void PMSM_FOC_Init(void)
{
10001950:	b500      	push	{lr}
10001952:	b083      	sub	sp, #12

  volatile uint32_t delay_counter;

  /* Reset configuration, clock configuration */
  Reset_Clock_Init();
10001954:	f7ff ff9e 	bl	10001894 <Reset_Clock_Init>

  /* Hardware Settling down Timing*/
  for(delay_counter = 0; delay_counter < PMSM_FOC_SETTLING_TIME; delay_counter++);
10001958:	2300      	movs	r3, #0
1000195a:	9301      	str	r3, [sp, #4]
1000195c:	9901      	ldr	r1, [sp, #4]
1000195e:	4b12      	ldr	r3, [pc, #72]	; (100019a8 <PMSM_FOC_Init+0x58>)
10001960:	1c1a      	adds	r2, r3, #0
10001962:	4299      	cmp	r1, r3
10001964:	d805      	bhi.n	10001972 <PMSM_FOC_Init+0x22>
10001966:	9b01      	ldr	r3, [sp, #4]
10001968:	3301      	adds	r3, #1
1000196a:	9301      	str	r3, [sp, #4]
1000196c:	9b01      	ldr	r3, [sp, #4]
1000196e:	4293      	cmp	r3, r2
10001970:	d9f9      	bls.n	10001966 <PMSM_FOC_Init+0x16>

  /* Init CCU8 */
  CCU8_Init();
10001972:	f7ff fe33 	bl	100015dc <CCU8_Init>

  /* Init CCU4 for debug, PWM speed adjustment, or FG / RD */
  CCU4_Init();
10001976:	f7ff fe1f 	bl	100015b8 <CCU4_Init>

  #if(UART_ENABLE != USIC_DISABLED_ALL)
  /* Init UART */
  UART_Init();
1000197a:	f000 f819 	bl	100019b0 <UART_Init>
  #endif
  /* Init MATH Unit (i.e.: CORDIC Coprocessor and Divider Unit DIV) */
  MATH_Init();
1000197e:	f7ff ffd9 	bl	10001934 <MATH_Init>

  /* Init GPIOs */
  GPIO_Init();
10001982:	f7ff ffa1 	bl	100018c8 <GPIO_Init>

  UART_TX_String("\r\nInfineon FOC\r\n");
10001986:	4809      	ldr	r0, [pc, #36]	; (100019ac <PMSM_FOC_Init+0x5c>)
10001988:	f000 f898 	bl	10001abc <UART_TX_String>

  /*  Init variables for motor control. Before start motor, brake the motor in case it is running */
  MotorControl_Init();
1000198c:	f000 fc48 	bl	10002220 <MotorControl_Init>

  /* Init ADC, for current sensing, ADC of DC link Vdc (and POT). Do at later stage of the init */
  ADC_Init();
10001990:	f7ff fd42 	bl	10001418 <ADC_Init>
  ADC_DCLink_Init();
10001994:	f7ff fdfc 	bl	10001590 <ADC_DCLink_Init>
  ADC_Pot_Init();
10001998:	f7ff fde6 	bl	10001568 <ADC_Pot_Init>

  /* Init WDT */
  WDT_Init();
1000199c:	f000 f916 	bl	10001bcc <WDT_Init>

  /* Synchronous start of CAPCOM modules, e.g.: CCU8x, and or CCU4x */
  CCUx_SynStart();
100019a0:	f7ff ff2e 	bl	10001800 <CCUx_SynStart>

}
100019a4:	b003      	add	sp, #12
100019a6:	bd00      	pop	{pc}
100019a8:	0007fffe 	.word	0x0007fffe
100019ac:	10003008 	.word	0x10003008

100019b0 <UART_Init>:
 * @retval None
 */
void UART_Init (void)
{
  /* Disable clock gating to USIC0: */
  SCU_GENERAL->PASSWD = XMC_SCU_GCU_PASSWD_PROT_DISABLE;
100019b0:	22c0      	movs	r2, #192	; 0xc0
100019b2:	4b32      	ldr	r3, [pc, #200]	; (10001a7c <UART_Init+0xcc>)
 *
 * @param  None
 * @retval None
 */
void UART_Init (void)
{
100019b4:	b570      	push	{r4, r5, r6, lr}
  /* Disable clock gating to USIC0: */
  SCU_GENERAL->PASSWD = XMC_SCU_GCU_PASSWD_PROT_DISABLE;
100019b6:	625a      	str	r2, [r3, #36]	; 0x24

  /* Stop gating USIC0 */
  SCU_CLK->CGATCLR0 = 0x00000008UL;
100019b8:	4b31      	ldr	r3, [pc, #196]	; (10001a80 <UART_Init+0xd0>)
100019ba:	3ab8      	subs	r2, #184	; 0xb8
100019bc:	611a      	str	r2, [r3, #16]

  /* Wait if VDDC is too low, for VDDC to stabilise */
  while (SCU_CLK->CLKCR & 0x40000000UL)
100019be:	2280      	movs	r2, #128	; 0x80
100019c0:	05d2      	lsls	r2, r2, #23
100019c2:	681d      	ldr	r5, [r3, #0]
100019c4:	4015      	ands	r5, r2
100019c6:	d1fc      	bne.n	100019c2 <UART_Init+0x12>
  {
    continue;
  }

  /* Enable bit protection */
  SCU_GENERAL->PASSWD = XMC_SCU_GCU_PASSWD_PROT_ENABLE;
100019c8:	22c3      	movs	r2, #195	; 0xc3
100019ca:	4b2c      	ldr	r3, [pc, #176]	; (10001a7c <UART_Init+0xcc>)

  /* Enable the module kernel clock and the module functionality: */
  USIC0_CH1->KSCFG |= USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk;
100019cc:	4c2d      	ldr	r4, [pc, #180]	; (10001a84 <UART_Init+0xd4>)
  {
    continue;
  }

  /* Enable bit protection */
  SCU_GENERAL->PASSWD = XMC_SCU_GCU_PASSWD_PROT_ENABLE;
100019ce:	625a      	str	r2, [r3, #36]	; 0x24

  /* Enable the module kernel clock and the module functionality: */
  USIC0_CH1->KSCFG |= USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk;
100019d0:	2303      	movs	r3, #3
100019d2:	68e2      	ldr	r2, [r4, #12]
  /* Standard transmit buffer event is enabled. */
  /* Define start entry of Transmit Data FIFO buffer DPTR = 0. */
  USIC0_CH1->TBCTR &= ~(USIC_CH_TBCTR_SIZE_Msk | USIC_CH_TBCTR_DPTR_Msk);

  /* Set Transmit Data Buffer size and set data pointer to position 0. */
  USIC0_CH1->TBCTR |= ((UART_FIFO_SIZE << USIC_CH_TBCTR_SIZE_Pos) | (0x00 << USIC_CH_TBCTR_DPTR_Pos));
100019d4:	21a0      	movs	r1, #160	; 0xa0

  /* Enable bit protection */
  SCU_GENERAL->PASSWD = XMC_SCU_GCU_PASSWD_PROT_ENABLE;

  /* Enable the module kernel clock and the module functionality: */
  USIC0_CH1->KSCFG |= USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk;
100019d6:	4313      	orrs	r3, r2
100019d8:	60e3      	str	r3, [r4, #12]

  /* fFD = fPB. */
  /* FDR.DM = 02b (Fractional divider mode). */
  USIC0_CH1->FDR &= ~(USIC_CH_FDR_DM_Msk | USIC_CH_FDR_STEP_Msk);
100019da:	6922      	ldr	r2, [r4, #16]
100019dc:	4b2a      	ldr	r3, [pc, #168]	; (10001a88 <UART_Init+0xd8>)
  USIC0_CH1->PCR |= USIC_CH_PCR_ASCMode_SMD_Msk | (9 << USIC_CH_PCR_ASCMode_SP_Pos);

  /* Configure Transmit Buffer: */
  /* Standard transmit buffer event is enabled. */
  /* Define start entry of Transmit Data FIFO buffer DPTR = 0. */
  USIC0_CH1->TBCTR &= ~(USIC_CH_TBCTR_SIZE_Msk | USIC_CH_TBCTR_DPTR_Msk);
100019de:	4e2b      	ldr	r6, [pc, #172]	; (10001a8c <UART_Init+0xdc>)
  /* Enable the module kernel clock and the module functionality: */
  USIC0_CH1->KSCFG |= USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk;

  /* fFD = fPB. */
  /* FDR.DM = 02b (Fractional divider mode). */
  USIC0_CH1->FDR &= ~(USIC_CH_FDR_DM_Msk | USIC_CH_FDR_STEP_Msk);
100019e0:	4013      	ands	r3, r2
100019e2:	6123      	str	r3, [r4, #16]
  USIC0_CH1->FDR |= (0x02UL << USIC_CH_FDR_DM_Pos) | (FDR_STEP << USIC_CH_FDR_STEP_Pos);
100019e4:	6923      	ldr	r3, [r4, #16]
100019e6:	4a2a      	ldr	r2, [pc, #168]	; (10001a90 <UART_Init+0xe0>)
  /* Standard transmit buffer event is enabled. */
  /* Define start entry of Transmit Data FIFO buffer DPTR = 0. */
  USIC0_CH1->TBCTR &= ~(USIC_CH_TBCTR_SIZE_Msk | USIC_CH_TBCTR_DPTR_Msk);

  /* Set Transmit Data Buffer size and set data pointer to position 0. */
  USIC0_CH1->TBCTR |= ((UART_FIFO_SIZE << USIC_CH_TBCTR_SIZE_Pos) | (0x00 << USIC_CH_TBCTR_DPTR_Pos));
100019e8:	04c9      	lsls	r1, r1, #19
  USIC0_CH1->KSCFG |= USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk;

  /* fFD = fPB. */
  /* FDR.DM = 02b (Fractional divider mode). */
  USIC0_CH1->FDR &= ~(USIC_CH_FDR_DM_Msk | USIC_CH_FDR_STEP_Msk);
  USIC0_CH1->FDR |= (0x02UL << USIC_CH_FDR_DM_Pos) | (FDR_STEP << USIC_CH_FDR_STEP_Pos);
100019ea:	4313      	orrs	r3, r2
100019ec:	6123      	str	r3, [r4, #16]

  /* Configure baud rate generator: */
  /* BAUDRATE = fCTQIN/(BRG.PCTQ x BRG.DCTQ). */
  /* CLKSEL = 0 (fPIN = fFD), CTQSEL = 00b (fCTQIN = fPDIV), PPPEN = 0 (fPPP=fPIN). */
  USIC0_CH1->BRG &= ~(USIC_CH_BRG_PCTQ_Msk | USIC_CH_BRG_DCTQ_Msk | USIC_CH_BRG_PDIV_Msk | USIC_CH_BRG_CLKSEL_Msk |
100019ee:	6962      	ldr	r2, [r4, #20]
100019f0:	4b28      	ldr	r3, [pc, #160]	; (10001a94 <UART_Init+0xe4>)

  /* Set Transmit Data Buffer size and set data pointer to position 0. */
  USIC0_CH1->TBCTR |= ((UART_FIFO_SIZE << USIC_CH_TBCTR_SIZE_Pos) | (0x00 << USIC_CH_TBCTR_DPTR_Pos));

  /* Init UART_RX (P1.3 --> DX0A, or P2.11 --> DX0E): */
  XMC_GPIO_SetMode(P1_3, XMC_GPIO_MODE_INPUT_TRISTATE);
100019f2:	4829      	ldr	r0, [pc, #164]	; (10001a98 <UART_Init+0xe8>)
  USIC0_CH1->FDR |= (0x02UL << USIC_CH_FDR_DM_Pos) | (FDR_STEP << USIC_CH_FDR_STEP_Pos);

  /* Configure baud rate generator: */
  /* BAUDRATE = fCTQIN/(BRG.PCTQ x BRG.DCTQ). */
  /* CLKSEL = 0 (fPIN = fFD), CTQSEL = 00b (fCTQIN = fPDIV), PPPEN = 0 (fPPP=fPIN). */
  USIC0_CH1->BRG &= ~(USIC_CH_BRG_PCTQ_Msk | USIC_CH_BRG_DCTQ_Msk | USIC_CH_BRG_PDIV_Msk | USIC_CH_BRG_CLKSEL_Msk |
100019f4:	4013      	ands	r3, r2
100019f6:	6163      	str	r3, [r4, #20]
                    USIC_CH_BRG_PPPEN_Msk);
  USIC0_CH1->BRG |= (BRG_PCTQ << USIC_CH_BRG_PCTQ_Pos) | (BRG_DCTQ << USIC_CH_BRG_DCTQ_Pos) |
100019f8:	6963      	ldr	r3, [r4, #20]
100019fa:	4a28      	ldr	r2, [pc, #160]	; (10001a9c <UART_Init+0xec>)
100019fc:	4313      	orrs	r3, r2
100019fe:	6163      	str	r3, [r4, #20]
  /* SCTR.TRM = 1 (Transmission Mode). */
  /*
   * SCTR.PDL = 1 (This bit defines the output level at the shift data output signal when no data is available
   * for transmission).
   */
  USIC0_CH1->SCTR &= ~(USIC_CH_SCTR_TRM_Msk | USIC_CH_SCTR_FLE_Msk | USIC_CH_SCTR_WLE_Msk);
10001a00:	6b62      	ldr	r2, [r4, #52]	; 0x34
10001a02:	4b27      	ldr	r3, [pc, #156]	; (10001aa0 <UART_Init+0xf0>)
10001a04:	4013      	ands	r3, r2
10001a06:	6363      	str	r3, [r4, #52]	; 0x34
  USIC0_CH1->SCTR |= USIC_CH_SCTR_PDL_Msk | (0x01UL << USIC_CH_SCTR_TRM_Pos) | (0x07UL << USIC_CH_SCTR_FLE_Pos) |
10001a08:	6b63      	ldr	r3, [r4, #52]	; 0x34
10001a0a:	4a26      	ldr	r2, [pc, #152]	; (10001aa4 <UART_Init+0xf4>)
10001a0c:	4313      	orrs	r3, r2
10001a0e:	6363      	str	r3, [r4, #52]	; 0x34
  /* TBUF.TDEN = 1 (TBUF Data Enable: A transmission of the data word in TBUF can be started if TDV = 1. */
  /*
   * TBUF.TDSSM = 1 (Data Single Shot Mode: allow word-by-word data transmission which avoid sending the same data
   * several times.
   */
  USIC0_CH1->TCSR &= ~(USIC_CH_TCSR_TDEN_Msk);
10001a10:	6ba2      	ldr	r2, [r4, #56]	; 0x38
10001a12:	4b25      	ldr	r3, [pc, #148]	; (10001aa8 <UART_Init+0xf8>)
10001a14:	4013      	ands	r3, r2
  USIC0_CH1->TCSR |= USIC_CH_TCSR_TDSSM_Msk | (0x01UL << USIC_CH_TCSR_TDEN_Pos);
10001a16:	22a0      	movs	r2, #160	; 0xa0
  /* TBUF.TDEN = 1 (TBUF Data Enable: A transmission of the data word in TBUF can be started if TDV = 1. */
  /*
   * TBUF.TDSSM = 1 (Data Single Shot Mode: allow word-by-word data transmission which avoid sending the same data
   * several times.
   */
  USIC0_CH1->TCSR &= ~(USIC_CH_TCSR_TDEN_Msk);
10001a18:	63a3      	str	r3, [r4, #56]	; 0x38
  USIC0_CH1->TCSR |= USIC_CH_TCSR_TDSSM_Msk | (0x01UL << USIC_CH_TCSR_TDEN_Pos);
10001a1a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
10001a1c:	00d2      	lsls	r2, r2, #3
10001a1e:	4313      	orrs	r3, r2
10001a20:	63a3      	str	r3, [r4, #56]	; 0x38
  /* Configuration of Protocol Control Register: */
  /* PCR.SMD = 1 (Sample Mode based on majority). */
  /* PCR.STPB = 0 (1x Stop bit). */
  /* PCR.SP = 5 (Sample Point). */
  /* PCR.PL = 0 (Pulse Length is equal to the bit length). */
  USIC0_CH1->PCR &= ~(USIC_CH_PCR_ASCMode_STPB_Msk | USIC_CH_PCR_ASCMode_SP_Msk | USIC_CH_PCR_ASCMode_PL_Msk);
10001a22:	6be2      	ldr	r2, [r4, #60]	; 0x3c
10001a24:	4b21      	ldr	r3, [pc, #132]	; (10001aac <UART_Init+0xfc>)
10001a26:	4013      	ands	r3, r2
10001a28:	63e3      	str	r3, [r4, #60]	; 0x3c
  USIC0_CH1->PCR |= USIC_CH_PCR_ASCMode_SMD_Msk | (9 << USIC_CH_PCR_ASCMode_SP_Pos);
10001a2a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
10001a2c:	4a20      	ldr	r2, [pc, #128]	; (10001ab0 <UART_Init+0x100>)
10001a2e:	4313      	orrs	r3, r2
10001a30:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Configure Transmit Buffer: */
  /* Standard transmit buffer event is enabled. */
  /* Define start entry of Transmit Data FIFO buffer DPTR = 0. */
  USIC0_CH1->TBCTR &= ~(USIC_CH_TBCTR_SIZE_Msk | USIC_CH_TBCTR_DPTR_Msk);
10001a32:	2384      	movs	r3, #132	; 0x84
10001a34:	005b      	lsls	r3, r3, #1
10001a36:	58e2      	ldr	r2, [r4, r3]
10001a38:	4032      	ands	r2, r6
10001a3a:	50e2      	str	r2, [r4, r3]

  /* Set Transmit Data Buffer size and set data pointer to position 0. */
  USIC0_CH1->TBCTR |= ((UART_FIFO_SIZE << USIC_CH_TBCTR_SIZE_Pos) | (0x00 << USIC_CH_TBCTR_DPTR_Pos));
10001a3c:	58e2      	ldr	r2, [r4, r3]
10001a3e:	430a      	orrs	r2, r1
10001a40:	50e2      	str	r2, [r4, r3]

  /* Init UART_RX (P1.3 --> DX0A, or P2.11 --> DX0E): */
  XMC_GPIO_SetMode(P1_3, XMC_GPIO_MODE_INPUT_TRISTATE);
10001a42:	2103      	movs	r1, #3
10001a44:	2200      	movs	r2, #0
10001a46:	f000 fe3b 	bl	100026c0 <XMC_GPIO_SetMode>
  USIC0_CH1->DX0CR = 0x00000000; /* USIC0_CH1.DX0A <-- P1.3. */

  /* Configure Receive Buffer: */
  /* Standard Receive buffer event is enabled. */
  /* Define start entry of Receive Data FIFO buffer DPTR. */
  USIC0_CH1->RBCTR &= ~(USIC_CH_RBCTR_SIZE_Msk | USIC_CH_RBCTR_DPTR_Msk);
10001a4a:	2386      	movs	r3, #134	; 0x86
  /* Set Transmit Data Buffer size and set data pointer to position 0. */
  USIC0_CH1->TBCTR |= ((UART_FIFO_SIZE << USIC_CH_TBCTR_SIZE_Pos) | (0x00 << USIC_CH_TBCTR_DPTR_Pos));

  /* Init UART_RX (P1.3 --> DX0A, or P2.11 --> DX0E): */
  XMC_GPIO_SetMode(P1_3, XMC_GPIO_MODE_INPUT_TRISTATE);
  USIC0_CH1->DX0CR = 0x00000000; /* USIC0_CH1.DX0A <-- P1.3. */
10001a4c:	61e5      	str	r5, [r4, #28]

  /* Configure Receive Buffer: */
  /* Standard Receive buffer event is enabled. */
  /* Define start entry of Receive Data FIFO buffer DPTR. */
  USIC0_CH1->RBCTR &= ~(USIC_CH_RBCTR_SIZE_Msk | USIC_CH_RBCTR_DPTR_Msk);
10001a4e:	005b      	lsls	r3, r3, #1
10001a50:	58e2      	ldr	r2, [r4, r3]

  /* Set Receive Data Buffer Size and set data pointer to position max. */
  USIC0_CH1->RBCTR |= ((UART_FIFO_SIZE << USIC_CH_RBCTR_SIZE_Pos) | ((1 << UART_FIFO_SIZE) << USIC_CH_RBCTR_DPTR_Pos));
10001a52:	4918      	ldr	r1, [pc, #96]	; (10001ab4 <UART_Init+0x104>)
  USIC0_CH1->DX0CR = 0x00000000; /* USIC0_CH1.DX0A <-- P1.3. */

  /* Configure Receive Buffer: */
  /* Standard Receive buffer event is enabled. */
  /* Define start entry of Receive Data FIFO buffer DPTR. */
  USIC0_CH1->RBCTR &= ~(USIC_CH_RBCTR_SIZE_Msk | USIC_CH_RBCTR_DPTR_Msk);
10001a54:	4016      	ands	r6, r2
10001a56:	50e6      	str	r6, [r4, r3]

  /* Set Receive Data Buffer Size and set data pointer to position max. */
  USIC0_CH1->RBCTR |= ((UART_FIFO_SIZE << USIC_CH_RBCTR_SIZE_Pos) | ((1 << UART_FIFO_SIZE) << USIC_CH_RBCTR_DPTR_Pos));
10001a58:	58e2      	ldr	r2, [r4, r3]

  /* Init UART_TX (P1.2 --> DOUT): */
  XMC_GPIO_SetMode(P1_2, XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT7);
10001a5a:	480f      	ldr	r0, [pc, #60]	; (10001a98 <UART_Init+0xe8>)
  /* Standard Receive buffer event is enabled. */
  /* Define start entry of Receive Data FIFO buffer DPTR. */
  USIC0_CH1->RBCTR &= ~(USIC_CH_RBCTR_SIZE_Msk | USIC_CH_RBCTR_DPTR_Msk);

  /* Set Receive Data Buffer Size and set data pointer to position max. */
  USIC0_CH1->RBCTR |= ((UART_FIFO_SIZE << USIC_CH_RBCTR_SIZE_Pos) | ((1 << UART_FIFO_SIZE) << USIC_CH_RBCTR_DPTR_Pos));
10001a5c:	430a      	orrs	r2, r1
10001a5e:	50e2      	str	r2, [r4, r3]

  /* Init UART_TX (P1.2 --> DOUT): */
  XMC_GPIO_SetMode(P1_2, XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT7);
10001a60:	2102      	movs	r1, #2
10001a62:	22b8      	movs	r2, #184	; 0xb8
10001a64:	f000 fe2c 	bl	100026c0 <XMC_GPIO_SetMode>

  /* Configuration of Channel Control Register: */
  /* CCR.PM = 00 ( Disable parity generation). */
  /* CCR.MODE = 2 (ASC mode enabled). */
  USIC0_CH1->CCR &= ~(USIC_CH_CCR_PM_Msk | USIC_CH_CCR_MODE_Msk);
10001a68:	6c22      	ldr	r2, [r4, #64]	; 0x40
10001a6a:	4b13      	ldr	r3, [pc, #76]	; (10001ab8 <UART_Init+0x108>)
10001a6c:	4013      	ands	r3, r2
10001a6e:	6423      	str	r3, [r4, #64]	; 0x40
  USIC0_CH1->CCR |= 0x02UL << USIC_CH_CCR_MODE_Pos;
10001a70:	2302      	movs	r3, #2
10001a72:	6c22      	ldr	r2, [r4, #64]	; 0x40
10001a74:	4313      	orrs	r3, r2
10001a76:	6423      	str	r3, [r4, #64]	; 0x40

}
10001a78:	bd70      	pop	{r4, r5, r6, pc}
10001a7a:	46c0      	nop			; (mov r8, r8)
10001a7c:	40010000 	.word	0x40010000
10001a80:	40010300 	.word	0x40010300
10001a84:	48000200 	.word	0x48000200
10001a88:	ffff3c00 	.word	0xffff3c00
10001a8c:	f8ffffc0 	.word	0xf8ffffc0
10001a90:	0000832b 	.word	0x0000832b
10001a94:	fc0080ec 	.word	0xfc0080ec
10001a98:	40040100 	.word	0x40040100
10001a9c:	00152400 	.word	0x00152400
10001aa0:	f0c0fcff 	.word	0xf0c0fcff
10001aa4:	07070102 	.word	0x07070102
10001aa8:	fffff3ff 	.word	0xfffff3ff
10001aac:	ffff00fd 	.word	0xffff00fd
10001ab0:	00000901 	.word	0x00000901
10001ab4:	05000020 	.word	0x05000020
10001ab8:	fffffcf0 	.word	0xfffffcf0

10001abc <UART_TX_String>:
  *
  * @param  None
  * @retval None
  */
void UART_TX_String (const char * String_Ptr)
{
10001abc:	b510      	push	{r4, lr}
10001abe:	1c04      	adds	r4, r0, #0
	uint16_t S_Count = 0;

	Temp_Ptr = String_Ptr;

	/* Transmit string until Null character (end of string), or to user-defined maximum length */
	while ((*Temp_Ptr != '\0') && (S_Count < STRING_MAX_NO))
10001ac0:	7803      	ldrb	r3, [r0, #0]
10001ac2:	3420      	adds	r4, #32
10001ac4:	2b00      	cmp	r3, #0
10001ac6:	d00a      	beq.n	10001ade <UART_TX_String+0x22>
	{
		/* Put one byte to USIC Transmit FIFO Buffer */
		UART_FIFO_BUFFER = *Temp_Ptr;
10001ac8:	22c0      	movs	r2, #192	; 0xc0
10001aca:	4905      	ldr	r1, [pc, #20]	; (10001ae0 <UART_TX_String+0x24>)
10001acc:	0052      	lsls	r2, r2, #1
10001ace:	e001      	b.n	10001ad4 <UART_TX_String+0x18>
	uint16_t S_Count = 0;

	Temp_Ptr = String_Ptr;

	/* Transmit string until Null character (end of string), or to user-defined maximum length */
	while ((*Temp_Ptr != '\0') && (S_Count < STRING_MAX_NO))
10001ad0:	42a0      	cmp	r0, r4
10001ad2:	d004      	beq.n	10001ade <UART_TX_String+0x22>
	{
		/* Put one byte to USIC Transmit FIFO Buffer */
		UART_FIFO_BUFFER = *Temp_Ptr;
10001ad4:	508b      	str	r3, [r1, r2]
		S_Count ++;
		Temp_Ptr ++;
10001ad6:	3001      	adds	r0, #1
	uint16_t S_Count = 0;

	Temp_Ptr = String_Ptr;

	/* Transmit string until Null character (end of string), or to user-defined maximum length */
	while ((*Temp_Ptr != '\0') && (S_Count < STRING_MAX_NO))
10001ad8:	7803      	ldrb	r3, [r0, #0]
10001ada:	2b00      	cmp	r3, #0
10001adc:	d1f8      	bne.n	10001ad0 <UART_TX_String+0x14>
		UART_FIFO_BUFFER = *Temp_Ptr;
		S_Count ++;
		Temp_Ptr ++;
	}

}
10001ade:	bd10      	pop	{r4, pc}
10001ae0:	48000200 	.word	0x48000200

10001ae4 <UART_TX_Return_NewLine>:
  * @param  None
  * @retval None
  */

void UART_TX_Return_NewLine (uint16_t N_times)
{
10001ae4:	b530      	push	{r4, r5, lr}

	uint16_t K_Counter;

	for (K_Counter = 0; K_Counter < N_times; K_Counter ++)
10001ae6:	2300      	movs	r3, #0
10001ae8:	2800      	cmp	r0, #0
10001aea:	d00a      	beq.n	10001b02 <UART_TX_Return_NewLine+0x1e>
	{
		/* Carriage return, \r. */
		UART_FIFO_BUFFER = 0x0D;
10001aec:	22c0      	movs	r2, #192	; 0xc0
10001aee:	250d      	movs	r5, #13

		/*  New line / Line Feed, \n.*/
		UART_FIFO_BUFFER = 0x0A;
10001af0:	240a      	movs	r4, #10
	uint16_t K_Counter;

	for (K_Counter = 0; K_Counter < N_times; K_Counter ++)
	{
		/* Carriage return, \r. */
		UART_FIFO_BUFFER = 0x0D;
10001af2:	4904      	ldr	r1, [pc, #16]	; (10001b04 <UART_TX_Return_NewLine+0x20>)
10001af4:	0052      	lsls	r2, r2, #1
void UART_TX_Return_NewLine (uint16_t N_times)
{

	uint16_t K_Counter;

	for (K_Counter = 0; K_Counter < N_times; K_Counter ++)
10001af6:	3301      	adds	r3, #1
10001af8:	b29b      	uxth	r3, r3
	{
		/* Carriage return, \r. */
		UART_FIFO_BUFFER = 0x0D;
10001afa:	508d      	str	r5, [r1, r2]

		/*  New line / Line Feed, \n.*/
		UART_FIFO_BUFFER = 0x0A;
10001afc:	508c      	str	r4, [r1, r2]
void UART_TX_Return_NewLine (uint16_t N_times)
{

	uint16_t K_Counter;

	for (K_Counter = 0; K_Counter < N_times; K_Counter ++)
10001afe:	4283      	cmp	r3, r0
10001b00:	d1f9      	bne.n	10001af6 <UART_TX_Return_NewLine+0x12>

		/*  New line / Line Feed, \n.*/
		UART_FIFO_BUFFER = 0x0A;
	}

}
10001b02:	bd30      	pop	{r4, r5, pc}
10001b04:	48000200 	.word	0x48000200

10001b08 <UART_TX_uint16_t>:
	#define DVDSLC_UART		0								// Dividend Shift Left Count
	#define DVSSRC_UART		0								// Divisor Shift Right Count.
	#define QSCNT_UART		0								// Quotient Shift Count.

	/* Unsigned Div. Quotient right shift */
	MATH->DIVCON = 0x00008004 | (DVDSLC_UART << 16U) | (DVSSRC_UART << 24U) | (QSCNT_UART << 8U);
10001b08:	4a2b      	ldr	r2, [pc, #172]	; (10001bb8 <UART_TX_uint16_t+0xb0>)
10001b0a:	4b2c      	ldr	r3, [pc, #176]	; (10001bbc <UART_TX_uint16_t+0xb4>)

	/* Integer_16: 10000 ~ 65535 */
	if (Integer_16 > 9999)
10001b0c:	492c      	ldr	r1, [pc, #176]	; (10001bc0 <UART_TX_uint16_t+0xb8>)
	#define DVDSLC_UART		0								// Dividend Shift Left Count
	#define DVSSRC_UART		0								// Divisor Shift Right Count.
	#define QSCNT_UART		0								// Quotient Shift Count.

	/* Unsigned Div. Quotient right shift */
	MATH->DIVCON = 0x00008004 | (DVDSLC_UART << 16U) | (DVSSRC_UART << 24U) | (QSCNT_UART << 8U);
10001b0e:	635a      	str	r2, [r3, #52]	; 0x34
10001b10:	2209      	movs	r2, #9

	/* Integer_16: 10000 ~ 65535 */
	if (Integer_16 > 9999)
10001b12:	4288      	cmp	r0, r1
10001b14:	d90f      	bls.n	10001b36 <UART_TX_uint16_t+0x2e>
	{
		/*11111** Divider Unit (DIV) #01 **11111*/
		MATH->DVD = Integer_16;

		/* Input Divisor, and auto start of DIV calculation (~35 kernel clock cycles) */
		MATH->DVS = 10000;
10001b16:	492b      	ldr	r1, [pc, #172]	; (10001bc4 <UART_TX_uint16_t+0xbc>)

	/* Integer_16: 10000 ~ 65535 */
	if (Integer_16 > 9999)
	{
		/*11111** Divider Unit (DIV) #01 **11111*/
		MATH->DVD = Integer_16;
10001b18:	6218      	str	r0, [r3, #32]

		/* Input Divisor, and auto start of DIV calculation (~35 kernel clock cycles) */
		MATH->DVS = 10000;
10001b1a:	6259      	str	r1, [r3, #36]	; 0x24

		/* Horizontal Tab. \v is Vertical Tab */
		UART_FIFO_BUFFER = '\t';
10001b1c:	21c0      	movs	r1, #192	; 0xc0
10001b1e:	482a      	ldr	r0, [pc, #168]	; (10001bc8 <UART_TX_uint16_t+0xc0>)
10001b20:	0049      	lsls	r1, r1, #1
10001b22:	5042      	str	r2, [r0, r1]

    /* Wait if DIV is still running calculation */
    while (MATH->DIVST)
10001b24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
10001b26:	4925      	ldr	r1, [pc, #148]	; (10001bbc <UART_TX_uint16_t+0xb4>)
10001b28:	2a00      	cmp	r2, #0
10001b2a:	d1fb      	bne.n	10001b24 <UART_TX_uint16_t+0x1c>
    {
      continue;
    }

		/* Read DIV Quotient result */
		Int_digit = MATH->QUOT;
10001b2c:	6a8a      	ldr	r2, [r1, #40]	; 0x28

		Integer_16 = MATH->RMD;
10001b2e:	6ac8      	ldr	r0, [r1, #44]	; 0x2c

		/* ASCII of ten-thousands digit */
		Int_digit += DIFF_09_TO_ASCII;
10001b30:	3230      	adds	r2, #48	; 0x30
    }

		/* Read DIV Quotient result */
		Int_digit = MATH->QUOT;

		Integer_16 = MATH->RMD;
10001b32:	b280      	uxth	r0, r0
10001b34:	b292      	uxth	r2, r2

	/* Dividend */
	MATH->DVD = Integer_16;

	/* Input Divisor, and auto start of DIV calculation */
	MATH->DVS = 1000;
10001b36:	21fa      	movs	r1, #250	; 0xfa
		/* Horizontal Tab. \v is Vertical Tab */
		Int_digit = '\t';
	}

	/* Dividend */
	MATH->DVD = Integer_16;
10001b38:	4b20      	ldr	r3, [pc, #128]	; (10001bbc <UART_TX_uint16_t+0xb4>)

	/* Input Divisor, and auto start of DIV calculation */
	MATH->DVS = 1000;
10001b3a:	0089      	lsls	r1, r1, #2
		/* Horizontal Tab. \v is Vertical Tab */
		Int_digit = '\t';
	}

	/* Dividend */
	MATH->DVD = Integer_16;
10001b3c:	6218      	str	r0, [r3, #32]

	/* Input Divisor, and auto start of DIV calculation */
	MATH->DVS = 1000;
10001b3e:	6259      	str	r1, [r3, #36]	; 0x24

	/* Put ten-thousands digit (or \t) to USIC Transmit FIFO Buffer */
	UART_FIFO_BUFFER = Int_digit;
10001b40:	21c0      	movs	r1, #192	; 0xc0
10001b42:	4821      	ldr	r0, [pc, #132]	; (10001bc8 <UART_TX_uint16_t+0xc0>)
10001b44:	0049      	lsls	r1, r1, #1
10001b46:	5042      	str	r2, [r0, r1]

  /* Wait if DIV is still running calculation. */
  while (MATH->DIVST)
10001b48:	1c1a      	adds	r2, r3, #0
10001b4a:	6b11      	ldr	r1, [r2, #48]	; 0x30
10001b4c:	4b1b      	ldr	r3, [pc, #108]	; (10001bbc <UART_TX_uint16_t+0xb4>)
10001b4e:	2900      	cmp	r1, #0
10001b50:	d1fb      	bne.n	10001b4a <UART_TX_uint16_t+0x42>
  {
    continue;
  }

	/* Read DIV Quotient result */
	Int_digit = MATH->QUOT;
10001b52:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	Integer_16 = MATH->RMD;
10001b54:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
10001b56:	0412      	lsls	r2, r2, #16

	/* Dividend */
	MATH->DVD = Integer_16;
10001b58:	0409      	lsls	r1, r1, #16
10001b5a:	0c09      	lsrs	r1, r1, #16
10001b5c:	6219      	str	r1, [r3, #32]

	/* Input Divisor, and auto start of DIV calculation */
	MATH->DVS = 100;
10001b5e:	2164      	movs	r1, #100	; 0x64
10001b60:	0c12      	lsrs	r2, r2, #16
10001b62:	6259      	str	r1, [r3, #36]	; 0x24

	/* Put thousands digit to USIC Transmit FIFO Buffer */
	UART_FIFO_BUFFER = Int_digit + DIFF_09_TO_ASCII;
10001b64:	4818      	ldr	r0, [pc, #96]	; (10001bc8 <UART_TX_uint16_t+0xc0>)
10001b66:	311d      	adds	r1, #29
10001b68:	3230      	adds	r2, #48	; 0x30
10001b6a:	31ff      	adds	r1, #255	; 0xff
10001b6c:	5042      	str	r2, [r0, r1]

  /* Wait if DIV is still running calculation */
  while (MATH->DIVST)
10001b6e:	1c1a      	adds	r2, r3, #0
10001b70:	6b11      	ldr	r1, [r2, #48]	; 0x30
10001b72:	4b12      	ldr	r3, [pc, #72]	; (10001bbc <UART_TX_uint16_t+0xb4>)
10001b74:	2900      	cmp	r1, #0
10001b76:	d1fb      	bne.n	10001b70 <UART_TX_uint16_t+0x68>
  {
    continue;
  }

	/*  Read DIV Quotient result */
	Int_digit = MATH->QUOT;
10001b78:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	Integer_16 = MATH->RMD;
10001b7a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
10001b7c:	0412      	lsls	r2, r2, #16

	/* Dividend */
	MATH->DVD = Integer_16;
10001b7e:	0409      	lsls	r1, r1, #16
10001b80:	0c09      	lsrs	r1, r1, #16
10001b82:	6219      	str	r1, [r3, #32]

	/* Input Divisor, and auto start of DIV calculation */
	MATH->DVS = 10;
10001b84:	210a      	movs	r1, #10
10001b86:	0c12      	lsrs	r2, r2, #16
10001b88:	6259      	str	r1, [r3, #36]	; 0x24

	/* Put hundreds digit to USIC Transmit FIFO Buffer */
	UART_FIFO_BUFFER = Int_digit + DIFF_09_TO_ASCII;
10001b8a:	480f      	ldr	r0, [pc, #60]	; (10001bc8 <UART_TX_uint16_t+0xc0>)
10001b8c:	3177      	adds	r1, #119	; 0x77
10001b8e:	3230      	adds	r2, #48	; 0x30
10001b90:	31ff      	adds	r1, #255	; 0xff
10001b92:	5042      	str	r2, [r0, r1]

  /* Wait if DIV is still running calculation */
  while (MATH->DIVST)
10001b94:	6b19      	ldr	r1, [r3, #48]	; 0x30
10001b96:	4a09      	ldr	r2, [pc, #36]	; (10001bbc <UART_TX_uint16_t+0xb4>)
10001b98:	2900      	cmp	r1, #0
10001b9a:	d1fb      	bne.n	10001b94 <UART_TX_uint16_t+0x8c>
  {
    continue;
  }

	/* Read DIV Quotient result */
	Int_digit = MATH->QUOT;
10001b9c:	6a93      	ldr	r3, [r2, #40]	; 0x28

	/* Put tens digit to USIC Transmit FIFO Buffer */
	UART_FIFO_BUFFER = Int_digit + DIFF_09_TO_ASCII;
10001b9e:	480a      	ldr	r0, [pc, #40]	; (10001bc8 <UART_TX_uint16_t+0xc0>)
10001ba0:	041b      	lsls	r3, r3, #16
10001ba2:	0c1b      	lsrs	r3, r3, #16
10001ba4:	3181      	adds	r1, #129	; 0x81
10001ba6:	31ff      	adds	r1, #255	; 0xff
10001ba8:	3330      	adds	r3, #48	; 0x30
10001baa:	5043      	str	r3, [r0, r1]

	/* Put units digit to USIC Transmit FIFO Buffer */
	Integer_16 = MATH->RMD;
10001bac:	6ad3      	ldr	r3, [r2, #44]	; 0x2c

	/*  Put units digit to USIC Transmit FIFO Buffer. */
	UART_FIFO_BUFFER = Integer_16 + DIFF_09_TO_ASCII;

}
10001bae:	041b      	lsls	r3, r3, #16
10001bb0:	0c1b      	lsrs	r3, r3, #16

	/* Put units digit to USIC Transmit FIFO Buffer */
	Integer_16 = MATH->RMD;

	/*  Put units digit to USIC Transmit FIFO Buffer. */
	UART_FIFO_BUFFER = Integer_16 + DIFF_09_TO_ASCII;
10001bb2:	3330      	adds	r3, #48	; 0x30
10001bb4:	5043      	str	r3, [r0, r1]

}
10001bb6:	4770      	bx	lr
10001bb8:	00008004 	.word	0x00008004
10001bbc:	40030000 	.word	0x40030000
10001bc0:	0000270f 	.word	0x0000270f
10001bc4:	00002710 	.word	0x00002710
10001bc8:	48000200 	.word	0x48000200

10001bcc <WDT_Init>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize and enable watchdog timer */
void WDT_Init(void)
{
10001bcc:	b508      	push	{r3, lr}
  XMC_WDT_Init(&wdt_init);
10001bce:	4802      	ldr	r0, [pc, #8]	; (10001bd8 <WDT_Init+0xc>)
10001bd0:	f000 fef4 	bl	100029bc <XMC_WDT_Init>
}
10001bd4:	bd08      	pop	{r3, pc}
10001bd6:	46c0      	nop			; (mov r8, r8)
10001bd8:	20000650 	.word	0x20000650

10001bdc <CCU80_1_IRQHandler>:
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
10001bdc:	2280      	movs	r2, #128	; 0x80
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* Trap protection interrupt, e.g.: for over-current protection, triggered by CCU8x Event2 */
void Trap_Protection_INT(void)
{
10001bde:	b508      	push	{r3, lr}
10001be0:	4b04      	ldr	r3, [pc, #16]	; (10001bf4 <CCU80_1_IRQHandler+0x18>)
10001be2:	0512      	lsls	r2, r2, #20
10001be4:	605a      	str	r2, [r3, #4]
  XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, DISABLE_LEVEL); /* Disable gate driver. */

  Motor.State = TRAP_PROTECTION; /*
10001be6:	2209      	movs	r2, #9
10001be8:	4b03      	ldr	r3, [pc, #12]	; (10001bf8 <CCU80_1_IRQHandler+0x1c>)
                                  * Next PWM cycles, go to trap protection, until MCU reset / POR
                                  * to resume normal motor operation.
                                  */

  UART_TX_String("\r\n\nCCU8 Trap!!");
10001bea:	4804      	ldr	r0, [pc, #16]	; (10001bfc <CCU80_1_IRQHandler+0x20>)
/* Trap protection interrupt, e.g.: for over-current protection, triggered by CCU8x Event2 */
void Trap_Protection_INT(void)
{
  XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, DISABLE_LEVEL); /* Disable gate driver. */

  Motor.State = TRAP_PROTECTION; /*
10001bec:	62da      	str	r2, [r3, #44]	; 0x2c
                                  * Next PWM cycles, go to trap protection, until MCU reset / POR
                                  * to resume normal motor operation.
                                  */

  UART_TX_String("\r\n\nCCU8 Trap!!");
10001bee:	f7ff ff65 	bl	10001abc <UART_TX_String>

} /* End of CCU80_1_IRQHandler () */
10001bf2:	bd08      	pop	{r3, pc}
10001bf4:	40040000 	.word	0x40040000
10001bf8:	20001244 	.word	0x20001244
10001bfc:	1000301c 	.word	0x1000301c

10001c00 <Error_Handling>:
 */
void Error_Handling(void)
{
  static uint32_t Cycle_Counter = 0; /* Static variable and init. */

  if ((Motor.State == TRAP_PROTECTION) && (SYSTEM_BE_IDLE))
10001c00:	4b10      	ldr	r3, [pc, #64]	; (10001c44 <Error_Handling+0x44>)
/*
 * Error handling, e.g.: to handle CCU8 TRAP protection
 * Execution time: ??us (O3 - Optimize most).
 */
void Error_Handling(void)
{
10001c02:	b510      	push	{r4, lr}
  static uint32_t Cycle_Counter = 0; /* Static variable and init. */

  if ((Motor.State == TRAP_PROTECTION) && (SYSTEM_BE_IDLE))
10001c04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
10001c06:	2a09      	cmp	r2, #9
10001c08:	d003      	beq.n	10001c12 <Error_Handling+0x12>

    }
  }
  else
  {
    Cycle_Counter = 0; /* Clear counter. */
10001c0a:	2200      	movs	r2, #0
10001c0c:	4b0e      	ldr	r3, [pc, #56]	; (10001c48 <Error_Handling+0x48>)
10001c0e:	601a      	str	r2, [r3, #0]
  }

} /* End of Error_Handling () */
10001c10:	bd10      	pop	{r4, pc}
 */
void Error_Handling(void)
{
  static uint32_t Cycle_Counter = 0; /* Static variable and init. */

  if ((Motor.State == TRAP_PROTECTION) && (SYSTEM_BE_IDLE))
10001c12:	4a0e      	ldr	r2, [pc, #56]	; (10001c4c <Error_Handling+0x4c>)
10001c14:	6a12      	ldr	r2, [r2, #32]
10001c16:	2a31      	cmp	r2, #49	; 0x31
10001c18:	dcf7      	bgt.n	10001c0a <Error_Handling+0xa>
  {
    /* If CCU8 TRAP has occurred, and system becomes idle (i.e.: PWM duty cycle or POT ADC too low), */
    Cycle_Counter++;
10001c1a:	490b      	ldr	r1, [pc, #44]	; (10001c48 <Error_Handling+0x48>)
10001c1c:	680a      	ldr	r2, [r1, #0]
10001c1e:	3201      	adds	r2, #1
10001c20:	600a      	str	r2, [r1, #0]

    if (Cycle_Counter > MAX_CYCLE_TIME)
10001c22:	490b      	ldr	r1, [pc, #44]	; (10001c50 <Error_Handling+0x50>)
10001c24:	428a      	cmp	r2, r1
10001c26:	d9f3      	bls.n	10001c10 <Error_Handling+0x10>
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
10001c28:	21b0      	movs	r1, #176	; 0xb0
10001c2a:	2480      	movs	r4, #128	; 0x80
10001c2c:	4809      	ldr	r0, [pc, #36]	; (10001c54 <Error_Handling+0x54>)
10001c2e:	00e4      	lsls	r4, r4, #3
10001c30:	5842      	ldr	r2, [r0, r1]
10001c32:	4322      	orrs	r2, r4
10001c34:	5042      	str	r2, [r0, r1]
10001c36:	2180      	movs	r1, #128	; 0x80
10001c38:	4a07      	ldr	r2, [pc, #28]	; (10001c58 <Error_Handling+0x58>)
10001c3a:	0109      	lsls	r1, r1, #4
10001c3c:	6051      	str	r1, [r2, #4]
    {

			  XMC_CCU8_SLICE_ClearEvent(CCU8_MODULE_PHASE_U,XMC_CCU8_SLICE_IRQ_ID_EVENT2);

        XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, ENABLE_LEVEL); /* Enable gate driver. */
        Motor.State = STOP_MOTOR;
10001c3e:	2203      	movs	r2, #3
10001c40:	62da      	str	r2, [r3, #44]	; 0x2c
10001c42:	e7e5      	b.n	10001c10 <Error_Handling+0x10>
10001c44:	20001244 	.word	0x20001244
10001c48:	20001000 	.word	0x20001000
10001c4c:	20001050 	.word	0x20001050
10001c50:	00001d4c 	.word	0x00001d4c
10001c54:	50000100 	.word	0x50000100
10001c58:	40040000 	.word	0x40040000

10001c5c <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* API to brake the motor, charge gate driver bootstrap capacitors */
void DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge(void)
{
10001c5c:	b538      	push	{r3, r4, r5, lr}
#if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
   ADC.ADC_Bias = (uint32_t) ((ADC.ADC_Bias * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_ResultTz1)
                                 >> SHIFT_BIAS_LPF;
#else
  Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
10001c5e:	4c1c      	ldr	r4, [pc, #112]	; (10001cd0 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x74>)
10001c60:	4b1c      	ldr	r3, [pc, #112]	; (10001cd4 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x78>)
10001c62:	1c22      	adds	r2, r4, #0
10001c64:	8858      	ldrh	r0, [r3, #2]
10001c66:	8819      	ldrh	r1, [r3, #0]
10001c68:	f001 f8ae 	bl	10002dc8 <__Get_ADCPhaseCurrent_veneer>


  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
10001c6c:	68a1      	ldr	r1, [r4, #8]
10001c6e:	8820      	ldrh	r0, [r4, #0]
10001c70:	00ca      	lsls	r2, r1, #3
10001c72:	1a53      	subs	r3, r2, r1
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
10001c74:	68e1      	ldr	r1, [r4, #12]
#else
  Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);


  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
10001c76:	18c3      	adds	r3, r0, r3
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
10001c78:	00ca      	lsls	r2, r1, #3
10001c7a:	8860      	ldrh	r0, [r4, #2]
  Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);


  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
                                 >> SHIFT_BIAS_LPF;
10001c7c:	08db      	lsrs	r3, r3, #3
#else
  Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);


  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
10001c7e:	60a3      	str	r3, [r4, #8]
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
10001c80:	1a53      	subs	r3, r2, r1
                                 >> SHIFT_BIAS_LPF;
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
10001c82:	6921      	ldr	r1, [r4, #16]

  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
10001c84:	18c3      	adds	r3, r0, r3
                                 >> SHIFT_BIAS_LPF;
10001c86:	08db      	lsrs	r3, r3, #3
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
10001c88:	88a0      	ldrh	r0, [r4, #4]
10001c8a:	00ca      	lsls	r2, r1, #3

  /* Read Iu ADC bias */
  ADC.ADC_Bias_Iu = (uint32_t) ((ADC.ADC_Bias_Iu * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iu)
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
10001c8c:	60e3      	str	r3, [r4, #12]
                                 >> SHIFT_BIAS_LPF;
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
10001c8e:	1a53      	subs	r3, r2, r1
10001c90:	18c3      	adds	r3, r0, r3
                                 >> SHIFT_BIAS_LPF;
#endif
  Motor.Counter++;
10001c92:	4d11      	ldr	r5, [pc, #68]	; (10001cd8 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x7c>)
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
                                 >> SHIFT_BIAS_LPF;
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
                                 >> SHIFT_BIAS_LPF;
10001c94:	08db      	lsrs	r3, r3, #3
                                 >> SHIFT_BIAS_LPF;
  /* Read Iv ADC bias */
  ADC.ADC_Bias_Iv = (uint32_t) ((ADC.ADC_Bias_Iv * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iv)
                                 >> SHIFT_BIAS_LPF;
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
10001c96:	6123      	str	r3, [r4, #16]
                                 >> SHIFT_BIAS_LPF;
#endif
  Motor.Counter++;
10001c98:	6beb      	ldr	r3, [r5, #60]	; 0x3c
10001c9a:	1c58      	adds	r0, r3, #1


  if (ADC.ADC_POT < TH_POT_ADC)
10001c9c:	6a23      	ldr	r3, [r4, #32]
                                 >> SHIFT_BIAS_LPF;
  /* Read Iw ADC bias */
  ADC.ADC_Bias_Iw = (uint32_t) ((ADC.ADC_Bias_Iw * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_Iw)
                                 >> SHIFT_BIAS_LPF;
#endif
  Motor.Counter++;
10001c9e:	63e8      	str	r0, [r5, #60]	; 0x3c


  if (ADC.ADC_POT < TH_POT_ADC)
10001ca0:	2b31      	cmp	r3, #49	; 0x31
10001ca2:	dc02      	bgt.n	10001caa <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x4e>
  {
    /* If system is idle, i.e.: PWM duty cycle or POT ADC too low. */
    Motor.Counter = 0U; /* cannot go to ramp up, keep motor braking. */
10001ca4:	2300      	movs	r3, #0
10001ca6:	63eb      	str	r3, [r5, #60]	; 0x3c
    /* Set ADC trigger for ADCTz1/Tz2, for single-shunt current sensing only. */
    ADCTZ12_TriggerSetting ();
#endif
  }

}
10001ca8:	bd38      	pop	{r3, r4, r5, pc}
    /* If system is idle, i.e.: PWM duty cycle or POT ADC too low. */
    Motor.Counter = 0U; /* cannot go to ramp up, keep motor braking. */
  }

  /*Timer decides when to stop motor braking. */
  if (Motor.Counter > BRAKE_TIME)
10001caa:	f000 ffe9 	bl	10002c80 <__aeabi_ui2f>
10001cae:	490b      	ldr	r1, [pc, #44]	; (10001cdc <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x80>)
10001cb0:	f000 ff18 	bl	10002ae4 <__aeabi_fcmpgt>
10001cb4:	2800      	cmp	r0, #0
10001cb6:	d0f7      	beq.n	10001ca8 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x4c>
  {
    /* Next, go to rotor initial preposition/alignment. */
    Motor.State = (uint32_t) PRE_POSITIONING;
10001cb8:	2306      	movs	r3, #6
10001cba:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Motor in transition mode. */
    Motor.Mode_Flag = MOTOR_TRANSITION;
10001cbc:	2300      	movs	r3, #0
    /* Clear counters. */
    Motor.Counter = 0U;
    Motor.Ramp_Counter = 0U;

    Current.I_U = 0;
10001cbe:	4a08      	ldr	r2, [pc, #32]	; (10001ce0 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x84>)
  {
    /* Next, go to rotor initial preposition/alignment. */
    Motor.State = (uint32_t) PRE_POSITIONING;

    /* Motor in transition mode. */
    Motor.Mode_Flag = MOTOR_TRANSITION;
10001cc0:	866b      	strh	r3, [r5, #50]	; 0x32
    /* Clear counters. */
    Motor.Counter = 0U;
10001cc2:	63eb      	str	r3, [r5, #60]	; 0x3c
    Motor.Ramp_Counter = 0U;
10001cc4:	642b      	str	r3, [r5, #64]	; 0x40

    Current.I_U = 0;
10001cc6:	6013      	str	r3, [r2, #0]
    Current.I_V = 0;
10001cc8:	6053      	str	r3, [r2, #4]
    Current.I_W = 0;
10001cca:	6093      	str	r3, [r2, #8]
10001ccc:	e7ec      	b.n	10001ca8 <DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge+0x4c>
10001cce:	46c0      	nop			; (mov r8, r8)
10001cd0:	20001050 	.word	0x20001050
10001cd4:	20001018 	.word	0x20001018
10001cd8:	20001244 	.word	0x20001244
10001cdc:	43960000 	.word	0x43960000
10001ce0:	200010c4 	.word	0x200010c4

10001ce4 <DirectFOCRotor_Pre_Positioning>:
/* End of DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge () */

/* API to set the Rotor initial preposition/alignment */
#define MIN_TORQUE_TOSTART  (USER_IQ_REF_HIGH_LIMIT * 0.3)
void DirectFOCRotor_Pre_Positioning(void)
{
10001ce4:	b538      	push	{r3, r4, r5, lr}

  /* Single-shunt or 2or3-shunt 3-phase current reconstruction, to get Iu and Iv. */
#if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
  Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Current);
#else
  Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
10001ce6:	4b39      	ldr	r3, [pc, #228]	; (10001dcc <DirectFOCRotor_Pre_Positioning+0xe8>)
10001ce8:	4c39      	ldr	r4, [pc, #228]	; (10001dd0 <DirectFOCRotor_Pre_Positioning+0xec>)
10001cea:	8859      	ldrh	r1, [r3, #2]
10001cec:	889a      	ldrh	r2, [r3, #4]
10001cee:	8818      	ldrh	r0, [r3, #0]
10001cf0:	1c23      	adds	r3, r4, #0
10001cf2:	f001 f859 	bl	10002da8 <__Current_Reconstruction_veneer>
  HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
  HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));

#else

  if(SVM.Flag_3or2_ADC == 0){
10001cf6:	4937      	ldr	r1, [pc, #220]	; (10001dd4 <DirectFOCRotor_Pre_Positioning+0xf0>)
#endif
  ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
10001cf8:	6822      	ldr	r2, [r4, #0]
10001cfa:	8889      	ldrh	r1, [r1, #4]
10001cfc:	6865      	ldr	r5, [r4, #4]
10001cfe:	68a3      	ldr	r3, [r4, #8]
10001d00:	2900      	cmp	r1, #0
10001d02:	d13a      	bne.n	10001d7a <DirectFOCRotor_Pre_Positioning+0x96>
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
10001d04:	18e9      	adds	r1, r5, r3
10001d06:	0052      	lsls	r2, r2, #1
10001d08:	1a50      	subs	r0, r2, r1
10001d0a:	4933      	ldr	r1, [pc, #204]	; (10001dd8 <DirectFOCRotor_Pre_Positioning+0xf4>)
10001d0c:	4c33      	ldr	r4, [pc, #204]	; (10001ddc <DirectFOCRotor_Pre_Positioning+0xf8>)
10001d0e:	4341      	muls	r1, r0
10001d10:	6021      	str	r1, [r4, #0]

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001d12:	4933      	ldr	r1, [pc, #204]	; (10001de0 <DirectFOCRotor_Pre_Positioning+0xfc>)
10001d14:	1aeb      	subs	r3, r5, r3
10001d16:	434b      	muls	r3, r1
10001d18:	6063      	str	r3, [r4, #4]

  /* Rotor preposition/alignment counter ++. */
  Motor.Alignment_Counter++;
10001d1a:	4c32      	ldr	r4, [pc, #200]	; (10001de4 <DirectFOCRotor_Pre_Positioning+0x100>)
  if (Motor.Alignment_Counter < ALIGNMENT_TIME)
10001d1c:	4a32      	ldr	r2, [pc, #200]	; (10001de8 <DirectFOCRotor_Pre_Positioning+0x104>)
  Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
#endif
  ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);

  /* Rotor preposition/alignment counter ++. */
  Motor.Alignment_Counter++;
10001d1e:	6c63      	ldr	r3, [r4, #68]	; 0x44
10001d20:	3301      	adds	r3, #1
10001d22:	6463      	str	r3, [r4, #68]	; 0x44
  if (Motor.Alignment_Counter < ALIGNMENT_TIME)
10001d24:	4293      	cmp	r3, r2
10001d26:	d814      	bhi.n	10001d52 <DirectFOCRotor_Pre_Positioning+0x6e>
  {

    if (Car2Polar.SVM_Vref16 < PRE_POSIT_VOLT)
10001d28:	4d30      	ldr	r5, [pc, #192]	; (10001dec <DirectFOCRotor_Pre_Positioning+0x108>)
10001d2a:	8b28      	ldrh	r0, [r5, #24]
10001d2c:	287b      	cmp	r0, #123	; 0x7b
10001d2e:	d934      	bls.n	10001d9a <DirectFOCRotor_Pre_Positioning+0xb6>

#endif
  }

  /* Update SVM PWM. */
  PWMSVM01_Update(Car2Polar.SVM_Vref16, Car2Polar.SVM_Angle16);
10001d30:	8b69      	ldrh	r1, [r5, #26]
10001d32:	f001 f841 	bl	10002db8 <__PWMSVM01_Update_veneer>
  /* Record SVM reference vector magnitude (32-bit) of last PWM cycle. */
  Car2Polar.Vref32_Previous = Car2Polar.Vref32;
10001d36:	68ab      	ldr	r3, [r5, #8]
  Car2Polar.Vref32 = (uint32_t) Car2Polar.SVM_Vref16 << CORDIC_SHIFT;

  /* Init for smooth transition from V/f to FOC closed-loop. */
  Init_Smooth_Transition_To_FOC(Motor.Speed);
10001d38:	68a0      	ldr	r0, [r4, #8]
  }

  /* Update SVM PWM. */
  PWMSVM01_Update(Car2Polar.SVM_Vref16, Car2Polar.SVM_Angle16);
  /* Record SVM reference vector magnitude (32-bit) of last PWM cycle. */
  Car2Polar.Vref32_Previous = Car2Polar.Vref32;
10001d3a:	612b      	str	r3, [r5, #16]
  Car2Polar.Vref32 = (uint32_t) Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
10001d3c:	8b2b      	ldrh	r3, [r5, #24]
10001d3e:	039b      	lsls	r3, r3, #14
10001d40:	60ab      	str	r3, [r5, #8]

  /* Init for smooth transition from V/f to FOC closed-loop. */
  Init_Smooth_Transition_To_FOC(Motor.Speed);
10001d42:	f000 f8a7 	bl	10001e94 <Init_Smooth_Transition_To_FOC>

  if (Motor.State == (uint32_t) FOC_CLOSED_LOOP)
10001d46:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10001d48:	2b00      	cmp	r3, #0
10001d4a:	d101      	bne.n	10001d50 <DirectFOCRotor_Pre_Positioning+0x6c>
  {
    /* Init parameters of FOC LIB. Init once only. */
    FOC_SystemParameters_Init_OnceOnly();
10001d4c:	f000 f870 	bl	10001e30 <FOC_SystemParameters_Init_OnceOnly>
  }

}
10001d50:	bd38      	pop	{r3, r4, r5, pc}
    }
  }
  else
  {
    /* Next, directly to FOC closed-loop for faster startup. */
    Motor.State = (uint32_t) FOC_CLOSED_LOOP;
10001d52:	2300      	movs	r3, #0
    Motor.Mode_Flag = MOTOR_TRANSITION;
    /* Clear counter. */
    Motor.Alignment_Counter = 0U;
    /* Init FOC rotor speed ωr = PI_PLL.Uk, needed for ωL|I|, ωLId, ωLIq,
     *  * and FG frequency calculation. */
    PI_PLL.Uk = (int32_t) Motor.Speed ;
10001d54:	68a2      	ldr	r2, [r4, #8]
10001d56:	4926      	ldr	r1, [pc, #152]	; (10001df0 <DirectFOCRotor_Pre_Positioning+0x10c>)
    /* Motor reference speed of FOC. */
    Motor.Ref_Speed = (int32_t) Motor.Speed;
    Ik_unsigned = (uint32_t) Car2Polar.SVM_Vref16 << PI_TORQUE_SCALE_KPKI;
10001d58:	4d24      	ldr	r5, [pc, #144]	; (10001dec <DirectFOCRotor_Pre_Positioning+0x108>)
    Motor.Mode_Flag = MOTOR_TRANSITION;
    /* Clear counter. */
    Motor.Alignment_Counter = 0U;
    /* Init FOC rotor speed ωr = PI_PLL.Uk, needed for ωL|I|, ωLId, ωLIq,
     *  * and FG frequency calculation. */
    PI_PLL.Uk = (int32_t) Motor.Speed ;
10001d5a:	604a      	str	r2, [r1, #4]
    /* Motor reference speed of FOC. */
    Motor.Ref_Speed = (int32_t) Motor.Speed;
10001d5c:	6062      	str	r2, [r4, #4]
    }
  }
  else
  {
    /* Next, directly to FOC closed-loop for faster startup. */
    Motor.State = (uint32_t) FOC_CLOSED_LOOP;
10001d5e:	62e3      	str	r3, [r4, #44]	; 0x2c
    /* Motor in transition mode. */
    Motor.Mode_Flag = MOTOR_TRANSITION;
10001d60:	8663      	strh	r3, [r4, #50]	; 0x32
    /* Clear counter. */
    Motor.Alignment_Counter = 0U;
10001d62:	6463      	str	r3, [r4, #68]	; 0x44
    /* Init FOC rotor speed ωr = PI_PLL.Uk, needed for ωL|I|, ωLId, ωLIq,
     *  * and FG frequency calculation. */
    PI_PLL.Uk = (int32_t) Motor.Speed ;
    /* Motor reference speed of FOC. */
    Motor.Ref_Speed = (int32_t) Motor.Speed;
    Ik_unsigned = (uint32_t) Car2Polar.SVM_Vref16 << PI_TORQUE_SCALE_KPKI;
10001d64:	8b28      	ldrh	r0, [r5, #24]
10001d66:	4a23      	ldr	r2, [pc, #140]	; (10001df4 <DirectFOCRotor_Pre_Positioning+0x110>)
10001d68:	1c01      	adds	r1, r0, #0
10001d6a:	6992      	ldr	r2, [r2, #24]
10001d6c:	4091      	lsls	r1, r2
10001d6e:	1c0a      	adds	r2, r1, #0
    PI_Torque.Ik = (int32_t) Ik_unsigned << 0;
10001d70:	4921      	ldr	r1, [pc, #132]	; (10001df8 <DirectFOCRotor_Pre_Positioning+0x114>)
10001d72:	608a      	str	r2, [r1, #8]
    /* Init Vd's Ik = 0 of flux / Id PI controller. */
    PI_Flux.Ik = 0;
10001d74:	4a21      	ldr	r2, [pc, #132]	; (10001dfc <DirectFOCRotor_Pre_Positioning+0x118>)
10001d76:	6093      	str	r3, [r2, #8]
10001d78:	e7da      	b.n	10001d30 <DirectFOCRotor_Pre_Positioning+0x4c>
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10001d7a:	4921      	ldr	r1, [pc, #132]	; (10001e00 <DirectFOCRotor_Pre_Positioning+0x11c>)
10001d7c:	8b09      	ldrh	r1, [r1, #24]
10001d7e:	2902      	cmp	r1, #2
10001d80:	d80f      	bhi.n	10001da2 <DirectFOCRotor_Pre_Positioning+0xbe>
10001d82:	2900      	cmp	r1, #0
10001d84:	d118      	bne.n	10001db8 <DirectFOCRotor_Pre_Positioning+0xd4>
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001d86:	4916      	ldr	r1, [pc, #88]	; (10001de0 <DirectFOCRotor_Pre_Positioning+0xfc>)
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10001d88:	18ea      	adds	r2, r5, r3
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001d8a:	1aeb      	subs	r3, r5, r3
10001d8c:	434b      	muls	r3, r1
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10001d8e:	4813      	ldr	r0, [pc, #76]	; (10001ddc <DirectFOCRotor_Pre_Positioning+0xf8>)
10001d90:	4252      	negs	r2, r2
10001d92:	0392      	lsls	r2, r2, #14
10001d94:	6002      	str	r2, [r0, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001d96:	6043      	str	r3, [r0, #4]
10001d98:	e7bf      	b.n	10001d1a <DirectFOCRotor_Pre_Positioning+0x36>
  {

    if (Car2Polar.SVM_Vref16 < PRE_POSIT_VOLT)
    {
      /* Vref increases gradually. */
      Car2Polar.SVM_Vref16 += VREF_INC_STEP;
10001d9a:	300a      	adds	r0, #10
10001d9c:	b280      	uxth	r0, r0
10001d9e:	8328      	strh	r0, [r5, #24]
10001da0:	e7c6      	b.n	10001d30 <DirectFOCRotor_Pre_Positioning+0x4c>
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10001da2:	2905      	cmp	r1, #5
10001da4:	d0ef      	beq.n	10001d86 <DirectFOCRotor_Pre_Positioning+0xa2>
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
10001da6:	490d      	ldr	r1, [pc, #52]	; (10001ddc <DirectFOCRotor_Pre_Positioning+0xf8>)
10001da8:	0393      	lsls	r3, r2, #14
10001daa:	600b      	str	r3, [r1, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
10001dac:	006b      	lsls	r3, r5, #1
10001dae:	18d2      	adds	r2, r2, r3
10001db0:	4b0b      	ldr	r3, [pc, #44]	; (10001de0 <DirectFOCRotor_Pre_Positioning+0xfc>)
10001db2:	435a      	muls	r2, r3
10001db4:	604a      	str	r2, [r1, #4]
10001db6:	e7b0      	b.n	10001d1a <DirectFOCRotor_Pre_Positioning+0x36>
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001db8:	005b      	lsls	r3, r3, #1
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10001dba:	0390      	lsls	r0, r2, #14
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001dbc:	18d2      	adds	r2, r2, r3
10001dbe:	4b11      	ldr	r3, [pc, #68]	; (10001e04 <DirectFOCRotor_Pre_Positioning+0x120>)
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10001dc0:	4906      	ldr	r1, [pc, #24]	; (10001ddc <DirectFOCRotor_Pre_Positioning+0xf8>)
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001dc2:	435a      	muls	r2, r3
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10001dc4:	6008      	str	r0, [r1, #0]
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001dc6:	604a      	str	r2, [r1, #4]
10001dc8:	e7a7      	b.n	10001d1a <DirectFOCRotor_Pre_Positioning+0x36>
10001dca:	46c0      	nop			; (mov r8, r8)
10001dcc:	20001050 	.word	0x20001050
10001dd0:	200010c4 	.word	0x200010c4
10001dd4:	20001018 	.word	0x20001018
10001dd8:	00001555 	.word	0x00001555
10001ddc:	200010bc 	.word	0x200010bc
10001de0:	000024f3 	.word	0x000024f3
10001de4:	20001244 	.word	0x20001244
10001de8:	000005db 	.word	0x000005db
10001dec:	2000109c 	.word	0x2000109c
10001df0:	20001120 	.word	0x20001120
10001df4:	200012a8 	.word	0x200012a8
10001df8:	20001170 	.word	0x20001170
10001dfc:	20001148 	.word	0x20001148
10001e00:	20001198 	.word	0x20001198
10001e04:	ffffdb0d 	.word	0xffffdb0d

10001e08 <Update_Vref_Angle>:
 * To update angle θ (16-bit) of SVM reference vector Vref
 * Digital implementation θ[k] = θ[k-1] + ω[k]
 */
void Update_Vref_Angle (int32_t Speed)
{
	Car2Polar.Vref_AngleQ31_Previous =  Car2Polar.Vref_AngleQ31;		// Record Vref angle θ of last PWM cycle.
10001e08:	4a07      	ldr	r2, [pc, #28]	; (10001e28 <Update_Vref_Angle+0x20>)

  if (Motor.Rotation_Dir == DIRECTION_INC)
10001e0a:	4908      	ldr	r1, [pc, #32]	; (10001e2c <Update_Vref_Angle+0x24>)
 * To update angle θ (16-bit) of SVM reference vector Vref
 * Digital implementation θ[k] = θ[k-1] + ω[k]
 */
void Update_Vref_Angle (int32_t Speed)
{
	Car2Polar.Vref_AngleQ31_Previous =  Car2Polar.Vref_AngleQ31;		// Record Vref angle θ of last PWM cycle.
10001e0c:	68d3      	ldr	r3, [r2, #12]

  if (Motor.Rotation_Dir == DIRECTION_INC)
  {
    /* If motor rotation direction - angle increasing. θ[k] = θ[k-1] + ω[k]. */
    Car2Polar.Vref_AngleQ31 += (Speed << (16U - RES_INC)); /* θ[k] = θ[k-1] + ω[k]. */
10001e0e:	0340      	lsls	r0, r0, #13
 * To update angle θ (16-bit) of SVM reference vector Vref
 * Digital implementation θ[k] = θ[k-1] + ω[k]
 */
void Update_Vref_Angle (int32_t Speed)
{
	Car2Polar.Vref_AngleQ31_Previous =  Car2Polar.Vref_AngleQ31;		// Record Vref angle θ of last PWM cycle.
10001e10:	6153      	str	r3, [r2, #20]

  if (Motor.Rotation_Dir == DIRECTION_INC)
10001e12:	8e09      	ldrh	r1, [r1, #48]	; 0x30
10001e14:	2900      	cmp	r1, #0
10001e16:	d004      	beq.n	10001e22 <Update_Vref_Angle+0x1a>
    /* If motor rotation direction - angle increasing. θ[k] = θ[k-1] + ω[k]. */
    Car2Polar.Vref_AngleQ31 += (Speed << (16U - RES_INC)); /* θ[k] = θ[k-1] + ω[k]. */
  }
  else
  {
		Car2Polar.Vref_AngleQ31 -= (Speed << (16U-RES_INC));		// θ[k] = θ[k-1] - ω[k].
10001e18:	1a18      	subs	r0, r3, r0
10001e1a:	60d0      	str	r0, [r2, #12]
	}

	Car2Polar.SVM_Angle16 = Car2Polar.Vref_AngleQ31 >> 16U;			// SVM Vref angle θ (16-bit).
10001e1c:	1400      	asrs	r0, r0, #16
10001e1e:	8350      	strh	r0, [r2, #26]
}	// End of Update_Vref_Angle ()
10001e20:	4770      	bx	lr
	Car2Polar.Vref_AngleQ31_Previous =  Car2Polar.Vref_AngleQ31;		// Record Vref angle θ of last PWM cycle.

  if (Motor.Rotation_Dir == DIRECTION_INC)
  {
    /* If motor rotation direction - angle increasing. θ[k] = θ[k-1] + ω[k]. */
    Car2Polar.Vref_AngleQ31 += (Speed << (16U - RES_INC)); /* θ[k] = θ[k-1] + ω[k]. */
10001e22:	1818      	adds	r0, r3, r0
10001e24:	e7f9      	b.n	10001e1a <Update_Vref_Angle+0x12>
10001e26:	46c0      	nop			; (mov r8, r8)
10001e28:	2000109c 	.word	0x2000109c
10001e2c:	20001244 	.word	0x20001244

10001e30 <FOC_SystemParameters_Init_OnceOnly>:

void FOC_SystemParameters_Init_OnceOnly (void)
{

  /* Init below once only before go to FOC: */
  FOCInput.Phase_L = L_OMEGALI;
10001e30:	221a      	movs	r2, #26
10001e32:	4b12      	ldr	r3, [pc, #72]	; (10001e7c <FOC_SystemParameters_Init_OnceOnly+0x4c>)
#endif

/* Init parameters of LIB. Init once only */

void FOC_SystemParameters_Init_OnceOnly (void)
{
10001e34:	b510      	push	{r4, lr}

  /* Init below once only before go to FOC: */
  FOCInput.Phase_L = L_OMEGALI;
10001e36:	601a      	str	r2, [r3, #0]
  FOCInput.Phase_L_Scale = SCALE_L;
10001e38:	3a08      	subs	r2, #8
10001e3a:	811a      	strh	r2, [r3, #8]

  FOCInput.Res_Inc = RES_INC; /* Resolution increase, use (16 + Res_Inc) bit to represent 360 deg. */
10001e3c:	3a0f      	subs	r2, #15
10001e3e:	819a      	strh	r2, [r3, #12]
  FOCInput.LPF_N_BEMF = SHIFT_MET_PLL;
10001e40:	3a01      	subs	r2, #1
10001e42:	821a      	strh	r2, [r3, #16]

  FOCInput.CCU8_Period = (uint32_t) PERIOD_REG;
10001e44:	4a0e      	ldr	r2, [pc, #56]	; (10001e80 <FOC_SystemParameters_Init_OnceOnly+0x50>)
  FOCInput.Ref_Id = 0;

  FOCInput.Vq = 0;
  FOCInput.Vq_Flag = 0; /* FOC Vq from Iq PI controller. */

  FOCInput.Iq_PI_Flag = 0; /* Reference of Iq PI controller from speed PI output. */
10001e46:	2154      	movs	r1, #84	; 0x54
  FOCInput.Phase_L_Scale = SCALE_L;

  FOCInput.Res_Inc = RES_INC; /* Resolution increase, use (16 + Res_Inc) bit to represent 360 deg. */
  FOCInput.LPF_N_BEMF = SHIFT_MET_PLL;

  FOCInput.CCU8_Period = (uint32_t) PERIOD_REG;
10001e48:	815a      	strh	r2, [r3, #10]

  FOCInput.Ref_Id = 0;
10001e4a:	2200      	movs	r2, #0

  FOCInput.Vq = 0;
  FOCInput.Vq_Flag = 0; /* FOC Vq from Iq PI controller. */

  FOCInput.Iq_PI_Flag = 0; /* Reference of Iq PI controller from speed PI output. */
10001e4c:	525a      	strh	r2, [r3, r1]
  FOCInput.SVM_5_Segment_Flag = 0; /* 7-segment SVM. For 3-shunt current sensing only. */

  FOCInput.Flag_State = 0;

    #if(OVERCURRENT_PROTECTION == ENABLED)
     FOCInput.overcurrent_factor = 4096;                /* */
10001e4e:	2180      	movs	r1, #128	; 0x80
10001e50:	0149      	lsls	r1, r1, #5
10001e52:	83d9      	strh	r1, [r3, #30]
    #endif
  PLL_Estimator.RotorSpeed_In = Motor.Speed;
10001e54:	490b      	ldr	r1, [pc, #44]	; (10001e84 <FOC_SystemParameters_Init_OnceOnly+0x54>)
10001e56:	480c      	ldr	r0, [pc, #48]	; (10001e88 <FOC_SystemParameters_Init_OnceOnly+0x58>)
10001e58:	6889      	ldr	r1, [r1, #8]
  FOCInput.Res_Inc = RES_INC; /* Resolution increase, use (16 + Res_Inc) bit to represent 360 deg. */
  FOCInput.LPF_N_BEMF = SHIFT_MET_PLL;

  FOCInput.CCU8_Period = (uint32_t) PERIOD_REG;

  FOCInput.Ref_Id = 0;
10001e5a:	64da      	str	r2, [r3, #76]	; 0x4c

    #if(OVERCURRENT_PROTECTION == ENABLED)
     FOCInput.overcurrent_factor = 4096;                /* */
    #endif
  PLL_Estimator.RotorSpeed_In = Motor.Speed;
  FOCInput.Ref_Speed = Motor.Speed; /* Motor reference speed. */
10001e5c:	6419      	str	r1, [r3, #64]	; 0x40

  FOCInput.CCU8_Period = (uint32_t) PERIOD_REG;

  FOCInput.Ref_Id = 0;

  FOCInput.Vq = 0;
10001e5e:	649a      	str	r2, [r3, #72]	; 0x48
  FOCInput.Vq_Flag = 0; /* FOC Vq from Iq PI controller. */
10001e60:	645a      	str	r2, [r3, #68]	; 0x44

  FOCInput.Iq_PI_Flag = 0; /* Reference of Iq PI controller from speed PI output. */

  FOCInput.RotorSpeed_In = 0;
10001e62:	65da      	str	r2, [r3, #92]	; 0x5c

  FOCInput.SVM_5_Segment_Flag = 0; /* 7-segment SVM. For 3-shunt current sensing only. */
10001e64:	851a      	strh	r2, [r3, #40]	; 0x28

  FOCInput.Flag_State = 0;
10001e66:	839a      	strh	r2, [r3, #28]
     FOCInput.overcurrent_factor = 4096;                /* */
    #endif
  PLL_Estimator.RotorSpeed_In = Motor.Speed;
  FOCInput.Ref_Speed = Motor.Speed; /* Motor reference speed. */

  PI_PLL.Ik = PLL_Estimator.RotorSpeed_In << PI_PLL.Scale_KpKi;
10001e68:	4b08      	ldr	r3, [pc, #32]	; (10001e8c <FOC_SystemParameters_Init_OnceOnly+0x5c>)
  FOCInput.Flag_State = 0;

    #if(OVERCURRENT_PROTECTION == ENABLED)
     FOCInput.overcurrent_factor = 4096;                /* */
    #endif
  PLL_Estimator.RotorSpeed_In = Motor.Speed;
10001e6a:	6101      	str	r1, [r0, #16]
  FOCInput.Ref_Speed = Motor.Speed; /* Motor reference speed. */

  PI_PLL.Ik = PLL_Estimator.RotorSpeed_In << PI_PLL.Scale_KpKi;
10001e6c:	2410      	movs	r4, #16
10001e6e:	5f18      	ldrsh	r0, [r3, r4]
10001e70:	4081      	lsls	r1, r0
10001e72:	6099      	str	r1, [r3, #8]

  FOCOutput.New_SVM_SectorNo = SVM.CurrentSectorNo;

  FOCOutput.Previous_SVM_SectorNo = 0;
10001e74:	4b06      	ldr	r3, [pc, #24]	; (10001e90 <FOC_SystemParameters_Init_OnceOnly+0x60>)
10001e76:	831a      	strh	r2, [r3, #24]
  FOCOutput.New_SVM_SectorNo = 0; /* Use default SVM sector. */
10001e78:	835a      	strh	r2, [r3, #26]

} /* End of FOC_SystemParameters_Init_OnceOnly () */
10001e7a:	bd10      	pop	{r4, pc}
10001e7c:	200011c8 	.word	0x200011c8
10001e80:	000010aa 	.word	0x000010aa
10001e84:	20001244 	.word	0x20001244
10001e88:	20001354 	.word	0x20001354
10001e8c:	20001120 	.word	0x20001120
10001e90:	20001198 	.word	0x20001198

10001e94 <Init_Smooth_Transition_To_FOC>:

/** To calculate |Vref|sin(γ-θ), wL|I|, and ε=|Vref|sin(γ-θ)+wL|I|, for MET (Maximum Efficiency Tracking) .
** Execution time: 5.9us - 6.3us (O3 - Optimize most).
* ----------------------------------------------------------------------------------------------------------*/
void Init_Smooth_Transition_To_FOC (uint32_t Omega_Speed)
{
10001e94:	b570      	push	{r4, r5, r6, lr}
    #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
    // Get_ADC_SingleShuntCurrent(&ADC);
    Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Current);

    #else
    Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
10001e96:	4c3b      	ldr	r4, [pc, #236]	; (10001f84 <Init_Smooth_Transition_To_FOC+0xf0>)
10001e98:	4d3b      	ldr	r5, [pc, #236]	; (10001f88 <Init_Smooth_Transition_To_FOC+0xf4>)
10001e9a:	1c22      	adds	r2, r4, #0

/** To calculate |Vref|sin(γ-θ), wL|I|, and ε=|Vref|sin(γ-θ)+wL|I|, for MET (Maximum Efficiency Tracking) .
** Execution time: 5.9us - 6.3us (O3 - Optimize most).
* ----------------------------------------------------------------------------------------------------------*/
void Init_Smooth_Transition_To_FOC (uint32_t Omega_Speed)
{
10001e9c:	b082      	sub	sp, #8
    #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
    // Get_ADC_SingleShuntCurrent(&ADC);
    Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Current);

    #else
    Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
10001e9e:	8868      	ldrh	r0, [r5, #2]
10001ea0:	8829      	ldrh	r1, [r5, #0]
10001ea2:	f000 ff91 	bl	10002dc8 <__Get_ADCPhaseCurrent_veneer>

    Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
10001ea6:	8820      	ldrh	r0, [r4, #0]
10001ea8:	8861      	ldrh	r1, [r4, #2]
10001eaa:	88a2      	ldrh	r2, [r4, #4]
10001eac:	4c37      	ldr	r4, [pc, #220]	; (10001f8c <Init_Smooth_Transition_To_FOC+0xf8>)
10001eae:	1c23      	adds	r3, r4, #0
10001eb0:	f000 ff7a 	bl	10002da8 <__Current_Reconstruction_veneer>
    #endif

    ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
10001eb4:	cc0d      	ldmia	r4!, {r0, r2, r3}
  HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
  HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));

#else

  if(SVM.Flag_3or2_ADC == 0){
10001eb6:	88a9      	ldrh	r1, [r5, #4]
10001eb8:	2900      	cmp	r1, #0
10001eba:	d144      	bne.n	10001f46 <Init_Smooth_Transition_To_FOC+0xb2>
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
10001ebc:	18d1      	adds	r1, r2, r3
10001ebe:	0040      	lsls	r0, r0, #1
10001ec0:	1a40      	subs	r0, r0, r1
10001ec2:	4933      	ldr	r1, [pc, #204]	; (10001f90 <Init_Smooth_Transition_To_FOC+0xfc>)
10001ec4:	4341      	muls	r1, r0
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001ec6:	1ad2      	subs	r2, r2, r3
10001ec8:	4b32      	ldr	r3, [pc, #200]	; (10001f94 <Init_Smooth_Transition_To_FOC+0x100>)
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10001eca:	4c33      	ldr	r4, [pc, #204]	; (10001f98 <Init_Smooth_Transition_To_FOC+0x104>)
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001ecc:	435a      	muls	r2, r3
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10001ece:	6021      	str	r1, [r4, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001ed0:	6062      	str	r2, [r4, #4]

    PLL_Imag(Car2Polar.Vref_AngleQ31,Clarke_Transform.I_Alpha_1Q31,Clarke_Transform.I_Beta_1Q31);
10001ed2:	4e32      	ldr	r6, [pc, #200]	; (10001f9c <Init_Smooth_Transition_To_FOC+0x108>)
10001ed4:	68f0      	ldr	r0, [r6, #12]
10001ed6:	f000 ff87 	bl	10002de8 <__PLL_Imag_veneer>

    /* Wait if CORDIC is still running calculation. Omit if CCU4 outputs debug information.*/
    while (CORDIC_IS_BSY)
10001eda:	2201      	movs	r2, #1
10001edc:	4930      	ldr	r1, [pc, #192]	; (10001fa0 <Init_Smooth_Transition_To_FOC+0x10c>)
10001ede:	6c0b      	ldr	r3, [r1, #64]	; 0x40
10001ee0:	421a      	tst	r2, r3
10001ee2:	d1fc      	bne.n	10001ede <Init_Smooth_Transition_To_FOC+0x4a>
    {
      continue;
    }
    PLL_Imag_GetResult(&PLL_Estimator);
10001ee4:	4c2f      	ldr	r4, [pc, #188]	; (10001fa4 <Init_Smooth_Transition_To_FOC+0x110>)
10001ee6:	1c20      	adds	r0, r4, #0
10001ee8:	f000 ff76 	bl	10002dd8 <__PLL_Imag_GetResult_veneer>

    PLL_Vref(PLL_Estimator.Delta_IV, Car2Polar.Vref32,PI_PLL.Uk, FOCInput.Phase_L,&PLL_Estimator);
10001eec:	4b2e      	ldr	r3, [pc, #184]	; (10001fa8 <Init_Smooth_Transition_To_FOC+0x114>)
10001eee:	4d2f      	ldr	r5, [pc, #188]	; (10001fac <Init_Smooth_Transition_To_FOC+0x118>)
10001ef0:	685a      	ldr	r2, [r3, #4]
10001ef2:	9400      	str	r4, [sp, #0]
10001ef4:	68b1      	ldr	r1, [r6, #8]
10001ef6:	682b      	ldr	r3, [r5, #0]
10001ef8:	6860      	ldr	r0, [r4, #4]
10001efa:	f000 ff7d 	bl	10002df8 <__PLL_Vref_veneer>

    /* CPU computes the following simultaneously when CORDIC #7 */
    /* γ, used for smooth MET->FOC transition and motor startup lock / fail / stall detection.*/
    I_AngleQ31 = PLL_Estimator.Delta_IV + Car2Polar.Vref_AngleQ31;
10001efe:	6862      	ldr	r2, [r4, #4]
10001f00:	68f3      	ldr	r3, [r6, #12]
10001f02:	4694      	mov	ip, r2
10001f04:	4a2a      	ldr	r2, [pc, #168]	; (10001fb0 <Init_Smooth_Transition_To_FOC+0x11c>)
10001f06:	4463      	add	r3, ip
10001f08:	6013      	str	r3, [r2, #0]

    /* Results of CORDIC #7 - Vrefxsin(Î³-Î¸) and Vrefxcos(γ-θ) */
    /* Wait if CORDIC is still running calculation.*/
    while (CORDIC_IS_BSY)
10001f0a:	2201      	movs	r2, #1
10001f0c:	4924      	ldr	r1, [pc, #144]	; (10001fa0 <Init_Smooth_Transition_To_FOC+0x10c>)
10001f0e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
10001f10:	421a      	tst	r2, r3
10001f12:	d1fc      	bne.n	10001f0e <Init_Smooth_Transition_To_FOC+0x7a>
    {
      continue;
    }
    PLL_Vref_GetResult(&PLL_Estimator);
10001f14:	1c20      	adds	r0, r4, #0
10001f16:	f000 ff3f 	bl	10002d98 <__PLL_Vref_GetResult_veneer>

    /* Shift to get real result (16-bit).*/
    PLL_Estimator.VrefxSinDelta >>= CORDIC_SHIFT;
10001f1a:	68a3      	ldr	r3, [r4, #8]

    PLL_Estimator.VrefxSinDelta = (PLL_Estimator.VrefxSinDelta * 311) >> 8;

    /* Unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>>FOCInput.LPF_N_BEMF */
    /* |Vref|sin(γ-θ) with LPF.*/
    FOCInput.BEMF1 = (FOCInput.BEMF1 * ((1 << FOCInput.LPF_N_BEMF) - 1) + PLL_Estimator.VrefxSinDelta)
10001f1c:	2201      	movs	r2, #1
      continue;
    }
    PLL_Vref_GetResult(&PLL_Estimator);

    /* Shift to get real result (16-bit).*/
    PLL_Estimator.VrefxSinDelta >>= CORDIC_SHIFT;
10001f1e:	1399      	asrs	r1, r3, #14

    PLL_Estimator.VrefxSinDelta = (PLL_Estimator.VrefxSinDelta * 311) >> 8;
10001f20:	2338      	movs	r3, #56	; 0x38
10001f22:	33ff      	adds	r3, #255	; 0xff
10001f24:	434b      	muls	r3, r1
10001f26:	1219      	asrs	r1, r3, #8
10001f28:	60a1      	str	r1, [r4, #8]

    /* Unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>>FOCInput.LPF_N_BEMF */
    /* |Vref|sin(γ-θ) with LPF.*/
    FOCInput.BEMF1 = (FOCInput.BEMF1 * ((1 << FOCInput.LPF_N_BEMF) - 1) + PLL_Estimator.VrefxSinDelta)
10001f2a:	8a28      	ldrh	r0, [r5, #16]
10001f2c:	4082      	lsls	r2, r0
10001f2e:	1e53      	subs	r3, r2, #1
10001f30:	6a2a      	ldr	r2, [r5, #32]
10001f32:	435a      	muls	r2, r3
10001f34:	188b      	adds	r3, r1, r2
    >> FOCInput.LPF_N_BEMF;
10001f36:	4103      	asrs	r3, r0

    /* Îµ = |Vref|sin(γ-θ) + wL|I|. Motor rotates in one direction only. Rotor angle always increasing.*/
    Epsilon = FOCInput.BEMF1 +  FOCInput.BEMF2;
10001f38:	6a6a      	ldr	r2, [r5, #36]	; 0x24

    PLL_Estimator.VrefxSinDelta = (PLL_Estimator.VrefxSinDelta * 311) >> 8;

    /* Unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>>FOCInput.LPF_N_BEMF */
    /* |Vref|sin(γ-θ) with LPF.*/
    FOCInput.BEMF1 = (FOCInput.BEMF1 * ((1 << FOCInput.LPF_N_BEMF) - 1) + PLL_Estimator.VrefxSinDelta)
10001f3a:	622b      	str	r3, [r5, #32]
    >> FOCInput.LPF_N_BEMF;

    /* Îµ = |Vref|sin(γ-θ) + wL|I|. Motor rotates in one direction only. Rotor angle always increasing.*/
    Epsilon = FOCInput.BEMF1 +  FOCInput.BEMF2;
10001f3c:	189b      	adds	r3, r3, r2
10001f3e:	4a1d      	ldr	r2, [pc, #116]	; (10001fb4 <Init_Smooth_Transition_To_FOC+0x120>)
10001f40:	6013      	str	r3, [r2, #0]

}
10001f42:	b002      	add	sp, #8
10001f44:	bd70      	pop	{r4, r5, r6, pc}
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10001f46:	491c      	ldr	r1, [pc, #112]	; (10001fb8 <Init_Smooth_Transition_To_FOC+0x124>)
10001f48:	8b09      	ldrh	r1, [r1, #24]
10001f4a:	2902      	cmp	r1, #2
10001f4c:	d805      	bhi.n	10001f5a <Init_Smooth_Transition_To_FOC+0xc6>
10001f4e:	2900      	cmp	r1, #0
10001f50:	d10e      	bne.n	10001f70 <Init_Smooth_Transition_To_FOC+0xdc>
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10001f52:	18d1      	adds	r1, r2, r3
10001f54:	4249      	negs	r1, r1
10001f56:	0389      	lsls	r1, r1, #14
10001f58:	e7b5      	b.n	10001ec6 <Init_Smooth_Transition_To_FOC+0x32>
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10001f5a:	2905      	cmp	r1, #5
10001f5c:	d0f9      	beq.n	10001f52 <Init_Smooth_Transition_To_FOC+0xbe>
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
10001f5e:	0052      	lsls	r2, r2, #1
10001f60:	4b0c      	ldr	r3, [pc, #48]	; (10001f94 <Init_Smooth_Transition_To_FOC+0x100>)
10001f62:	1882      	adds	r2, r0, r2
10001f64:	435a      	muls	r2, r3
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
10001f66:	4c0c      	ldr	r4, [pc, #48]	; (10001f98 <Init_Smooth_Transition_To_FOC+0x104>)
10001f68:	0381      	lsls	r1, r0, #14
10001f6a:	6021      	str	r1, [r4, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
10001f6c:	6062      	str	r2, [r4, #4]
10001f6e:	e7b0      	b.n	10001ed2 <Init_Smooth_Transition_To_FOC+0x3e>
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001f70:	005a      	lsls	r2, r3, #1
10001f72:	4b12      	ldr	r3, [pc, #72]	; (10001fbc <Init_Smooth_Transition_To_FOC+0x128>)
10001f74:	1882      	adds	r2, r0, r2
10001f76:	435a      	muls	r2, r3
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10001f78:	4c07      	ldr	r4, [pc, #28]	; (10001f98 <Init_Smooth_Transition_To_FOC+0x104>)
10001f7a:	0381      	lsls	r1, r0, #14
10001f7c:	6021      	str	r1, [r4, #0]
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10001f7e:	6062      	str	r2, [r4, #4]
10001f80:	e7a7      	b.n	10001ed2 <Init_Smooth_Transition_To_FOC+0x3e>
10001f82:	46c0      	nop			; (mov r8, r8)
10001f84:	20001050 	.word	0x20001050
10001f88:	20001018 	.word	0x20001018
10001f8c:	200010c4 	.word	0x200010c4
10001f90:	00001555 	.word	0x00001555
10001f94:	000024f3 	.word	0x000024f3
10001f98:	200010bc 	.word	0x200010bc
10001f9c:	2000109c 	.word	0x2000109c
10001fa0:	40030000 	.word	0x40030000
10001fa4:	20001354 	.word	0x20001354
10001fa8:	20001120 	.word	0x20001120
10001fac:	200011c8 	.word	0x200011c8
10001fb0:	20001024 	.word	0x20001024
10001fb4:	200010f4 	.word	0x200010f4
10001fb8:	20001198 	.word	0x20001198
10001fbc:	ffffdb0d 	.word	0xffffdb0d

10001fc0 <Stop_Motor>:

/** Stop the motor, check PWM or POT ADC (for adjusting motor speed)
 ** Execution time: ?us (O3 - Optimize most).
	* ---------------------------------------------------------------------*/
void Stop_Motor (void)
{
10001fc0:	b570      	push	{r4, r5, r6, lr}

    #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
      Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Current);
    #else
      /* 2or3-shunt 3-phase current reconstruction, to get Iu and Iv */
      Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
10001fc2:	4c4d      	ldr	r4, [pc, #308]	; (100020f8 <Stop_Motor+0x138>)
10001fc4:	4d4d      	ldr	r5, [pc, #308]	; (100020fc <Stop_Motor+0x13c>)
10001fc6:	1c23      	adds	r3, r4, #0
10001fc8:	8869      	ldrh	r1, [r5, #2]
10001fca:	88aa      	ldrh	r2, [r5, #4]
10001fcc:	8828      	ldrh	r0, [r5, #0]
10001fce:	f000 feeb 	bl	10002da8 <__Current_Reconstruction_veneer>
  HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
  HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));

#else

  if(SVM.Flag_3or2_ADC == 0){
10001fd2:	494b      	ldr	r1, [pc, #300]	; (10002100 <Stop_Motor+0x140>)
    #endif
      ClarkeTransform(Current.I_U, Current.I_V,Current.I_W, &Clarke_Transform);
10001fd4:	6822      	ldr	r2, [r4, #0]
10001fd6:	8889      	ldrh	r1, [r1, #4]
10001fd8:	6866      	ldr	r6, [r4, #4]
10001fda:	68a3      	ldr	r3, [r4, #8]
10001fdc:	2900      	cmp	r1, #0
10001fde:	d131      	bne.n	10002044 <Stop_Motor+0x84>
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
10001fe0:	18f1      	adds	r1, r6, r3
10001fe2:	0052      	lsls	r2, r2, #1
10001fe4:	1a50      	subs	r0, r2, r1
10001fe6:	4947      	ldr	r1, [pc, #284]	; (10002104 <Stop_Motor+0x144>)
10001fe8:	4c47      	ldr	r4, [pc, #284]	; (10002108 <Stop_Motor+0x148>)
10001fea:	4341      	muls	r1, r0
10001fec:	6021      	str	r1, [r4, #0]

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10001fee:	4947      	ldr	r1, [pc, #284]	; (1000210c <Stop_Motor+0x14c>)
10001ff0:	1af3      	subs	r3, r6, r3
10001ff2:	434b      	muls	r3, r1
10001ff4:	6063      	str	r3, [r4, #4]
      local_counter ++;
10001ff6:	4a46      	ldr	r2, [pc, #280]	; (10002110 <Stop_Motor+0x150>)
#if(uCPROBE_GUI == ENABLED)
    if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
10001ff8:	4946      	ldr	r1, [pc, #280]	; (10002114 <Stop_Motor+0x154>)
    #else
      /* 2or3-shunt 3-phase current reconstruction, to get Iu and Iv */
      Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
    #endif
      ClarkeTransform(Current.I_U, Current.I_V,Current.I_W, &Clarke_Transform);
      local_counter ++;
10001ffa:	6813      	ldr	r3, [r2, #0]
#if(uCPROBE_GUI == ENABLED)
    if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
10001ffc:	6808      	ldr	r0, [r1, #0]
10001ffe:	4946      	ldr	r1, [pc, #280]	; (10002118 <Stop_Motor+0x158>)
    #else
      /* 2or3-shunt 3-phase current reconstruction, to get Iu and Iv */
      Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
    #endif
      ClarkeTransform(Current.I_U, Current.I_V,Current.I_W, &Clarke_Transform);
      local_counter ++;
10002000:	3301      	adds	r3, #1
10002002:	6013      	str	r3, [r2, #0]
#if(uCPROBE_GUI == ENABLED)
    if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
10002004:	4288      	cmp	r0, r1
10002006:	d044      	beq.n	10002092 <Stop_Motor+0xd2>

      NVIC_SystemReset();
    }
#endif

    if (SYSTEM_BE_IDLE)
10002008:	6a29      	ldr	r1, [r5, #32]
1000200a:	2931      	cmp	r1, #49	; 0x31
1000200c:	dc0c      	bgt.n	10002028 <Stop_Motor+0x68>
    {
      /* If system is idle, i.e.: PWM duty cycle or POT ADC too low.*/
      /* Reset counter, local_counter < TIME_OF_STOP to prevent it from re-start of motor.*/
      local_counter = 0;
1000200e:	2100      	movs	r1, #0
10002010:	1c08      	adds	r0, r1, #0
      Motor.Speed = 0;
10002012:	4b42      	ldr	r3, [pc, #264]	; (1000211c <Stop_Motor+0x15c>)

    if (SYSTEM_BE_IDLE)
    {
      /* If system is idle, i.e.: PWM duty cycle or POT ADC too low.*/
      /* Reset counter, local_counter < TIME_OF_STOP to prevent it from re-start of motor.*/
      local_counter = 0;
10002014:	6011      	str	r1, [r2, #0]
      Motor.Speed = 0;
10002016:	6099      	str	r1, [r3, #8]
      }
    }
    else
    {
      /* To update angle θ (16-bit) of SVM reference vector Vref */
      Update_Vref_Angle (Motor.Speed);
10002018:	f7ff fef6 	bl	10001e08 <Update_Vref_Angle>
      /* Update SVM PWM, brake motor.*/
      PWMSVM01_Update(0, Car2Polar.SVM_Angle16);
1000201c:	4b40      	ldr	r3, [pc, #256]	; (10002120 <Stop_Motor+0x160>)
1000201e:	2000      	movs	r0, #0
10002020:	8b59      	ldrh	r1, [r3, #26]
10002022:	f000 fec9 	bl	10002db8 <__PWMSVM01_Update_veneer>
    }

}
10002026:	bd70      	pop	{r4, r5, r6, pc}
      local_counter = 0;
      Motor.Speed = 0;
    }


    if (local_counter > TIME_OF_STOP)
10002028:	2bc8      	cmp	r3, #200	; 0xc8
1000202a:	d926      	bls.n	1000207a <Stop_Motor+0xba>
    {
      local_counter = 0;
1000202c:	2300      	movs	r3, #0
1000202e:	6013      	str	r3, [r2, #0]
      /* Init ADC, for current sensing, ADC of DC link Vdc (and POT). Do at later stage of the init */
      ADC_Init();
      ADC_DCLink_Init();
      ADC_Pot_Init();
      #endif
      CCU8_Init();
10002030:	f7ff fad4 	bl	100015dc <CCU8_Init>
      Variables_Init ();
10002034:	f000 f93c 	bl	100022b0 <Variables_Init>
      CCUx_SynStart();
10002038:	f7ff fbe2 	bl	10001800 <CCUx_SynStart>

      /* Direct FOC startup. Motor startup to FOC closed-loop directly, no V/f or MET*/
      #if(MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_DIRECT_FOC || MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC || MY_FOC_CONTROL_SCHEME == CONSTANT_VQ_DIRECT_FOC)
      /* Next, go to rotor initial preposition/alignment.*/
      Motor.State = PRE_POSITIONING;
1000203c:	2206      	movs	r2, #6
1000203e:	4b37      	ldr	r3, [pc, #220]	; (1000211c <Stop_Motor+0x15c>)
10002040:	62da      	str	r2, [r3, #44]	; 0x2c
10002042:	e7f0      	b.n	10002026 <Stop_Motor+0x66>
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10002044:	4937      	ldr	r1, [pc, #220]	; (10002124 <Stop_Motor+0x164>)
10002046:	8b09      	ldrh	r1, [r1, #24]
10002048:	2902      	cmp	r1, #2
1000204a:	d80b      	bhi.n	10002064 <Stop_Motor+0xa4>
1000204c:	2900      	cmp	r1, #0
1000204e:	d117      	bne.n	10002080 <Stop_Motor+0xc0>
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10002050:	492e      	ldr	r1, [pc, #184]	; (1000210c <Stop_Motor+0x14c>)
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10002052:	18f2      	adds	r2, r6, r3
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10002054:	1af3      	subs	r3, r6, r3
10002056:	434b      	muls	r3, r1
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
10002058:	482b      	ldr	r0, [pc, #172]	; (10002108 <Stop_Motor+0x148>)
1000205a:	4252      	negs	r2, r2
1000205c:	0392      	lsls	r2, r2, #14
1000205e:	6002      	str	r2, [r0, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
10002060:	6043      	str	r3, [r0, #4]
10002062:	e7c8      	b.n	10001ff6 <Stop_Motor+0x36>
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
10002064:	2905      	cmp	r1, #5
10002066:	d0f3      	beq.n	10002050 <Stop_Motor+0x90>
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
10002068:	4927      	ldr	r1, [pc, #156]	; (10002108 <Stop_Motor+0x148>)
1000206a:	0393      	lsls	r3, r2, #14
1000206c:	600b      	str	r3, [r1, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
1000206e:	0073      	lsls	r3, r6, #1
10002070:	18d2      	adds	r2, r2, r3
10002072:	4b26      	ldr	r3, [pc, #152]	; (1000210c <Stop_Motor+0x14c>)
10002074:	435a      	muls	r2, r3
10002076:	604a      	str	r2, [r1, #4]
10002078:	e7bd      	b.n	10001ff6 <Stop_Motor+0x36>
1000207a:	4b28      	ldr	r3, [pc, #160]	; (1000211c <Stop_Motor+0x15c>)
1000207c:	6898      	ldr	r0, [r3, #8]
1000207e:	e7cb      	b.n	10002018 <Stop_Motor+0x58>
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10002080:	005b      	lsls	r3, r3, #1
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10002082:	0390      	lsls	r0, r2, #14
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
10002084:	18d2      	adds	r2, r2, r3
10002086:	4b28      	ldr	r3, [pc, #160]	; (10002128 <Stop_Motor+0x168>)
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
10002088:	491f      	ldr	r1, [pc, #124]	; (10002108 <Stop_Motor+0x148>)
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
1000208a:	435a      	muls	r2, r3
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
1000208c:	6008      	str	r0, [r1, #0]
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
1000208e:	604a      	str	r2, [r1, #4]
10002090:	e7b1      	b.n	10001ff6 <Stop_Motor+0x36>

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
10002092:	2180      	movs	r1, #128	; 0x80
10002094:	2380      	movs	r3, #128	; 0x80
10002096:	4a25      	ldr	r2, [pc, #148]	; (1000212c <Stop_Motor+0x16c>)
10002098:	0489      	lsls	r1, r1, #18
1000209a:	50d1      	str	r1, [r2, r3]
    if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
    {
      /* Disable CCU8 interrupt to enable update of user parameter */
      NVIC_DisableIRQ(CCU80_0_IRQn);

      User_Para[1] = PI_Speed.Kp;
1000209c:	4b24      	ldr	r3, [pc, #144]	; (10002130 <Stop_Motor+0x170>)
1000209e:	4925      	ldr	r1, [pc, #148]	; (10002134 <Stop_Motor+0x174>)
100020a0:	899a      	ldrh	r2, [r3, #12]
      User_Para[11] = PI_PLL.Ki;
      User_Para[12] = PI_PLL.Scale_KpKi;

      uint32_t *MotorCONF_Address = MotorConfig_Addr;
      uint32_t *UserConfig_Address = &User_Para[0];
      XMC_FLASH_ProgramVerifyPage(MotorCONF_Address,UserConfig_Address);
100020a2:	4825      	ldr	r0, [pc, #148]	; (10002138 <Stop_Motor+0x178>)
    if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
    {
      /* Disable CCU8 interrupt to enable update of user parameter */
      NVIC_DisableIRQ(CCU80_0_IRQn);

      User_Para[1] = PI_Speed.Kp;
100020a4:	604a      	str	r2, [r1, #4]
      User_Para[2] = PI_Speed.Ki;
100020a6:	89da      	ldrh	r2, [r3, #14]
100020a8:	608a      	str	r2, [r1, #8]
      User_Para[3] = PI_Speed.Scale_KpKi;
100020aa:	2210      	movs	r2, #16
100020ac:	5e9b      	ldrsh	r3, [r3, r2]
100020ae:	60cb      	str	r3, [r1, #12]

      User_Para[4] = PI_Torque.Kp;
100020b0:	4b22      	ldr	r3, [pc, #136]	; (1000213c <Stop_Motor+0x17c>)
100020b2:	899a      	ldrh	r2, [r3, #12]
100020b4:	610a      	str	r2, [r1, #16]
      User_Para[5] = PI_Torque.Ki;
100020b6:	89da      	ldrh	r2, [r3, #14]
100020b8:	614a      	str	r2, [r1, #20]
      User_Para[6] = PI_Torque.Scale_KpKi;
100020ba:	2210      	movs	r2, #16
100020bc:	5e9b      	ldrsh	r3, [r3, r2]
100020be:	618b      	str	r3, [r1, #24]

      User_Para[7] = PI_Flux.Kp;
100020c0:	4b1f      	ldr	r3, [pc, #124]	; (10002140 <Stop_Motor+0x180>)
100020c2:	899a      	ldrh	r2, [r3, #12]
100020c4:	61ca      	str	r2, [r1, #28]
      User_Para[8] = PI_Flux.Ki;
100020c6:	89da      	ldrh	r2, [r3, #14]
100020c8:	620a      	str	r2, [r1, #32]
      User_Para[9] = PI_Flux.Scale_KpKi;
100020ca:	2210      	movs	r2, #16
100020cc:	5e9b      	ldrsh	r3, [r3, r2]
100020ce:	624b      	str	r3, [r1, #36]	; 0x24

      User_Para[10] = PI_PLL.Kp;
100020d0:	4b1c      	ldr	r3, [pc, #112]	; (10002144 <Stop_Motor+0x184>)
100020d2:	899a      	ldrh	r2, [r3, #12]
100020d4:	628a      	str	r2, [r1, #40]	; 0x28
      User_Para[11] = PI_PLL.Ki;
100020d6:	89da      	ldrh	r2, [r3, #14]
100020d8:	62ca      	str	r2, [r1, #44]	; 0x2c
      User_Para[12] = PI_PLL.Scale_KpKi;
100020da:	2210      	movs	r2, #16
100020dc:	5e9b      	ldrsh	r3, [r3, r2]
100020de:	630b      	str	r3, [r1, #48]	; 0x30

      uint32_t *MotorCONF_Address = MotorConfig_Addr;
      uint32_t *UserConfig_Address = &User_Para[0];
      XMC_FLASH_ProgramVerifyPage(MotorCONF_Address,UserConfig_Address);
100020e0:	f000 f928 	bl	10002334 <XMC_FLASH_ProgramVerifyPage>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
100020e4:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
100020e8:	4a17      	ldr	r2, [pc, #92]	; (10002148 <Stop_Motor+0x188>)
100020ea:	4b18      	ldr	r3, [pc, #96]	; (1000214c <Stop_Motor+0x18c>)
100020ec:	60da      	str	r2, [r3, #12]
100020ee:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
100020f2:	46c0      	nop			; (mov r8, r8)
100020f4:	e7fd      	b.n	100020f2 <Stop_Motor+0x132>
100020f6:	46c0      	nop			; (mov r8, r8)
100020f8:	200010c4 	.word	0x200010c4
100020fc:	20001050 	.word	0x20001050
10002100:	20001018 	.word	0x20001018
10002104:	00001555 	.word	0x00001555
10002108:	200010bc 	.word	0x200010bc
1000210c:	000024f3 	.word	0x000024f3
10002110:	20001004 	.word	0x20001004
10002114:	20001348 	.word	0x20001348
10002118:	000004d2 	.word	0x000004d2
1000211c:	20001244 	.word	0x20001244
10002120:	2000109c 	.word	0x2000109c
10002124:	20001198 	.word	0x20001198
10002128:	ffffdb0d 	.word	0xffffdb0d
1000212c:	e000e100 	.word	0xe000e100
10002130:	200010f8 	.word	0x200010f8
10002134:	200012a8 	.word	0x200012a8
10002138:	10006800 	.word	0x10006800
1000213c:	20001170 	.word	0x20001170
10002140:	20001148 	.word	0x20001148
10002144:	20001120 	.word	0x20001120
10002148:	05fa0004 	.word	0x05fa0004
1000214c:	e000ed00 	.word	0xe000ed00

10002150 <PI_controller_Init>:

/* API to initialize PI Controller parameters */
void PI_controller_Init(void)
{
  /*################### For Speed PI controller ######################*/
	PI_Speed.Kp = (uint16_t)PI_SPEED_KP;
10002150:	4b2a      	ldr	r3, [pc, #168]	; (100021fc <PI_controller_Init+0xac>)
10002152:	4a2b      	ldr	r2, [pc, #172]	; (10002200 <PI_controller_Init+0xb0>)
10002154:	8899      	ldrh	r1, [r3, #4]
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to initialize PI Controller parameters */
void PI_controller_Init(void)
{
10002156:	b570      	push	{r4, r5, r6, lr}
  /*################### For Speed PI controller ######################*/
	PI_Speed.Kp = (uint16_t)PI_SPEED_KP;
10002158:	8191      	strh	r1, [r2, #12]
	PI_Speed.Ki = PI_SPEED_KI;
1000215a:	8919      	ldrh	r1, [r3, #8]
	PI_Speed.Scale_KpKi = PI_SPEED_SCALE_KPKI;

	PI_Speed.Ik_limit_min = PI_SPEED_IK_LIMIT_MIN;
	PI_Speed.Ik_limit_max = PI_SPEED_IK_LIMIT_MAX;
	PI_Speed.Ik_limit_min <<= PI_Speed.Scale_KpKi;		/* Ik (32-bit) limits shift, due to PI Controller design. */
1000215c:	4829      	ldr	r0, [pc, #164]	; (10002204 <PI_controller_Init+0xb4>)
/* API to initialize PI Controller parameters */
void PI_controller_Init(void)
{
  /*################### For Speed PI controller ######################*/
	PI_Speed.Kp = (uint16_t)PI_SPEED_KP;
	PI_Speed.Ki = PI_SPEED_KI;
1000215e:	81d1      	strh	r1, [r2, #14]
	PI_Speed.Scale_KpKi = PI_SPEED_SCALE_KPKI;
10002160:	8999      	ldrh	r1, [r3, #12]
	PI_Torque.Ki = PI_TORQUE_KI;
	PI_Torque.Scale_KpKi = PI_TORQUE_SCALE_KPKI;

	PI_Torque.Ik_limit_min = PI_TORQUE_IK_LIMIT_MIN;
	PI_Torque.Ik_limit_max = PI_TORQUE_IK_LIMIT_MAX;
	PI_Torque.Ik_limit_min <<= PI_Torque.Scale_KpKi;	/* Ik limits shift. */
10002162:	4d29      	ldr	r5, [pc, #164]	; (10002208 <PI_controller_Init+0xb8>)
void PI_controller_Init(void)
{
  /*################### For Speed PI controller ######################*/
	PI_Speed.Kp = (uint16_t)PI_SPEED_KP;
	PI_Speed.Ki = PI_SPEED_KI;
	PI_Speed.Scale_KpKi = PI_SPEED_SCALE_KPKI;
10002164:	8211      	strh	r1, [r2, #16]

	PI_Speed.Ik_limit_min = PI_SPEED_IK_LIMIT_MIN;
	PI_Speed.Ik_limit_max = PI_SPEED_IK_LIMIT_MAX;
	PI_Speed.Ik_limit_min <<= PI_Speed.Scale_KpKi;		/* Ik (32-bit) limits shift, due to PI Controller design. */
10002166:	b209      	sxth	r1, r1
10002168:	4088      	lsls	r0, r1
1000216a:	6150      	str	r0, [r2, #20]
	PI_Speed.Ik_limit_max <<= PI_Speed.Scale_KpKi;
1000216c:	2080      	movs	r0, #128	; 0x80
1000216e:	01c0      	lsls	r0, r0, #7
10002170:	4088      	lsls	r0, r1
  PI_Speed.Uk_limit_status = 0;
10002172:	2124      	movs	r1, #36	; 0x24
	PI_Speed.Scale_KpKi = PI_SPEED_SCALE_KPKI;

	PI_Speed.Ik_limit_min = PI_SPEED_IK_LIMIT_MIN;
	PI_Speed.Ik_limit_max = PI_SPEED_IK_LIMIT_MAX;
	PI_Speed.Ik_limit_min <<= PI_Speed.Scale_KpKi;		/* Ik (32-bit) limits shift, due to PI Controller design. */
	PI_Speed.Ik_limit_max <<= PI_Speed.Scale_KpKi;
10002174:	6190      	str	r0, [r2, #24]
  PI_Speed.Uk_limit_status = 0;
10002176:	2000      	movs	r0, #0
	PI_Torque.Ki = PI_TORQUE_KI;
	PI_Torque.Scale_KpKi = PI_TORQUE_SCALE_KPKI;

	PI_Torque.Ik_limit_min = PI_TORQUE_IK_LIMIT_MIN;
	PI_Torque.Ik_limit_max = PI_TORQUE_IK_LIMIT_MAX;
	PI_Torque.Ik_limit_min <<= PI_Torque.Scale_KpKi;	/* Ik limits shift. */
10002178:	1c2e      	adds	r6, r5, #0
  PI_Speed.Uk_limit_status = 0;

	PI_Speed.Ik = 0;

	PI_Speed.Uk_limit_min = PI_SPEED_UK_LIMIT_MIN;
	PI_Speed.Uk_limit_max = PI_SPEED_UK_LIMIT_MAX;
1000217a:	4c24      	ldr	r4, [pc, #144]	; (1000220c <PI_controller_Init+0xbc>)

	PI_Speed.Ik_limit_min = PI_SPEED_IK_LIMIT_MIN;
	PI_Speed.Ik_limit_max = PI_SPEED_IK_LIMIT_MAX;
	PI_Speed.Ik_limit_min <<= PI_Speed.Scale_KpKi;		/* Ik (32-bit) limits shift, due to PI Controller design. */
	PI_Speed.Ik_limit_max <<= PI_Speed.Scale_KpKi;
  PI_Speed.Uk_limit_status = 0;
1000217c:	5450      	strb	r0, [r2, r1]

	PI_Speed.Ik = 0;

	PI_Speed.Uk_limit_min = PI_SPEED_UK_LIMIT_MIN;
1000217e:	3920      	subs	r1, #32
	PI_Speed.Ik_limit_max = PI_SPEED_IK_LIMIT_MAX;
	PI_Speed.Ik_limit_min <<= PI_Speed.Scale_KpKi;		/* Ik (32-bit) limits shift, due to PI Controller design. */
	PI_Speed.Ik_limit_max <<= PI_Speed.Scale_KpKi;
  PI_Speed.Uk_limit_status = 0;

	PI_Speed.Ik = 0;
10002180:	6090      	str	r0, [r2, #8]

	PI_Speed.Uk_limit_min = PI_SPEED_UK_LIMIT_MIN;
10002182:	61d1      	str	r1, [r2, #28]
	PI_Speed.Uk_limit_max = PI_SPEED_UK_LIMIT_MAX;
10002184:	6214      	str	r4, [r2, #32]

  /*################### For Torque / Iq PI controller ######################*/
	PI_Torque.Kp = PI_TORQUE_KP;
10002186:	8a19      	ldrh	r1, [r3, #16]
10002188:	4a21      	ldr	r2, [pc, #132]	; (10002210 <PI_controller_Init+0xc0>)
1000218a:	8191      	strh	r1, [r2, #12]
	PI_Torque.Ki = PI_TORQUE_KI;
1000218c:	8a99      	ldrh	r1, [r3, #20]
	PI_Torque.Ik_limit_min <<= PI_Torque.Scale_KpKi;	/* Ik limits shift. */
	PI_Torque.Ik_limit_max <<= PI_Torque.Scale_KpKi;

	PI_Torque.Ik = 0;

	PI_Torque.Uk_limit_min = PI_TORQUE_UK_LIMIT_MIN;
1000218e:	61d5      	str	r5, [r2, #28]
	PI_Speed.Uk_limit_min = PI_SPEED_UK_LIMIT_MIN;
	PI_Speed.Uk_limit_max = PI_SPEED_UK_LIMIT_MAX;

  /*################### For Torque / Iq PI controller ######################*/
	PI_Torque.Kp = PI_TORQUE_KP;
	PI_Torque.Ki = PI_TORQUE_KI;
10002190:	81d1      	strh	r1, [r2, #14]
	PI_Torque.Scale_KpKi = PI_TORQUE_SCALE_KPKI;
10002192:	8b19      	ldrh	r1, [r3, #24]
	PI_Torque.Ik_limit_min = PI_TORQUE_IK_LIMIT_MIN;
	PI_Torque.Ik_limit_max = PI_TORQUE_IK_LIMIT_MAX;
	PI_Torque.Ik_limit_min <<= PI_Torque.Scale_KpKi;	/* Ik limits shift. */
	PI_Torque.Ik_limit_max <<= PI_Torque.Scale_KpKi;

	PI_Torque.Ik = 0;
10002194:	6090      	str	r0, [r2, #8]
	PI_Speed.Uk_limit_max = PI_SPEED_UK_LIMIT_MAX;

  /*################### For Torque / Iq PI controller ######################*/
	PI_Torque.Kp = PI_TORQUE_KP;
	PI_Torque.Ki = PI_TORQUE_KI;
	PI_Torque.Scale_KpKi = PI_TORQUE_SCALE_KPKI;
10002196:	8211      	strh	r1, [r2, #16]

	PI_Torque.Ik_limit_min = PI_TORQUE_IK_LIMIT_MIN;
	PI_Torque.Ik_limit_max = PI_TORQUE_IK_LIMIT_MAX;
	PI_Torque.Ik_limit_min <<= PI_Torque.Scale_KpKi;	/* Ik limits shift. */
10002198:	b209      	sxth	r1, r1
1000219a:	408e      	lsls	r6, r1
1000219c:	6156      	str	r6, [r2, #20]
	PI_Torque.Ik_limit_max <<= PI_Torque.Scale_KpKi;
1000219e:	1c26      	adds	r6, r4, #0
100021a0:	408e      	lsls	r6, r1
100021a2:	6196      	str	r6, [r2, #24]
	PI_Flux.Ki = PI_FLUX_KI;
	PI_Flux.Scale_KpKi = PI_FLUX_SCALE_KPKI;

	PI_Flux.Ik_limit_min = PI_FLUX_IK_LIMIT_MIN;
	PI_Flux.Ik_limit_max = PI_FLUX_IK_LIMIT_MAX;
	PI_Flux.Ik_limit_min <<= PI_Flux.Scale_KpKi;		/* Ik limits shift. */
100021a4:	1c2e      	adds	r6, r5, #0

	PI_Torque.Uk_limit_min = PI_TORQUE_UK_LIMIT_MIN;
	PI_Torque.Uk_limit_max = PI_TORQUE_UK_LIMIT_MAX;

  /*################### For Flux / Id PI controller ######################*/
	PI_Flux.Kp = PI_FLUX_KP;
100021a6:	8b99      	ldrh	r1, [r3, #28]
	PI_Torque.Ik_limit_max <<= PI_Torque.Scale_KpKi;

	PI_Torque.Ik = 0;

	PI_Torque.Uk_limit_min = PI_TORQUE_UK_LIMIT_MIN;
	PI_Torque.Uk_limit_max = PI_TORQUE_UK_LIMIT_MAX;
100021a8:	6214      	str	r4, [r2, #32]

  /*################### For Flux / Id PI controller ######################*/
	PI_Flux.Kp = PI_FLUX_KP;
100021aa:	4a1a      	ldr	r2, [pc, #104]	; (10002214 <PI_controller_Init+0xc4>)
100021ac:	8191      	strh	r1, [r2, #12]
	PI_Flux.Ki = PI_FLUX_KI;
100021ae:	8c19      	ldrh	r1, [r3, #32]
100021b0:	81d1      	strh	r1, [r2, #14]
	PI_Flux.Scale_KpKi = PI_FLUX_SCALE_KPKI;
100021b2:	8c99      	ldrh	r1, [r3, #36]	; 0x24
100021b4:	8211      	strh	r1, [r2, #16]

	PI_Flux.Ik_limit_min = PI_FLUX_IK_LIMIT_MIN;
	PI_Flux.Ik_limit_max = PI_FLUX_IK_LIMIT_MAX;
	PI_Flux.Ik_limit_min <<= PI_Flux.Scale_KpKi;		/* Ik limits shift. */
100021b6:	b209      	sxth	r1, r1
100021b8:	408e      	lsls	r6, r1
100021ba:	6156      	str	r6, [r2, #20]
	PI_Flux.Ik_limit_max <<= PI_Flux.Scale_KpKi;
100021bc:	1c26      	adds	r6, r4, #0
100021be:	408e      	lsls	r6, r1

	PI_Flux.Ik = 0;

	PI_Flux.Uk_limit_min = PI_FLUX_UK_LIMIT_MIN;
100021c0:	61d5      	str	r5, [r2, #28]
	PI_Flux.Scale_KpKi = PI_FLUX_SCALE_KPKI;

	PI_Flux.Ik_limit_min = PI_FLUX_IK_LIMIT_MIN;
	PI_Flux.Ik_limit_max = PI_FLUX_IK_LIMIT_MAX;
	PI_Flux.Ik_limit_min <<= PI_Flux.Scale_KpKi;		/* Ik limits shift. */
	PI_Flux.Ik_limit_max <<= PI_Flux.Scale_KpKi;
100021c2:	6196      	str	r6, [r2, #24]

	PI_Flux.Ik = 0;

	PI_Flux.Uk_limit_min = PI_FLUX_UK_LIMIT_MIN;
	PI_Flux.Uk_limit_max = PI_FLUX_UK_LIMIT_MAX;
100021c4:	6214      	str	r4, [r2, #32]

  /*################### For PLL rotor speed PI controller ######################*/
	PI_PLL.Kp = (uint16_t)PI_PLL_KP;
100021c6:	8d19      	ldrh	r1, [r3, #40]	; 0x28
	PI_Flux.Ik_limit_min = PI_FLUX_IK_LIMIT_MIN;
	PI_Flux.Ik_limit_max = PI_FLUX_IK_LIMIT_MAX;
	PI_Flux.Ik_limit_min <<= PI_Flux.Scale_KpKi;		/* Ik limits shift. */
	PI_Flux.Ik_limit_max <<= PI_Flux.Scale_KpKi;

	PI_Flux.Ik = 0;
100021c8:	6090      	str	r0, [r2, #8]

	PI_Flux.Uk_limit_min = PI_FLUX_UK_LIMIT_MIN;
	PI_Flux.Uk_limit_max = PI_FLUX_UK_LIMIT_MAX;

  /*################### For PLL rotor speed PI controller ######################*/
	PI_PLL.Kp = (uint16_t)PI_PLL_KP;
100021ca:	4a13      	ldr	r2, [pc, #76]	; (10002218 <PI_controller_Init+0xc8>)
100021cc:	8191      	strh	r1, [r2, #12]
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
100021ce:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
	PI_PLL.Ik_limit_max = (int32_t)PI_PLL_IK_LIMIT_MAX;
	PI_PLL.Ik_limit_min <<= PI_PLL.Scale_KpKi;			/* Ik limits shift. */
	PI_PLL.Ik_limit_max <<= PI_PLL.Scale_KpKi;

	PI_PLL.Ik = 0;
100021d0:	6090      	str	r0, [r2, #8]
	PI_Flux.Uk_limit_min = PI_FLUX_UK_LIMIT_MIN;
	PI_Flux.Uk_limit_max = PI_FLUX_UK_LIMIT_MAX;

  /*################### For PLL rotor speed PI controller ######################*/
	PI_PLL.Kp = (uint16_t)PI_PLL_KP;
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
100021d2:	81d1      	strh	r1, [r2, #14]
	PI_PLL.Scale_KpKi = PI_PLL_SCALE_KPKI;
100021d4:	6b19      	ldr	r1, [r3, #48]	; 0x30

	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
100021d6:	231e      	movs	r3, #30
	PI_Flux.Uk_limit_max = PI_FLUX_UK_LIMIT_MAX;

  /*################### For PLL rotor speed PI controller ######################*/
	PI_PLL.Kp = (uint16_t)PI_PLL_KP;
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
	PI_PLL.Scale_KpKi = PI_PLL_SCALE_KPKI;
100021d8:	b28c      	uxth	r4, r1

	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
100021da:	1a5b      	subs	r3, r3, r1
100021dc:	2101      	movs	r1, #1
100021de:	4099      	lsls	r1, r3
100021e0:	1c0b      	adds	r3, r1, #0
	PI_PLL.Ik_limit_max = (int32_t)PI_PLL_IK_LIMIT_MAX;
	PI_PLL.Ik_limit_min <<= PI_PLL.Scale_KpKi;			/* Ik limits shift. */
100021e2:	b221      	sxth	r1, r4
	PI_Flux.Uk_limit_max = PI_FLUX_UK_LIMIT_MAX;

  /*################### For PLL rotor speed PI controller ######################*/
	PI_PLL.Kp = (uint16_t)PI_PLL_KP;
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
	PI_PLL.Scale_KpKi = PI_PLL_SCALE_KPKI;
100021e4:	8214      	strh	r4, [r2, #16]

	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
100021e6:	425c      	negs	r4, r3
	PI_PLL.Ik_limit_max = (int32_t)PI_PLL_IK_LIMIT_MAX;
	PI_PLL.Ik_limit_min <<= PI_PLL.Scale_KpKi;			/* Ik limits shift. */
	PI_PLL.Ik_limit_max <<= PI_PLL.Scale_KpKi;
100021e8:	408b      	lsls	r3, r1
100021ea:	6193      	str	r3, [r2, #24]

	PI_PLL.Ik = 0;

	PI_PLL.Uk_limit_min = (int32_t)PI_PLL_UK_LIMIT_MIN;
100021ec:	2391      	movs	r3, #145	; 0x91
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
	PI_PLL.Scale_KpKi = PI_PLL_SCALE_KPKI;

	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
	PI_PLL.Ik_limit_max = (int32_t)PI_PLL_IK_LIMIT_MAX;
	PI_PLL.Ik_limit_min <<= PI_PLL.Scale_KpKi;			/* Ik limits shift. */
100021ee:	408c      	lsls	r4, r1
	PI_PLL.Ik_limit_max <<= PI_PLL.Scale_KpKi;

	PI_PLL.Ik = 0;

	PI_PLL.Uk_limit_min = (int32_t)PI_PLL_UK_LIMIT_MIN;
100021f0:	005b      	lsls	r3, r3, #1
100021f2:	61d3      	str	r3, [r2, #28]
	PI_PLL.Uk_limit_max = (int32_t)PI_PLL_UK_LIMIT_MAX;
100021f4:	4b09      	ldr	r3, [pc, #36]	; (1000221c <PI_controller_Init+0xcc>)
	PI_PLL.Ki = (uint16_t)PI_PLL_KI;
	PI_PLL.Scale_KpKi = PI_PLL_SCALE_KPKI;

	PI_PLL.Ik_limit_min = (int32_t)PI_PLL_IK_LIMIT_MIN;
	PI_PLL.Ik_limit_max = (int32_t)PI_PLL_IK_LIMIT_MAX;
	PI_PLL.Ik_limit_min <<= PI_PLL.Scale_KpKi;			/* Ik limits shift. */
100021f6:	6154      	str	r4, [r2, #20]
	PI_PLL.Ik_limit_max <<= PI_PLL.Scale_KpKi;

	PI_PLL.Ik = 0;

	PI_PLL.Uk_limit_min = (int32_t)PI_PLL_UK_LIMIT_MIN;
	PI_PLL.Uk_limit_max = (int32_t)PI_PLL_UK_LIMIT_MAX;
100021f8:	6213      	str	r3, [r2, #32]


}	/* End of PI_controller_Init () */
100021fa:	bd70      	pop	{r4, r5, r6, pc}
100021fc:	200012a8 	.word	0x200012a8
10002200:	200010f8 	.word	0x200010f8
10002204:	ffffc000 	.word	0xffffc000
10002208:	ffff8000 	.word	0xffff8000
1000220c:	00007fff 	.word	0x00007fff
10002210:	20001170 	.word	0x20001170
10002214:	20001148 	.word	0x20001148
10002218:	20001120 	.word	0x20001120
1000221c:	00004688 	.word	0x00004688

10002220 <MotorControl_Init>:

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
10002220:	211a      	movs	r1, #26
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/*###* Init for motor control ####
	 * ---------------------------*/
void MotorControl_Init (void)
{
10002222:	b508      	push	{r3, lr}


  Motor.State = BRAKE_BOOTSTRAP;/*
10002224:	4b1c      	ldr	r3, [pc, #112]	; (10002298 <MotorControl_Init+0x78>)
10002226:	2202      	movs	r2, #2

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
10002228:	6019      	str	r1, [r3, #0]
                                     //Using L_OMEGALI instead of Motor.L_METPLL in multiplication saves one MCU clock.

  Motor.Counter = 0;								// Init counters.
  Motor.Ramp_Counter = 0;
  Motor.Alignment_Counter = 0;
  Motor.Non_RealTime_Counter = 1;
1000222a:	3919      	subs	r1, #25
1000222c:	6499      	str	r1, [r3, #72]	; 0x48
  Motor.UART_Debug_Counter = 0;

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
  Motor.Speed_by_POT_PWM = SPEED_LOW_LIMIT;
1000222e:	2191      	movs	r1, #145	; 0x91
10002230:	0089      	lsls	r1, r1, #2
10002232:	60d9      	str	r1, [r3, #12]

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
10002234:	2110      	movs	r1, #16
10002236:	6259      	str	r1, [r3, #36]	; 0x24
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);
10002238:	3908      	subs	r1, #8
	 * ---------------------------*/
void MotorControl_Init (void)
{


  Motor.State = BRAKE_BOOTSTRAP;/*
1000223a:	62da      	str	r2, [r3, #44]	; 0x2c
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
  Motor.Speed_by_POT_PWM = SPEED_LOW_LIMIT;

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);
1000223c:	6299      	str	r1, [r3, #40]	; 0x28
  Motor.State = BRAKE_BOOTSTRAP;/*
                                 * First brake the motor before motor startup.
                                 * Charge gate driver bootstrap capacitors (if any).
                                 */

  Motor.Rotation_Dir = DIRECTION_INC; /* Motor rotation direction - rotor angle increasing. */
1000223e:	2200      	movs	r2, #0
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);


  Motor.PWM_DutyCycle = 0;
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.
10002240:	310c      	adds	r1, #12
10002242:	6219      	str	r1, [r3, #32]

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.
10002244:	2180      	movs	r1, #128	; 0x80
  Motor.Alignment_Counter = 0;
  Motor.Non_RealTime_Counter = 1;
  Motor.UART_Counter = 0;
  Motor.UART_Debug_Counter = 0;

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
10002246:	609a      	str	r2, [r3, #8]
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
10002248:	605a      	str	r2, [r3, #4]

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);


  Motor.PWM_DutyCycle = 0;
1000224a:	615a      	str	r2, [r3, #20]
  Motor.PWM_Speed_Raw = 0;
1000224c:	61da      	str	r2, [r3, #28]
  Motor.State = BRAKE_BOOTSTRAP;/*
                                 * First brake the motor before motor startup.
                                 * Charge gate driver bootstrap capacitors (if any).
                                 */

  Motor.Rotation_Dir = DIRECTION_INC; /* Motor rotation direction - rotor angle increasing. */
1000224e:	861a      	strh	r2, [r3, #48]	; 0x30

/* Init variables */

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.
10002250:	865a      	strh	r2, [r3, #50]	; 0x32

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
                                     //Using L_OMEGALI instead of Motor.L_METPLL in multiplication saves one MCU clock.

  Motor.Counter = 0;								// Init counters.
10002252:	63da      	str	r2, [r3, #60]	; 0x3c
  Motor.Ramp_Counter = 0;
10002254:	641a      	str	r2, [r3, #64]	; 0x40
  Motor.Alignment_Counter = 0;
10002256:	645a      	str	r2, [r3, #68]	; 0x44
  Motor.Non_RealTime_Counter = 1;
  Motor.UART_Counter = 0;
10002258:	651a      	str	r2, [r3, #80]	; 0x50
  Motor.UART_Debug_Counter = 0;
1000225a:	655a      	str	r2, [r3, #84]	; 0x54

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
1000225c:	659a      	str	r2, [r3, #88]	; 0x58

  Motor.PWM_DutyCycle = 0;
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.
1000225e:	4b0f      	ldr	r3, [pc, #60]	; (1000229c <MotorControl_Init+0x7c>)
10002260:	01c9      	lsls	r1, r1, #7
10002262:	8359      	strh	r1, [r3, #26]

  Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16U;
10002264:	2180      	movs	r1, #128	; 0x80
10002266:	05c9      	lsls	r1, r1, #23
  Car2Polar.Vref_AngleQ31_Previous = Car2Polar.Vref_AngleQ31;


  Car2Polar.SVM_Vref16 = 0;
10002268:	831a      	strh	r2, [r3, #24]
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.

  Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16U;
1000226a:	60d9      	str	r1, [r3, #12]
  Car2Polar.Vref_AngleQ31_Previous = Car2Polar.Vref_AngleQ31;
1000226c:	6159      	str	r1, [r3, #20]


  Car2Polar.SVM_Vref16 = 0;

  ADC.ADCTrig_Point = (uint32_t)(PERIOD_REG) >> 1;			// For ADC trigger for 2or3-shunt current sensing.
1000226e:	4b0c      	ldr	r3, [pc, #48]	; (100022a0 <MotorControl_Init+0x80>)
10002270:	490c      	ldr	r1, [pc, #48]	; (100022a4 <MotorControl_Init+0x84>)
10002272:	8399      	strh	r1, [r3, #28]

  ADC.ADC_DCLink = ADC_DCLINK_IDEAL;
10002274:	21b4      	movs	r1, #180	; 0xb4
10002276:	0109      	lsls	r1, r1, #4
10002278:	6259      	str	r1, [r3, #36]	; 0x24
  SVM.SVM_Flag = SVM_USE_PZV;        /* Init using SVM with Pseudo Zero Vectors (PZV). */
  ADC.Result_Flag = RESULTS_ADCTZ12;
#endif

  /* Init motor phase currents */
  Current.I_U = 0;
1000227a:	4b0b      	ldr	r3, [pc, #44]	; (100022a8 <MotorControl_Init+0x88>)
1000227c:	601a      	str	r2, [r3, #0]
  Current.I_V = 0;
1000227e:	605a      	str	r2, [r3, #4]
  Current.I_W = 0;
10002280:	609a      	str	r2, [r3, #8]

  SVM.PreviousSectorNo = 0;						// Init SVM sector No.
10002282:	4b0a      	ldr	r3, [pc, #40]	; (100022ac <MotorControl_Init+0x8c>)
10002284:	805a      	strh	r2, [r3, #2]

  SVM.Flag_3or2_ADC = USE_ALL_ADC;				// Init to use all (e.g.: three) ADC samplings for current reconstruction, for 2or3-shunt.
10002286:	809a      	strh	r2, [r3, #4]

  PI_controller_Init();							// Init parameters (Kp / Ki, limits) of PI controllers.
10002288:	f7ff ff62 	bl	10002150 <PI_controller_Init>


  FOC_SystemParameters_Init_OnceOnly();
1000228c:	f7ff fdd0 	bl	10001e30 <FOC_SystemParameters_Init_OnceOnly>
                                 */

  Motor.Rotation_Dir = DIRECTION_INC; /* Motor rotation direction - rotor angle increasing. */

	Variables_Init ();								/* Init variables. */
	Get_Current_Bias();
10002290:	f7fe ff4a 	bl	10001128 <Get_Current_Bias>

} /* End of MotorControl_Init () */
10002294:	bd08      	pop	{r3, pc}
10002296:	46c0      	nop			; (mov r8, r8)
10002298:	20001244 	.word	0x20001244
1000229c:	2000109c 	.word	0x2000109c
100022a0:	20001050 	.word	0x20001050
100022a4:	00000855 	.word	0x00000855
100022a8:	200010c4 	.word	0x200010c4
100022ac:	20001018 	.word	0x20001018

100022b0 <Variables_Init>:

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
100022b0:	211a      	movs	r1, #26

/* Init variables */

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.
100022b2:	4a1a      	ldr	r2, [pc, #104]	; (1000231c <Variables_Init+0x6c>)


/* Init variables */

void Variables_Init (void)
{
100022b4:	b508      	push	{r3, lr}
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
100022b6:	6011      	str	r1, [r2, #0]
                                     //Using L_OMEGALI instead of Motor.L_METPLL in multiplication saves one MCU clock.

  Motor.Counter = 0;								// Init counters.
  Motor.Ramp_Counter = 0;
  Motor.Alignment_Counter = 0;
  Motor.Non_RealTime_Counter = 1;
100022b8:	3919      	subs	r1, #25
100022ba:	6491      	str	r1, [r2, #72]	; 0x48
  Motor.UART_Debug_Counter = 0;

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
  Motor.Speed_by_POT_PWM = SPEED_LOW_LIMIT;
100022bc:	2191      	movs	r1, #145	; 0x91
100022be:	0089      	lsls	r1, r1, #2
100022c0:	60d1      	str	r1, [r2, #12]

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
100022c2:	2110      	movs	r1, #16
100022c4:	6251      	str	r1, [r2, #36]	; 0x24
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);
100022c6:	3908      	subs	r1, #8

/* Init variables */

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.
100022c8:	2300      	movs	r3, #0
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
  Motor.Speed_by_POT_PWM = SPEED_LOW_LIMIT;

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);
100022ca:	6291      	str	r1, [r2, #40]	; 0x28


  Motor.PWM_DutyCycle = 0;
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.
100022cc:	310c      	adds	r1, #12
100022ce:	6211      	str	r1, [r2, #32]

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.
100022d0:	2180      	movs	r1, #128	; 0x80
  Motor.Alignment_Counter = 0;
  Motor.Non_RealTime_Counter = 1;
  Motor.UART_Counter = 0;
  Motor.UART_Debug_Counter = 0;

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
100022d2:	6093      	str	r3, [r2, #8]
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
  Motor.Ref_Speed = 0;
100022d4:	6053      	str	r3, [r2, #4]

  Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;	// Slower ramp up and ramp down for S-curve profile.
  Motor.Ramp_Dn_Rate = RAMPDOWN_RATE << (RATIO_S - 1);


  Motor.PWM_DutyCycle = 0;
100022d6:	6153      	str	r3, [r2, #20]
  Motor.PWM_Speed_Raw = 0;
100022d8:	61d3      	str	r3, [r2, #28]

/* Init variables */

void Variables_Init (void)
{
  Motor.Mode_Flag = MOTOR_TRANSITION;				// Motor in transition mode.
100022da:	8653      	strh	r3, [r2, #50]	; 0x32

  Motor.L_METPLL = L_OMEGALI;						// Motor inductance per phase
                                     //Using L_OMEGALI instead of Motor.L_METPLL in multiplication saves one MCU clock.

  Motor.Counter = 0;								// Init counters.
100022dc:	63d3      	str	r3, [r2, #60]	; 0x3c
  Motor.Ramp_Counter = 0;
100022de:	6413      	str	r3, [r2, #64]	; 0x40
  Motor.Alignment_Counter = 0;
100022e0:	6453      	str	r3, [r2, #68]	; 0x44
  Motor.Non_RealTime_Counter = 1;
  Motor.UART_Counter = 0;
100022e2:	6513      	str	r3, [r2, #80]	; 0x50
  Motor.UART_Debug_Counter = 0;
100022e4:	6553      	str	r3, [r2, #84]	; 0x54

  Motor.Speed = DEFAULT_SPEED_STARTUP;			// Init for V/f ramp-up.
  Motor.FG_Speed = Motor.Speed;					// Motor speed for Frequency Generation (FG) only.
100022e6:	6593      	str	r3, [r2, #88]	; 0x58

  Motor.PWM_DutyCycle = 0;
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.
100022e8:	4a0d      	ldr	r2, [pc, #52]	; (10002320 <Variables_Init+0x70>)
100022ea:	01c9      	lsls	r1, r1, #7
100022ec:	8351      	strh	r1, [r2, #26]

  Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16U;
100022ee:	2180      	movs	r1, #128	; 0x80
100022f0:	05c9      	lsls	r1, r1, #23
  Car2Polar.Vref_AngleQ31_Previous = Car2Polar.Vref_AngleQ31;


  Car2Polar.SVM_Vref16 = 0;
100022f2:	8313      	strh	r3, [r2, #24]
  Motor.PWM_Speed_Raw = 0;
  Motor.PWM_Freq = 20;							// Init PWM frequency 20Hz.

  Car2Polar.SVM_Angle16 = (DEGREE_X >> 16U);		// Init Vref angle θ = X°.

  Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16U;
100022f4:	60d1      	str	r1, [r2, #12]
  Car2Polar.Vref_AngleQ31_Previous = Car2Polar.Vref_AngleQ31;
100022f6:	6151      	str	r1, [r2, #20]


  Car2Polar.SVM_Vref16 = 0;

  ADC.ADCTrig_Point = (uint32_t)(PERIOD_REG) >> 1;			// For ADC trigger for 2or3-shunt current sensing.
100022f8:	4a0a      	ldr	r2, [pc, #40]	; (10002324 <Variables_Init+0x74>)
100022fa:	490b      	ldr	r1, [pc, #44]	; (10002328 <Variables_Init+0x78>)
100022fc:	8391      	strh	r1, [r2, #28]

  ADC.ADC_DCLink = ADC_DCLINK_IDEAL;
100022fe:	21b4      	movs	r1, #180	; 0xb4
10002300:	0109      	lsls	r1, r1, #4
10002302:	6251      	str	r1, [r2, #36]	; 0x24
  SVM.SVM_Flag = SVM_USE_PZV;        /* Init using SVM with Pseudo Zero Vectors (PZV). */
  ADC.Result_Flag = RESULTS_ADCTZ12;
#endif

  /* Init motor phase currents */
  Current.I_U = 0;
10002304:	4a09      	ldr	r2, [pc, #36]	; (1000232c <Variables_Init+0x7c>)
10002306:	6013      	str	r3, [r2, #0]
  Current.I_V = 0;
10002308:	6053      	str	r3, [r2, #4]
  Current.I_W = 0;
1000230a:	6093      	str	r3, [r2, #8]

  SVM.PreviousSectorNo = 0;						// Init SVM sector No.
1000230c:	4a08      	ldr	r2, [pc, #32]	; (10002330 <Variables_Init+0x80>)
1000230e:	8053      	strh	r3, [r2, #2]

  SVM.Flag_3or2_ADC = USE_ALL_ADC;				// Init to use all (e.g.: three) ADC samplings for current reconstruction, for 2or3-shunt.
10002310:	8093      	strh	r3, [r2, #4]

  PI_controller_Init();							// Init parameters (Kp / Ki, limits) of PI controllers.
10002312:	f7ff ff1d 	bl	10002150 <PI_controller_Init>


  FOC_SystemParameters_Init_OnceOnly();
10002316:	f7ff fd8b 	bl	10001e30 <FOC_SystemParameters_Init_OnceOnly>

}	// End of Variables_Init ()
1000231a:	bd08      	pop	{r3, pc}
1000231c:	20001244 	.word	0x20001244
10002320:	2000109c 	.word	0x2000109c
10002324:	20001050 	.word	0x20001050
10002328:	00000855 	.word	0x00000855
1000232c:	200010c4 	.word	0x200010c4
10002330:	20001018 	.word	0x20001018

10002334 <XMC_FLASH_ProgramVerifyPage>:
{
  (void)XMC1000_NvmErasePage(address);
}

void XMC_FLASH_ProgramVerifyPage(uint32_t *address, const uint32_t *data)
{
10002334:	b508      	push	{r3, lr}
  (void)XMC1000_NvmProgVerify(data, address);
10002336:	2382      	movs	r3, #130	; 0x82
{
  (void)XMC1000_NvmErasePage(address);
}

void XMC_FLASH_ProgramVerifyPage(uint32_t *address, const uint32_t *data)
{
10002338:	1c02      	adds	r2, r0, #0
  (void)XMC1000_NvmProgVerify(data, address);
1000233a:	005b      	lsls	r3, r3, #1
1000233c:	1c08      	adds	r0, r1, #0
1000233e:	681b      	ldr	r3, [r3, #0]
10002340:	1c11      	adds	r1, r2, #0
10002342:	4798      	blx	r3
}
10002344:	bd08      	pop	{r3, pc}
10002346:	46c0      	nop			; (mov r8, r8)

10002348 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
10002348:	b5f0      	push	{r4, r5, r6, r7, lr}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000234a:	2403      	movs	r4, #3
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
1000234c:	4647      	mov	r7, r8
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000234e:	1c26      	adds	r6, r4, #0
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
10002350:	b480      	push	{r7}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
10002352:	27f8      	movs	r7, #248	; 0xf8
10002354:	400e      	ands	r6, r1
10002356:	00f6      	lsls	r6, r6, #3
10002358:	40b7      	lsls	r7, r6
1000235a:	088b      	lsrs	r3, r1, #2
1000235c:	009b      	lsls	r3, r3, #2
1000235e:	18c3      	adds	r3, r0, r3
10002360:	691d      	ldr	r5, [r3, #16]
10002362:	46b0      	mov	r8, r6
10002364:	43bd      	bics	r5, r7

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10002366:	004f      	lsls	r7, r1, #1
10002368:	40bc      	lsls	r4, r7
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
  XMC_ASSERT("XMC_GPIO_Init: Invalid input hysteresis", XMC_GPIO_CHECK_INPUT_HYSTERESIS(config->input_hysteresis));
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
1000236a:	611d      	str	r5, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
1000236c:	6f45      	ldr	r5, [r0, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
1000236e:	2604      	movs	r6, #4
  
  /* Switch to input */
  port->IOCR[pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
10002370:	43a5      	bics	r5, r4
10002372:	6745      	str	r5, [r0, #116]	; 0x74

  /* Set input hysteresis */
  port->PHCR[(uint32_t)pin >> 3U] &= ~(uint32_t)((uint32_t)PORT_PHCR_Msk << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U)));
10002374:	2507      	movs	r5, #7
10002376:	400d      	ands	r5, r1
10002378:	00ad      	lsls	r5, r5, #2
1000237a:	40ae      	lsls	r6, r5
1000237c:	08cc      	lsrs	r4, r1, #3
1000237e:	00a4      	lsls	r4, r4, #2
10002380:	1904      	adds	r4, r0, r4
10002382:	6c27      	ldr	r7, [r4, #64]	; 0x40
10002384:	43b7      	bics	r7, r6
10002386:	6427      	str	r7, [r4, #64]	; 0x40
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
10002388:	7856      	ldrb	r6, [r2, #1]
1000238a:	6c27      	ldr	r7, [r4, #64]	; 0x40
1000238c:	40ae      	lsls	r6, r5
1000238e:	1c35      	adds	r5, r6, #0
10002390:	433d      	orrs	r5, r7
10002392:	6425      	str	r5, [r4, #64]	; 0x40
    
  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
10002394:	4c0a      	ldr	r4, [pc, #40]	; (100023c0 <XMC_GPIO_Init+0x78>)
10002396:	42a0      	cmp	r0, r4
10002398:	d00c      	beq.n	100023b4 <XMC_GPIO_Init+0x6c>
  {    
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  /* Set output level */
  port->OMR = (uint32_t)config->output_level << pin;
1000239a:	6854      	ldr	r4, [r2, #4]
  
  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
1000239c:	7812      	ldrb	r2, [r2, #0]
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {    
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  /* Set output level */
  port->OMR = (uint32_t)config->output_level << pin;
1000239e:	408c      	lsls	r4, r1
100023a0:	6044      	str	r4, [r0, #4]
  
  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << (PORT_IOCR_PC_Size * (pin & 0x3U));
100023a2:	4640      	mov	r0, r8
100023a4:	4082      	lsls	r2, r0
100023a6:	1c16      	adds	r6, r2, #0
100023a8:	6919      	ldr	r1, [r3, #16]
100023aa:	430e      	orrs	r6, r1
100023ac:	611e      	str	r6, [r3, #16]
}
100023ae:	bc04      	pop	{r2}
100023b0:	4690      	mov	r8, r2
100023b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  port->PHCR[(uint32_t)pin >> 3U] |= (uint32_t)config->input_hysteresis << ((uint32_t)PORT_PHCR_Size * ((uint32_t)pin & 0x7U));
    
  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {    
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
100023b4:	2501      	movs	r5, #1
100023b6:	408d      	lsls	r5, r1
100023b8:	6e04      	ldr	r4, [r0, #96]	; 0x60
100023ba:	43ac      	bics	r4, r5
100023bc:	6604      	str	r4, [r0, #96]	; 0x60
100023be:	e7ec      	b.n	1000239a <XMC_GPIO_Init+0x52>
100023c0:	40040200 	.word	0x40040200

100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>:
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100023c4:	23c0      	movs	r3, #192	; 0xc0

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100023c6:	2104      	movs	r1, #4
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100023c8:	4a08      	ldr	r2, [pc, #32]	; (100023ec <XMC_SCU_CLOCK_UngatePeripheralClock+0x28>)
100023ca:	6253      	str	r3, [r2, #36]	; 0x24

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100023cc:	6a53      	ldr	r3, [r2, #36]	; 0x24
100023ce:	4219      	tst	r1, r3
100023d0:	d1fc      	bne.n	100023cc <XMC_SCU_CLOCK_UngatePeripheralClock+0x8>
/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  XMC_SCU_UnlockProtectedBits();
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100023d2:	2180      	movs	r1, #128	; 0x80

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  XMC_SCU_UnlockProtectedBits();
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
100023d4:	4a06      	ldr	r2, [pc, #24]	; (100023f0 <XMC_SCU_CLOCK_UngatePeripheralClock+0x2c>)
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100023d6:	05c9      	lsls	r1, r1, #23

/* API which ungates a clock note at its source */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  XMC_SCU_UnlockProtectedBits();
  SCU_CLK->CGATCLR0 |= (uint32_t)peripheral;
100023d8:	6913      	ldr	r3, [r2, #16]
100023da:	4318      	orrs	r0, r3
100023dc:	6110      	str	r0, [r2, #16]
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
100023de:	6813      	ldr	r3, [r2, #0]
100023e0:	420b      	tst	r3, r1
100023e2:	d1fc      	bne.n	100023de <XMC_SCU_CLOCK_UngatePeripheralClock+0x1a>
}

 /* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
100023e4:	22c3      	movs	r2, #195	; 0xc3
100023e6:	4b01      	ldr	r3, [pc, #4]	; (100023ec <XMC_SCU_CLOCK_UngatePeripheralClock+0x28>)
100023e8:	625a      	str	r2, [r3, #36]	; 0x24
  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
  {
    /* Wait voltage suply stabilization */
  }
  XMC_SCU_LockProtectedBits();
}
100023ea:	4770      	bx	lr
100023ec:	40010000 	.word	0x40010000
100023f0:	40010300 	.word	0x40010300

100023f4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>:
}


/* A utility routine which updates the fractional dividers in steps */
void XMC_SCU_CLOCK_ScaleMCLKFrequency(uint32_t idiv, uint32_t fdiv)
{
100023f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100023f6:	23c0      	movs	r3, #192	; 0xc0

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100023f8:	2404      	movs	r4, #4
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100023fa:	4a2d      	ldr	r2, [pc, #180]	; (100024b0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xbc>)
100023fc:	6253      	str	r3, [r2, #36]	; 0x24

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100023fe:	6a53      	ldr	r3, [r2, #36]	; 0x24
10002400:	421c      	tst	r4, r3
10002402:	d1fc      	bne.n	100023fe <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xa>

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
10002404:	23ff      	movs	r3, #255	; 0xff
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10002406:	4a2b      	ldr	r2, [pc, #172]	; (100024b4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc0>)
10002408:	6814      	ldr	r4, [r2, #0]

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
1000240a:	6815      	ldr	r5, [r2, #0]
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
1000240c:	0424      	lsls	r4, r4, #16

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
1000240e:	439d      	bics	r5, r3
10002410:	4b29      	ldr	r3, [pc, #164]	; (100024b8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc4>)
  uint32_t curr_idiv;

  XMC_SCU_UnlockProtectedBits();

  /* Take a snapshot of value already programmed into IDIV */
  curr_idiv = (SCU_CLK->CLKCR & SCU_CLK_CLKCR_IDIV_Msk) >> SCU_CLK_CLKCR_IDIV_Pos;
10002412:	0e24      	lsrs	r4, r4, #24
10002414:	432b      	orrs	r3, r5
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
10002416:	430b      	orrs	r3, r1
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002418:	2180      	movs	r1, #128	; 0x80

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
                   (uint32_t)((fdiv & 0xffU) << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#else
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_FDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Pos)) |
1000241a:	6013      	str	r3, [r2, #0]
                   (uint32_t)(fdiv << SCU_CLK_CLKCR_FDIV_Pos) |
                   (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
#endif

  while ((SCU_CLK->CLKCR)& SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000241c:	05c9      	lsls	r1, r1, #23
1000241e:	6813      	ldr	r3, [r2, #0]
10002420:	420b      	tst	r3, r1
10002422:	d1fc      	bne.n	1000241e <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x2a>
  {
    /* Spin until the core supply stabilizes */
  }

  if(curr_idiv <= idiv)
10002424:	4284      	cmp	r4, r0
10002426:	d929      	bls.n	1000247c <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x88>
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002428:	2180      	movs	r1, #128	; 0x80
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000242a:	4b24      	ldr	r3, [pc, #144]	; (100024bc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc8>)
1000242c:	0086      	lsls	r6, r0, #2
1000242e:	4a21      	ldr	r2, [pc, #132]	; (100024b4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc0>)
10002430:	469c      	mov	ip, r3
10002432:	4f21      	ldr	r7, [pc, #132]	; (100024b8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc4>)
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002434:	05c9      	lsls	r1, r1, #23
}

/* Utility routine to perform frequency upscaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10002436:	42b4      	cmp	r4, r6
10002438:	d90c      	bls.n	10002454 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000243a:	4665      	mov	r5, ip
1000243c:	6813      	ldr	r3, [r2, #0]
/* Utility routine to perform frequency upscaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */
1000243e:	08a4      	lsrs	r4, r4, #2

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002440:	402b      	ands	r3, r5
10002442:	433b      	orrs	r3, r7
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
10002444:	0225      	lsls	r5, r4, #8
10002446:	432b      	orrs	r3, r5
{
  while (curr_idiv > (target_idiv * 4UL))
  {
    curr_idiv = (uint32_t)(curr_idiv >> 2UL);   /* Divide by 4. */

    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002448:	6013      	str	r3, [r2, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000244a:	6813      	ldr	r3, [r2, #0]
1000244c:	420b      	tst	r3, r1
1000244e:	d1fc      	bne.n	1000244a <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x56>
}

/* Utility routine to perform frequency upscaling */
static void XMC_SCU_CLOCK_lFrequencyUpScaling(uint32_t curr_idiv, uint32_t target_idiv)
{
  while (curr_idiv > (target_idiv * 4UL))
10002450:	42b4      	cmp	r4, r6
10002452:	d8f2      	bhi.n	1000243a <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x46>
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002454:	4a17      	ldr	r2, [pc, #92]	; (100024b4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc0>)
10002456:	4b19      	ldr	r3, [pc, #100]	; (100024bc <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc8>)
10002458:	6811      	ldr	r1, [r2, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
1000245a:	0200      	lsls	r0, r0, #8
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
1000245c:	400b      	ands	r3, r1
1000245e:	4916      	ldr	r1, [pc, #88]	; (100024b8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc4>)
10002460:	430b      	orrs	r3, r1
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002462:	2180      	movs	r1, #128	; 0x80
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);
10002464:	4303      	orrs	r3, r0
  {
    /* Requested IDIV is lower than currently programmed IDIV. So upscale the frequency */
    XMC_SCU_CLOCK_lFrequencyUpScaling(curr_idiv, idiv);
  }

  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk | SCU_CLK_CLKCR_CNTADJ_Msk)) |
10002466:	6013      	str	r3, [r2, #0]
                   (uint32_t)(idiv << SCU_CLK_CLKCR_IDIV_Pos) | (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

  while ((SCU_CLK->CLKCR) & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002468:	05c9      	lsls	r1, r1, #23
1000246a:	6813      	ldr	r3, [r2, #0]
1000246c:	420b      	tst	r3, r1
1000246e:	d1fc      	bne.n	1000246a <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x76>
}

 /* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
10002470:	22c3      	movs	r2, #195	; 0xc3
10002472:	4b0f      	ldr	r3, [pc, #60]	; (100024b0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xbc>)
10002474:	625a      	str	r2, [r3, #36]	; 0x24
    /* Wait voltage suply stabilization */
  }

  XMC_SCU_LockProtectedBits();

  SystemCoreClockUpdate();
10002476:	f7fe fe13 	bl	100010a0 <SystemCoreClockUpdate>

}
1000247a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk|SCU_CLK_CLKCR_CNTADJ_Pos)) |
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000247c:	2180      	movs	r1, #128	; 0x80
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk|SCU_CLK_CLKCR_CNTADJ_Pos)) |
1000247e:	4a0d      	ldr	r2, [pc, #52]	; (100024b4 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc0>)
10002480:	4f0f      	ldr	r7, [pc, #60]	; (100024c0 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xcc>)
10002482:	4e0d      	ldr	r6, [pc, #52]	; (100024b8 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xc4>)
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
10002484:	05c9      	lsls	r1, r1, #23

/* Utility routine to perform frequency downscaling */
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
10002486:	00a3      	lsls	r3, r4, #2
10002488:	4298      	cmp	r0, r3
1000248a:	d9e3      	bls.n	10002454 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x60>
  {
    if(0U == curr_idiv)
1000248c:	2c00      	cmp	r4, #0
1000248e:	d00a      	beq.n	100024a6 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xb2>
10002490:	02a5      	lsls	r5, r4, #10
10002492:	1c1c      	adds	r4, r3, #0
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk|SCU_CLK_CLKCR_CNTADJ_Pos)) |
10002494:	6813      	ldr	r3, [r2, #0]
10002496:	403b      	ands	r3, r7
10002498:	4333      	orrs	r3, r6
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
1000249a:	432b      	orrs	r3, r5
    if(0U == curr_idiv)
    {
      curr_idiv = 1U;
    }
    curr_idiv  = (uint32_t)(curr_idiv << 2UL);   /* Multiply by 4. */
    SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_IDIV_Msk|SCU_CLK_CLKCR_CNTADJ_Pos)) |
1000249c:	6013      	str	r3, [r2, #0]
                     (uint32_t)(curr_idiv << SCU_CLK_CLKCR_IDIV_Pos) |
                     (uint32_t)(1023UL << SCU_CLK_CLKCR_CNTADJ_Pos);

    while (SCU_CLK->CLKCR & SCU_CLK_CLKCR_VDDC2LOW_Msk)
1000249e:	6813      	ldr	r3, [r2, #0]
100024a0:	420b      	tst	r3, r1
100024a2:	d1fc      	bne.n	1000249e <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xaa>
100024a4:	e7ef      	b.n	10002486 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0x92>
static void XMC_SCU_CLOCK_lFrequencyDownScaling(uint32_t curr_idiv, uint32_t target_idiv)
{

  while ((curr_idiv * 4UL) < target_idiv)
  {
    if(0U == curr_idiv)
100024a6:	2580      	movs	r5, #128	; 0x80
100024a8:	2404      	movs	r4, #4
100024aa:	00ed      	lsls	r5, r5, #3
100024ac:	e7f2      	b.n	10002494 <XMC_SCU_CLOCK_ScaleMCLKFrequency+0xa0>
100024ae:	46c0      	nop			; (mov r8, r8)
100024b0:	40010000 	.word	0x40010000
100024b4:	40010300 	.word	0x40010300
100024b8:	3ff00000 	.word	0x3ff00000
100024bc:	c00f00ff 	.word	0xc00f00ff
100024c0:	ffff00eb 	.word	0xffff00eb

100024c4 <XMC_SCU_CLOCK_Init>:
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100024c4:	23c0      	movs	r3, #192	; 0xc0

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100024c6:	2104      	movs	r1, #4
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100024c8:	4a0b      	ldr	r2, [pc, #44]	; (100024f8 <XMC_SCU_CLOCK_Init+0x34>)
}


/* API which initializes the clock tree ofthe device */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
100024ca:	b510      	push	{r4, lr}
}

/* API to make protected bitfields available for modification */
void XMC_SCU_UnlockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_DISABLE;
100024cc:	6253      	str	r3, [r2, #36]	; 0x24

  while(((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk))
100024ce:	6a53      	ldr	r3, [r2, #36]	; 0x24
100024d0:	4219      	tst	r1, r3
100024d2:	d1fc      	bne.n	100024ce <XMC_SCU_CLOCK_Init+0xa>
100024d4:	6882      	ldr	r2, [r0, #8]
100024d6:	6841      	ldr	r1, [r0, #4]
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100024d8:	4c08      	ldr	r4, [pc, #32]	; (100024fc <XMC_SCU_CLOCK_Init+0x38>)
100024da:	4311      	orrs	r1, r2
100024dc:	6823      	ldr	r3, [r4, #0]
100024de:	4a08      	ldr	r2, [pc, #32]	; (10002500 <XMC_SCU_CLOCK_Init+0x3c>)
100024e0:	4013      	ands	r3, r2
}

 /* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
100024e2:	22c3      	movs	r2, #195	; 0xc3
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
                   config->rtc_src |
100024e4:	430b      	orrs	r3, r1
  SCU_CLK->CLKCR1 = (SCU_CLK->CLKCR1 & ~SCU_CLK_CLKCR1_DCLKSEL_Msk) |
                    config->dclk_src;

#endif
  /* Update PCLK selection mux. */
  SCU_CLK->CLKCR = (SCU_CLK->CLKCR & (uint32_t)~(SCU_CLK_CLKCR_PCLKSEL_Msk | SCU_CLK_CLKCR_RTCCLKSEL_Msk)) |
100024e6:	6023      	str	r3, [r4, #0]
}

 /* API to lock protected bitfields from being modified */
void XMC_SCU_LockProtectedBits(void)
{
  SCU_GENERAL->PASSWD = SCU_GCU_PASSWD_PROT_ENABLE;
100024e8:	4b03      	ldr	r3, [pc, #12]	; (100024f8 <XMC_SCU_CLOCK_Init+0x34>)
100024ea:	625a      	str	r2, [r3, #36]	; 0x24

  /* Close the lock opened above. */
  XMC_SCU_LockProtectedBits();

  /* Update the dividers now */
  XMC_SCU_CLOCK_ScaleMCLKFrequency(config->idiv, config->fdiv);
100024ec:	7843      	ldrb	r3, [r0, #1]
100024ee:	7801      	ldrb	r1, [r0, #0]
100024f0:	1c18      	adds	r0, r3, #0
100024f2:	f7ff ff7f 	bl	100023f4 <XMC_SCU_CLOCK_ScaleMCLKFrequency>

}
100024f6:	bd10      	pop	{r4, pc}
100024f8:	40010000 	.word	0x40010000
100024fc:	40010300 	.word	0x40010300
10002500:	fff0ffff 	.word	0xfff0ffff

10002504 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
10002504:	b538      	push	{r3, r4, r5, lr}
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  switch ((uint32_t)module)
10002506:	4b0a      	ldr	r3, [pc, #40]	; (10002530 <XMC_CCU4_Init+0x2c>)
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
10002508:	1c04      	adds	r4, r0, #0
1000250a:	1c0d      	adds	r5, r1, #0
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  switch ((uint32_t)module)
1000250c:	4298      	cmp	r0, r3
1000250e:	d102      	bne.n	10002516 <XMC_CCU4_Init+0x12>
  {
    case (uint32_t)CCU40:
      XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
10002510:	2004      	movs	r0, #4
10002512:	f7ff ff57 	bl	100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>
10002516:	2280      	movs	r2, #128	; 0x80
10002518:	68e3      	ldr	r3, [r4, #12]
1000251a:	0052      	lsls	r2, r2, #1
1000251c:	4313      	orrs	r3, r2
1000251e:	60e3      	str	r3, [r4, #12]
  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
10002520:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
10002522:	4b04      	ldr	r3, [pc, #16]	; (10002534 <XMC_CCU4_Init+0x30>)
10002524:	400b      	ands	r3, r1
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
10002526:	03a9      	lsls	r1, r5, #14
10002528:	4319      	orrs	r1, r3
  
  module->GCTRL = gctrl;
1000252a:	6021      	str	r1, [r4, #0]
}
1000252c:	bd38      	pop	{r3, r4, r5, pc}
1000252e:	46c0      	nop			; (mov r8, r8)
10002530:	48040000 	.word	0x48040000
10002534:	ffff3fff 	.word	0xffff3fff

10002538 <XMC_CCU4_SetModuleClock>:

  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Clock", XMC_CCU4_SLICE_CHECK_CLOCK(clock));

  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t) CCU4_GCTRL_PCIS_Msk);
10002538:	2230      	movs	r2, #48	; 0x30
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Clock", XMC_CCU4_SLICE_CHECK_CLOCK(clock));

  gctrl = module->GCTRL;
1000253a:	6803      	ldr	r3, [r0, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_PCIS_Msk);
  gctrl |= ((uint32_t) clock) << CCU4_GCTRL_PCIS_Pos;
1000253c:	0109      	lsls	r1, r1, #4

  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_SetModuleClock:Invalid Module Clock", XMC_CCU4_SLICE_CHECK_CLOCK(clock));

  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t) CCU4_GCTRL_PCIS_Msk);
1000253e:	4393      	bics	r3, r2
  gctrl |= ((uint32_t) clock) << CCU4_GCTRL_PCIS_Pos;
10002540:	4319      	orrs	r1, r3
  
  module->GCTRL = gctrl;
10002542:	6001      	str	r1, [r0, #0]
}
10002544:	4770      	bx	lr
10002546:	46c0      	nop			; (mov r8, r8)

10002548 <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
10002548:	b538      	push	{r3, r4, r5, lr}
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  switch ((uint32_t)module)
1000254a:	23a0      	movs	r3, #160	; 0xa0
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
1000254c:	1c04      	adds	r4, r0, #0
1000254e:	1c0d      	adds	r5, r1, #0
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  switch ((uint32_t)module)
10002550:	05db      	lsls	r3, r3, #23
10002552:	4298      	cmp	r0, r3
10002554:	d102      	bne.n	1000255c <XMC_CCU8_Init+0x14>
  {
    case (uint32_t)CCU80:
      XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
10002556:	2002      	movs	r0, #2
10002558:	f7ff ff34 	bl	100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
1000255c:	2280      	movs	r2, #128	; 0x80
1000255e:	68e3      	ldr	r3, [r4, #12]
10002560:	0052      	lsls	r2, r2, #1
10002562:	4313      	orrs	r3, r2
10002564:	60e3      	str	r3, [r4, #12]
  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
  
  gctrl = module->GCTRL;
10002566:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
10002568:	4b02      	ldr	r3, [pc, #8]	; (10002574 <XMC_CCU8_Init+0x2c>)
1000256a:	400b      	ands	r3, r1
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
1000256c:	03a9      	lsls	r1, r5, #14
1000256e:	4319      	orrs	r1, r3
  
  module->GCTRL = gctrl;
10002570:	6021      	str	r1, [r4, #0]
}
10002572:	bd38      	pop	{r3, r4, r5, pc}
10002574:	ffff3fff 	.word	0xffff3fff

10002578 <XMC_CCU8_SLICE_CompareInit>:
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR |= (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
10002578:	2301      	movs	r3, #1
1000257a:	6902      	ldr	r2, [r0, #16]
1000257c:	4313      	orrs	r3, r2
  slice->PSL = (uint32_t) compare_init->psl;
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
1000257e:	2214      	movs	r2, #20
10002580:	6103      	str	r3, [r0, #16]
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
10002582:	680b      	ldr	r3, [r1, #0]
10002584:	6143      	str	r3, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
10002586:	7b4b      	ldrb	r3, [r1, #13]
10002588:	06db      	lsls	r3, r3, #27
1000258a:	0fdb      	lsrs	r3, r3, #31
1000258c:	051b      	lsls	r3, r3, #20
1000258e:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
10002590:	7b0b      	ldrb	r3, [r1, #12]
10002592:	071b      	lsls	r3, r3, #28
10002594:	0f1b      	lsrs	r3, r3, #28
10002596:	6243      	str	r3, [r0, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
10002598:	7b0b      	ldrb	r3, [r1, #12]
1000259a:	091b      	lsrs	r3, r3, #4
1000259c:	62c3      	str	r3, [r0, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
1000259e:	7b4b      	ldrb	r3, [r1, #13]
100025a0:	071b      	lsls	r3, r3, #28
100025a2:	0f1b      	lsrs	r3, r3, #28
100025a4:	6203      	str	r3, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
100025a6:	684b      	ldr	r3, [r1, #4]
100025a8:	6183      	str	r3, [r0, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
100025aa:	688b      	ldr	r3, [r1, #8]
100025ac:	4053      	eors	r3, r2
100025ae:	6483      	str	r3, [r0, #72]	; 0x48
#endif
}
100025b0:	4770      	bx	lr
100025b2:	46c0      	nop			; (mov r8, r8)

100025b4 <XMC_CCU8_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice*/
void XMC_CCU8_SLICE_StartConfig(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_EVENT_t event,
                                const XMC_CCU8_SLICE_START_MODE_t start_mode)
{
100025b4:	b510      	push	{r4, lr}
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) ||\
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
100025b6:	2403      	movs	r4, #3
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) ||\
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
100025b8:	6843      	ldr	r3, [r0, #4]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
100025ba:	43a3      	bics	r3, r4
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
100025bc:	4319      	orrs	r1, r3

  slice->CMC = cmc;
100025be:	6041      	str	r1, [r0, #4]

  tc  = slice->TC;
100025c0:	6943      	ldr	r3, [r0, #20]

  if(start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
100025c2:	2a01      	cmp	r2, #1
100025c4:	d003      	beq.n	100025ce <XMC_CCU8_SLICE_StartConfig+0x1a>
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
100025c6:	4a04      	ldr	r2, [pc, #16]	; (100025d8 <XMC_CCU8_SLICE_StartConfig+0x24>)
100025c8:	4013      	ands	r3, r2
  }

  slice->TC = tc;
100025ca:	6143      	str	r3, [r0, #20]
}
100025cc:	bd10      	pop	{r4, pc}

  tc  = slice->TC;

  if(start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
100025ce:	2280      	movs	r2, #128	; 0x80
100025d0:	00d2      	lsls	r2, r2, #3
100025d2:	4313      	orrs	r3, r2
100025d4:	e7f9      	b.n	100025ca <XMC_CCU8_SLICE_StartConfig+0x16>
100025d6:	46c0      	nop			; (mov r8, r8)
100025d8:	fffffbff 	.word	0xfffffbff

100025dc <XMC_CCU8_SLICE_TrapConfig>:

  cmc = slice->CMC;

  /* Map trap function to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_TS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
100025dc:	2380      	movs	r3, #128	; 0x80

/* API to configure trap function*/
void XMC_CCU8_SLICE_TrapConfig(XMC_CCU8_SLICE_t *const slice,
                               const XMC_CCU8_SLICE_TRAP_EXIT_MODE_t exit_mode,
                               const bool synch_with_pwm)
{
100025de:	b510      	push	{r4, lr}

  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC) ||\
                                                             (exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)));

  cmc = slice->CMC;
100025e0:	6844      	ldr	r4, [r0, #4]

  /* Map trap function to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_TS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
100025e2:	029b      	lsls	r3, r3, #10
100025e4:	4323      	orrs	r3, r4

  slice->CMC = cmc;
100025e6:	6043      	str	r3, [r0, #4]

  tc = slice->TC;
100025e8:	6943      	ldr	r3, [r0, #20]

  /* Configure synchronization option */
  if(synch_with_pwm == true)
100025ea:	2a00      	cmp	r2, #0
100025ec:	d008      	beq.n	10002600 <XMC_CCU8_SLICE_TrapConfig+0x24>
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
100025ee:	2280      	movs	r2, #128	; 0x80
100025f0:	0392      	lsls	r2, r2, #14
100025f2:	4313      	orrs	r3, r2
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
  }

  /* Configure exit mode */
  if(exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)
100025f4:	2901      	cmp	r1, #1
100025f6:	d007      	beq.n	10002608 <XMC_CCU8_SLICE_TrapConfig+0x2c>
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSW_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSW_Msk);
100025f8:	4a05      	ldr	r2, [pc, #20]	; (10002610 <XMC_CCU8_SLICE_TrapConfig+0x34>)
100025fa:	4013      	ands	r3, r2
  }

  slice->TC = tc;
100025fc:	6143      	str	r3, [r0, #20]
}
100025fe:	bd10      	pop	{r4, pc}
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
10002600:	4a04      	ldr	r2, [pc, #16]	; (10002614 <XMC_CCU8_SLICE_TrapConfig+0x38>)
10002602:	4013      	ands	r3, r2
  }

  /* Configure exit mode */
  if(exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)
10002604:	2901      	cmp	r1, #1
10002606:	d1f7      	bne.n	100025f8 <XMC_CCU8_SLICE_TrapConfig+0x1c>
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSW_Msk;
10002608:	2280      	movs	r2, #128	; 0x80
1000260a:	03d2      	lsls	r2, r2, #15
1000260c:	4313      	orrs	r3, r2
1000260e:	e7f5      	b.n	100025fc <XMC_CCU8_SLICE_TrapConfig+0x20>
10002610:	ffbfffff 	.word	0xffbfffff
10002614:	ffdfffff 	.word	0xffdfffff

10002618 <XMC_CCU8_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
10002618:	b5f0      	push	{r4, r5, r6, r7, lr}
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
1000261a:	1e4e      	subs	r6, r1, #1
1000261c:	b2f6      	uxtb	r6, r6

#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
1000261e:	0074      	lsls	r4, r6, #1
10002620:	b2e4      	uxtb	r4, r4
10002622:	1c25      	adds	r5, r4, #0
10002624:	3510      	adds	r5, #16
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
10002626:	b2ed      	uxtb	r5, r5

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
10002628:	4647      	mov	r7, r8
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
1000262a:	46ac      	mov	ip, r5

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
1000262c:	b480      	push	{r7}
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
1000262e:	2503      	movs	r5, #3
10002630:	4667      	mov	r7, ip
10002632:	46a8      	mov	r8, r5
10002634:	40bd      	lsls	r5, r7
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
10002636:	6803      	ldr	r3, [r0, #0]
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
10002638:	3115      	adds	r1, #21
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
1000263a:	43ab      	bics	r3, r5
  ins |= ((uint32_t) config->edge) << pos;
1000263c:	7855      	ldrb	r5, [r2, #1]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
1000263e:	b2c9      	uxtb	r1, r1
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
10002640:	40bd      	lsls	r5, r7
10002642:	432b      	orrs	r3, r5

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
10002644:	2501      	movs	r5, #1
10002646:	408d      	lsls	r5, r1
10002648:	43ab      	bics	r3, r5
  ins |= ((uint32_t) (config->level)) << pos;
1000264a:	7895      	ldrb	r5, [r2, #2]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
1000264c:	4647      	mov	r7, r8
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
1000264e:	408d      	lsls	r5, r1

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
10002650:	3419      	adds	r4, #25
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
10002652:	432b      	orrs	r3, r5

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
10002654:	78d5      	ldrb	r5, [r2, #3]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
10002656:	b2e4      	uxtb	r4, r4
10002658:	40a7      	lsls	r7, r4
  ins |= ((uint32_t) config->duration) << pos;
1000265a:	40a5      	lsls	r5, r4

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
1000265c:	240f      	movs	r4, #15
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
1000265e:	00b6      	lsls	r6, r6, #2
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
10002660:	b2f1      	uxtb	r1, r6
  ins |= ((uint32_t) config->mapped_input) << pos;
10002662:	7812      	ldrb	r2, [r2, #0]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
10002664:	408c      	lsls	r4, r1
  ins |= ((uint32_t) config->mapped_input) << pos;
10002666:	408a      	lsls	r2, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
10002668:	43bb      	bics	r3, r7
  ins |= ((uint32_t) config->duration) << pos;
1000266a:	432b      	orrs	r3, r5

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
1000266c:	43a3      	bics	r3, r4
  ins |= ((uint32_t) config->mapped_input) << pos;
1000266e:	4313      	orrs	r3, r2

  slice->INS = ins;
10002670:	6003      	str	r3, [r0, #0]
#endif
}
10002672:	bc04      	pop	{r2}
10002674:	4690      	mov	r8, r2
10002676:	bdf0      	pop	{r4, r5, r6, r7, pc}

10002678 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
10002678:	6341      	str	r1, [r0, #52]	; 0x34
}
1000267a:	4770      	bx	lr

1000267c <XMC_CCU8_SLICE_SetInterruptNode>:

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
1000267c:	23a8      	movs	r3, #168	; 0xa8

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
1000267e:	b530      	push	{r4, r5, lr}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
10002680:	58c5      	ldr	r5, [r0, r3]
10002682:	2909      	cmp	r1, #9
10002684:	d80b      	bhi.n	1000269e <XMC_CCU8_SLICE_SetInterruptNode+0x22>
10002686:	4b07      	ldr	r3, [pc, #28]	; (100026a4 <XMC_CCU8_SLICE_SetInterruptNode+0x28>)
10002688:	0089      	lsls	r1, r1, #2
1000268a:	58cc      	ldr	r4, [r1, r3]
1000268c:	43e3      	mvns	r3, r4
1000268e:	4c06      	ldr	r4, [pc, #24]	; (100026a8 <XMC_CCU8_SLICE_SetInterruptNode+0x2c>)
10002690:	5909      	ldr	r1, [r1, r4]
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
  srs |= (uint32_t)sr << pos;
10002692:	408a      	lsls	r2, r1
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
10002694:	402b      	ands	r3, r5
  srs |= (uint32_t)sr << pos;
10002696:	431a      	orrs	r2, r3
  
  slice->SRS = srs;
10002698:	23a8      	movs	r3, #168	; 0xa8
1000269a:	50c2      	str	r2, [r0, r3]
}
1000269c:	bd30      	pop	{r4, r5, pc}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
1000269e:	210c      	movs	r1, #12
100026a0:	4b02      	ldr	r3, [pc, #8]	; (100026ac <XMC_CCU8_SLICE_SetInterruptNode+0x30>)
100026a2:	e7f6      	b.n	10002692 <XMC_CCU8_SLICE_SetInterruptNode+0x16>
100026a4:	1000322c 	.word	0x1000322c
100026a8:	10003254 	.word	0x10003254
100026ac:	ffffcfff 	.word	0xffffcfff

100026b0 <XMC_CCU8_SLICE_DeadTimeInit>:
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
100026b0:	684b      	ldr	r3, [r1, #4]
100026b2:	6503      	str	r3, [r0, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
100026b4:	688b      	ldr	r3, [r1, #8]
100026b6:	6543      	str	r3, [r0, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
100026b8:	680b      	ldr	r3, [r1, #0]
100026ba:	64c3      	str	r3, [r0, #76]	; 0x4c
}
100026bc:	4770      	bx	lr
100026be:	46c0      	nop			; (mov r8, r8)

100026c0 <XMC_GPIO_SetMode>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
100026c0:	b510      	push	{r4, lr}
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
100026c2:	2403      	movs	r4, #3
100026c4:	088b      	lsrs	r3, r1, #2
100026c6:	4021      	ands	r1, r4
100026c8:	00c9      	lsls	r1, r1, #3
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
100026ca:	408a      	lsls	r2, r1
void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
100026cc:	34f5      	adds	r4, #245	; 0xf5
100026ce:	408c      	lsls	r4, r1
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
100026d0:	1c11      	adds	r1, r2, #0
100026d2:	009b      	lsls	r3, r3, #2
100026d4:	18c0      	adds	r0, r0, r3
void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
100026d6:	6903      	ldr	r3, [r0, #16]
100026d8:	43a3      	bics	r3, r4
100026da:	6103      	str	r3, [r0, #16]
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
100026dc:	6903      	ldr	r3, [r0, #16]
100026de:	4319      	orrs	r1, r3
100026e0:	6101      	str	r1, [r0, #16]
}
100026e2:	bd10      	pop	{r4, pc}

100026e4 <__aeabi_uidiv>:
 * API IMPLEMENTATION - aeabi routines
 **********************************************************************************************************************/
/* This function performs unsigned integer division */
uint32_t __aeabi_uidiv(uint32_t dividend, uint32_t divisor)
{
  MATH->DIVCON  = XMC_MATH_UNSIGNED_DIVISION;
100026e4:	2204      	movs	r2, #4
100026e6:	4b03      	ldr	r3, [pc, #12]	; (100026f4 <__aeabi_uidiv+0x10>)
100026e8:	635a      	str	r2, [r3, #52]	; 0x34
  MATH->DVD     = dividend;
100026ea:	6218      	str	r0, [r3, #32]
  MATH->DVS     = divisor;
100026ec:	6259      	str	r1, [r3, #36]	; 0x24

  return ((uint32_t) MATH->QUOT);
100026ee:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
100026f0:	4770      	bx	lr
100026f2:	46c0      	nop			; (mov r8, r8)
100026f4:	40030000 	.word	0x40030000

100026f8 <XMC_VADC_GLOBAL_Init>:
   * Please refer to the XMC1000 Errata sheet V1.4 released 2014-06 Errata ID : ADC_AI.003 Additonal bit to enable ADC
   * function
   */

#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
100026f8:	22ff      	movs	r2, #255	; 0xff
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
100026fa:	b538      	push	{r3, r4, r5, lr}
100026fc:	1c0d      	adds	r5, r1, #0
100026fe:	1c04      	adds	r4, r0, #0
   * Please refer to the XMC1000 Errata sheet V1.4 released 2014-06 Errata ID : ADC_AI.003 Additonal bit to enable ADC
   * function
   */

#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
10002700:	4b0d      	ldr	r3, [pc, #52]	; (10002738 <XMC_VADC_GLOBAL_Init+0x40>)
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
10002702:	2001      	movs	r0, #1
   * Please refer to the XMC1000 Errata sheet V1.4 released 2014-06 Errata ID : ADC_AI.003 Additonal bit to enable ADC
   * function
   */

#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
10002704:	601a      	str	r2, [r3, #0]
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
10002706:	f7ff fe5d 	bl	100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>
  XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();

  global_ptr->CLC = (uint32_t)(config->clc);
1000270a:	696b      	ldr	r3, [r5, #20]
1000270c:	6023      	str	r3, [r4, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
1000270e:	2380      	movs	r3, #128	; 0x80
10002710:	686a      	ldr	r2, [r5, #4]
10002712:	021b      	lsls	r3, r3, #8
10002714:	4313      	orrs	r3, r2
10002716:	2280      	movs	r2, #128	; 0x80
10002718:	50a3      	str	r3, [r4, r2]
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
1000271a:	23a0      	movs	r3, #160	; 0xa0
1000271c:	68aa      	ldr	r2, [r5, #8]
1000271e:	50e2      	str	r2, [r4, r3]

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
10002720:	68ea      	ldr	r2, [r5, #12]
10002722:	3304      	adds	r3, #4
10002724:	50e2      	str	r2, [r4, r3]


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
10002726:	692a      	ldr	r2, [r5, #16]
10002728:	33dd      	adds	r3, #221	; 0xdd
1000272a:	33ff      	adds	r3, #255	; 0xff
1000272c:	50e2      	str	r2, [r4, r3]

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
1000272e:	682a      	ldr	r2, [r5, #0]
10002730:	3bc9      	subs	r3, #201	; 0xc9
10002732:	3bff      	subs	r3, #255	; 0xff
10002734:	50e2      	str	r2, [r4, r3]

  /* From the Errata sheet of XMC1100 V1.7*/
  XMC_VADC_CONV_ENABLE_FOR_XMC11 = 1U;
#endif

}
10002736:	bd38      	pop	{r3, r4, r5, pc}
10002738:	40010500 	.word	0x40010500

1000273c <XMC_VADC_GLOBAL_StartupCalibration>:
  VADC_G_TypeDef *group_ptr;
#endif
  
  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
1000273c:	2380      	movs	r3, #128	; 0x80
1000273e:	2180      	movs	r1, #128	; 0x80
10002740:	58c2      	ldr	r2, [r0, r3]
10002742:	0609      	lsls	r1, r1, #24
10002744:	430a      	orrs	r2, r1
10002746:	50c2      	str	r2, [r0, r3]
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
10002748:	4a0c      	ldr	r2, [pc, #48]	; (1000277c <XMC_VADC_GLOBAL_StartupCalibration+0x40>)
1000274a:	58d1      	ldr	r1, [r2, r3]
1000274c:	23c0      	movs	r3, #192	; 0xc0
1000274e:	029b      	lsls	r3, r3, #10
10002750:	4219      	tst	r1, r3
10002752:	d005      	beq.n	10002760 <XMC_VADC_GLOBAL_StartupCalibration+0x24>
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
10002754:	2180      	movs	r1, #128	; 0x80
10002756:	2080      	movs	r0, #128	; 0x80
10002758:	0549      	lsls	r1, r1, #21
1000275a:	5813      	ldr	r3, [r2, r0]
1000275c:	420b      	tst	r3, r1
1000275e:	d1fc      	bne.n	1000275a <XMC_VADC_GLOBAL_StartupCalibration+0x1e>
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
10002760:	2380      	movs	r3, #128	; 0x80
10002762:	4a07      	ldr	r2, [pc, #28]	; (10002780 <XMC_VADC_GLOBAL_StartupCalibration+0x44>)
10002764:	58d1      	ldr	r1, [r2, r3]
10002766:	23c0      	movs	r3, #192	; 0xc0
10002768:	029b      	lsls	r3, r3, #10
1000276a:	4219      	tst	r1, r3
1000276c:	d005      	beq.n	1000277a <XMC_VADC_GLOBAL_StartupCalibration+0x3e>
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
1000276e:	2180      	movs	r1, #128	; 0x80
10002770:	2080      	movs	r0, #128	; 0x80
10002772:	0549      	lsls	r1, r1, #21
10002774:	5813      	ldr	r3, [r2, r0]
10002776:	420b      	tst	r3, r1
10002778:	d1fc      	bne.n	10002774 <XMC_VADC_GLOBAL_StartupCalibration+0x38>
  while( ( (SHS0->SHSCFG) & (uint32_t)SHS_SHSCFG_STATE_Msk) == XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    /* NOP */
  }
#endif
}
1000277a:	4770      	bx	lr
1000277c:	48030400 	.word	0x48030400
10002780:	48030800 	.word	0x48030800

10002784 <XMC_VADC_GROUP_Init>:
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
10002784:	23a0      	movs	r3, #160	; 0xa0
10002786:	58c2      	ldr	r2, [r0, r3]
10002788:	469c      	mov	ip, r3

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
1000278a:	4b30      	ldr	r3, [pc, #192]	; (1000284c <XMC_VADC_GROUP_Init+0xc8>)
}

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)  
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
1000278c:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
1000278e:	401a      	ands	r2, r3
10002790:	1c14      	adds	r4, r2, #0
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
10002792:	271f      	movs	r7, #31
10002794:	794a      	ldrb	r2, [r1, #5]

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
10002796:	4d2e      	ldr	r5, [pc, #184]	; (10002850 <XMC_VADC_GROUP_Init+0xcc>)
10002798:	0752      	lsls	r2, r2, #29
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
1000279a:	0d52      	lsrs	r2, r2, #21
1000279c:	4322      	orrs	r2, r4
1000279e:	790c      	ldrb	r4, [r1, #4]
  conv_class &= ~(sample_time_mask);
100027a0:	43ba      	bics	r2, r7
100027a2:	06e4      	lsls	r4, r4, #27
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
100027a4:	0ee4      	lsrs	r4, r4, #27

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
100027a6:	4322      	orrs	r2, r4
  group_ptr->ICLASS[set_num] = conv_class;
100027a8:	4664      	mov	r4, ip
100027aa:	5102      	str	r2, [r0, r4]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
100027ac:	5902      	ldr	r2, [r0, r4]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
100027ae:	4e29      	ldr	r6, [pc, #164]	; (10002854 <XMC_VADC_GROUP_Init+0xd0>)

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
100027b0:	402a      	ands	r2, r5
100027b2:	1c14      	adds	r4, r2, #0
100027b4:	79ca      	ldrb	r2, [r1, #7]
  group_ptr->BOUND = config->g_bound;

  /* External mux configuration */
  XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr,config->emux_config);

}
100027b6:	0752      	lsls	r2, r2, #29
  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
100027b8:	0952      	lsrs	r2, r2, #5
100027ba:	4322      	orrs	r2, r4
100027bc:	798c      	ldrb	r4, [r1, #6]
  conv_class &= ~(sample_time_mask);
100027be:	4032      	ands	r2, r6
100027c0:	06e4      	lsls	r4, r4, #27
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
100027c2:	0ae4      	lsrs	r4, r4, #11
100027c4:	4322      	orrs	r2, r4
  group_ptr->ICLASS[set_num] = conv_class;
100027c6:	4664      	mov	r4, ip
100027c8:	5102      	str	r2, [r0, r4]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
100027ca:	3404      	adds	r4, #4
100027cc:	5902      	ldr	r2, [r0, r4]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
100027ce:	401a      	ands	r2, r3
100027d0:	7a4b      	ldrb	r3, [r1, #9]
100027d2:	075b      	lsls	r3, r3, #29
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
100027d4:	0d5b      	lsrs	r3, r3, #21
100027d6:	4313      	orrs	r3, r2
100027d8:	7a0a      	ldrb	r2, [r1, #8]
  conv_class &= ~(sample_time_mask);
100027da:	43bb      	bics	r3, r7
100027dc:	06d2      	lsls	r2, r2, #27
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
100027de:	0ed2      	lsrs	r2, r2, #27

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
100027e0:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
100027e2:	5103      	str	r3, [r0, r4]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
100027e4:	5903      	ldr	r3, [r0, r4]
100027e6:	7a8a      	ldrb	r2, [r1, #10]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
100027e8:	401d      	ands	r5, r3
100027ea:	7acb      	ldrb	r3, [r1, #11]
100027ec:	06d2      	lsls	r2, r2, #27
100027ee:	075b      	lsls	r3, r3, #29
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
100027f0:	095b      	lsrs	r3, r3, #5
100027f2:	432b      	orrs	r3, r5
  conv_class &= ~(sample_time_mask);
100027f4:	4033      	ands	r3, r6
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
100027f6:	0ad2      	lsrs	r2, r2, #11
100027f8:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
100027fa:	5103      	str	r3, [r0, r4]
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);

  group_ptr->ARBCFG = config->g_arbcfg;
100027fc:	2380      	movs	r3, #128	; 0x80
100027fe:	690a      	ldr	r2, [r1, #16]
10002800:	50c2      	str	r2, [r0, r3]

  group_ptr->BOUND = config->g_bound;
10002802:	68ca      	ldr	r2, [r1, #12]
10002804:	3338      	adds	r3, #56	; 0x38
10002806:	50c2      	str	r2, [r0, r3]
10002808:	78cb      	ldrb	r3, [r1, #3]
1000280a:	071d      	lsls	r5, r3, #28
1000280c:	06df      	lsls	r7, r3, #27
1000280e:	069c      	lsls	r4, r3, #26
10002810:	065b      	lsls	r3, r3, #25
10002812:	0fda      	lsrs	r2, r3, #31
10002814:	884b      	ldrh	r3, [r1, #2]
10002816:	0fff      	lsrs	r7, r7, #31
10002818:	059b      	lsls	r3, r3, #22
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
1000281a:	099e      	lsrs	r6, r3, #6
1000281c:	780b      	ldrb	r3, [r1, #0]
1000281e:	2180      	movs	r1, #128	; 0x80
10002820:	075b      	lsls	r3, r3, #29
{
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
10002822:	0f5b      	lsrs	r3, r3, #29
10002824:	4333      	orrs	r3, r6
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
10002826:	26f8      	movs	r6, #248	; 0xf8
10002828:	0076      	lsls	r6, r6, #1
1000282a:	5183      	str	r3, [r0, r6]
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
1000282c:	5983      	ldr	r3, [r0, r6]
1000282e:	0609      	lsls	r1, r1, #24

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
10002830:	073f      	lsls	r7, r7, #28
10002832:	430b      	orrs	r3, r1
10002834:	0fad      	lsrs	r5, r5, #30
10002836:	433b      	orrs	r3, r7
                ((uint32_t)emux_cfg.emux_mode  << (uint32_t)VADC_G_EMUXCTR_EMUXMODE_Pos)|
10002838:	06ad      	lsls	r5, r5, #26
1000283a:	0fe4      	lsrs	r4, r4, #31
1000283c:	432b      	orrs	r3, r5
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);
1000283e:	0764      	lsls	r4, r4, #29
10002840:	4323      	orrs	r3, r4
10002842:	1c19      	adds	r1, r3, #0

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
10002844:	0793      	lsls	r3, r2, #30
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
10002846:	430b      	orrs	r3, r1
10002848:	5183      	str	r3, [r0, r6]

  /* External mux configuration */
  XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr,config->emux_config);

}
1000284a:	bdf0      	pop	{r4, r5, r6, r7, pc}
1000284c:	fffff8ff 	.word	0xfffff8ff
10002850:	f8ffffff 	.word	0xf8ffffff
10002854:	ffe0ffff 	.word	0xffe0ffff

10002858 <XMC_VADC_GROUP_SetPowerMode>:
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
10002858:	2280      	movs	r2, #128	; 0x80
  group_ptr->ICLASS[set_num] = conv_class;
}

/* API which sets the power mode of analog converter of a VADC group */
void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_t power_mode)
{
1000285a:	b510      	push	{r4, lr}
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
1000285c:	2403      	movs	r4, #3
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
1000285e:	5883      	ldr	r3, [r0, r2]

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
10002860:	43a3      	bics	r3, r4
  arbcfg |= (uint32_t)power_mode;
10002862:	4319      	orrs	r1, r3

  group_ptr->ARBCFG = arbcfg;
10002864:	5081      	str	r1, [r0, r2]
}
10002866:	bd10      	pop	{r4, pc}

10002868 <XMC_VADC_GROUP_SetSyncSlave>:
  #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )

  /* Determine the coding of SYNCTR */
  if (slave_grp > master_grp)
  {
    master_grp = master_grp + 1U;
10002868:	4291      	cmp	r1, r2
1000286a:	4192      	sbcs	r2, r2
1000286c:	4252      	negs	r2, r2
1000286e:	1889      	adds	r1, r1, r2
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
10002870:	22c0      	movs	r2, #192	; 0xc0
  group_ptr->ARBCFG = arbcfg;
}

/* API which programs a group as a slave group during sync conversions */
void XMC_VADC_GROUP_SetSyncSlave(XMC_VADC_GROUP_t *const group_ptr, uint32_t master_grp, uint32_t slave_grp)
{
10002872:	b510      	push	{r4, lr}
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
10002874:	2403      	movs	r4, #3
    master_grp = master_grp + 1U;
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
10002876:	5883      	ldr	r3, [r0, r2]
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
10002878:	43a3      	bics	r3, r4
  synctr   |= master_grp;
1000287a:	4319      	orrs	r1, r3
  group_ptr->SYNCTR = synctr;
1000287c:	5081      	str	r1, [r0, r2]
}
1000287e:	bd10      	pop	{r4, pc}

10002880 <XMC_VADC_GROUP_SetSyncMaster>:
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
10002880:	22c0      	movs	r2, #192	; 0xc0
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
10002882:	2103      	movs	r1, #3
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
10002884:	5883      	ldr	r3, [r0, r2]
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
10002886:	438b      	bics	r3, r1
  group_ptr->SYNCTR = synctr;
10002888:	5083      	str	r3, [r0, r2]
}
1000288a:	4770      	bx	lr

1000288c <XMC_VADC_GROUP_CheckSlaveReadiness>:
    ready_pos = (uint8_t)VADC_G_SYNCTR_EVALR3_Pos;
  }

  group_ptr->SYNCTR |= (uint32_t)((uint32_t)1 << ready_pos);
#else
  group_ptr->SYNCTR |= ((uint32_t)VADC_G_SYNCTR_EVALR1_Msk);
1000288c:	22c0      	movs	r2, #192	; 0xc0
1000288e:	2310      	movs	r3, #16
10002890:	5881      	ldr	r1, [r0, r2]
10002892:	430b      	orrs	r3, r1
10002894:	5083      	str	r3, [r0, r2]
#endif
}
10002896:	4770      	bx	lr

10002898 <XMC_VADC_GLOBAL_SHS_SetGainFactor>:
/* API to set the gain factor of the Sample and hold module*/
void XMC_VADC_GLOBAL_SHS_SetGainFactor(XMC_VADC_GLOBAL_SHS_t *const shs_ptr,
                                       uint8_t gain_value,
                                       XMC_VADC_GROUP_INDEX_t group_num,
                                       uint8_t ch_num)
{
10002898:	b530      	push	{r4, r5, lr}

  XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetGainFactor:Wrong SHS Pointer", (shs_ptr == (XMC_VADC_GLOBAL_SHS_t*)(void*)SHS0))
  XMC_ASSERT("XMC_VADC_GLOBAL_SHS_SetGainFactor:Wrong Index number",(group_num <= XMC_VADC_GROUP_INDEX_1))

  /*Calculate location of channel bit-field*/
  ch_mask = ((uint32_t)ch_num << (uint32_t)2);
1000289a:	009b      	lsls	r3, r3, #2
  if (group_num == XMC_VADC_GROUP_INDEX_0 )
1000289c:	2a00      	cmp	r2, #0
1000289e:	d00f      	beq.n	100028c0 <XMC_VADC_GLOBAL_SHS_SetGainFactor+0x28>
  {
    shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
    shs_ptr->GNCTR00 |=  ((uint32_t)gain_value << ch_mask);
  }
  else if (group_num == XMC_VADC_GROUP_INDEX_1 )
100028a0:	2a01      	cmp	r2, #1
100028a2:	d000      	beq.n	100028a6 <XMC_VADC_GLOBAL_SHS_SetGainFactor+0xe>
  }
  else
  {
    /* for MISRA*/
  }
}
100028a4:	bd30      	pop	{r4, r5, pc}
    shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
    shs_ptr->GNCTR00 |=  ((uint32_t)gain_value << ch_mask);
  }
  else if (group_num == XMC_VADC_GROUP_INDEX_1 )
  {
    shs_ptr->GNCTR10 &= ~((uint32_t)SHS_GNCTR10_GAIN0_Msk << ch_mask);
100028a6:	3290      	adds	r2, #144	; 0x90
100028a8:	250f      	movs	r5, #15
    shs_ptr->GNCTR10 |=  ((uint32_t)gain_value << ch_mask);
100028aa:	4099      	lsls	r1, r3
    shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
    shs_ptr->GNCTR00 |=  ((uint32_t)gain_value << ch_mask);
  }
  else if (group_num == XMC_VADC_GROUP_INDEX_1 )
  {
    shs_ptr->GNCTR10 &= ~((uint32_t)SHS_GNCTR10_GAIN0_Msk << ch_mask);
100028ac:	409d      	lsls	r5, r3
    shs_ptr->GNCTR10 |=  ((uint32_t)gain_value << ch_mask);
100028ae:	1c0b      	adds	r3, r1, #0
    shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
    shs_ptr->GNCTR00 |=  ((uint32_t)gain_value << ch_mask);
  }
  else if (group_num == XMC_VADC_GROUP_INDEX_1 )
  {
    shs_ptr->GNCTR10 &= ~((uint32_t)SHS_GNCTR10_GAIN0_Msk << ch_mask);
100028b0:	32ff      	adds	r2, #255	; 0xff
100028b2:	5884      	ldr	r4, [r0, r2]
100028b4:	43ac      	bics	r4, r5
100028b6:	5084      	str	r4, [r0, r2]
    shs_ptr->GNCTR10 |=  ((uint32_t)gain_value << ch_mask);
100028b8:	5884      	ldr	r4, [r0, r2]
100028ba:	4323      	orrs	r3, r4
100028bc:	5083      	str	r3, [r0, r2]
100028be:	e7f1      	b.n	100028a4 <XMC_VADC_GLOBAL_SHS_SetGainFactor+0xc>

  /*Calculate location of channel bit-field*/
  ch_mask = ((uint32_t)ch_num << (uint32_t)2);
  if (group_num == XMC_VADC_GROUP_INDEX_0 )
  {
    shs_ptr->GNCTR00 &= ~((uint32_t)SHS_GNCTR00_GAIN0_Msk << ch_mask) ;
100028c0:	3281      	adds	r2, #129	; 0x81
100028c2:	e7f1      	b.n	100028a8 <XMC_VADC_GLOBAL_SHS_SetGainFactor+0x10>

100028c4 <XMC_VADC_GROUP_QueueInit>:
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)  
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
100028c4:	b570      	push	{r4, r5, r6, lr}
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
100028c6:	2584      	movs	r5, #132	; 0x84
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
100028c8:	2603      	movs	r6, #3
100028ca:	5942      	ldr	r2, [r0, r5]
100028cc:	4b1b      	ldr	r3, [pc, #108]	; (1000293c <XMC_VADC_GROUP_QueueInit+0x78>)
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
100028ce:	780c      	ldrb	r4, [r1, #0]
100028d0:	4013      	ands	r3, r2
100028d2:	5143      	str	r3, [r0, r5]
  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;
100028d4:	5943      	ldr	r3, [r0, r5]

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
100028d6:	43b3      	bics	r3, r6
100028d8:	1c1a      	adds	r2, r3, #0
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
100028da:	0723      	lsls	r3, r4, #28
100028dc:	0f9b      	lsrs	r3, r3, #30
100028de:	4313      	orrs	r3, r2

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
100028e0:	4034      	ands	r4, r6
100028e2:	d01c      	beq.n	1000291e <XMC_VADC_GROUP_QueueInit+0x5a>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
100028e4:	2208      	movs	r2, #8
100028e6:	4313      	orrs	r3, r2
  }

  group_ptr->ARBPR = reg;
100028e8:	5143      	str	r3, [r0, r5]


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
100028ea:	684a      	ldr	r2, [r1, #4]
100028ec:	4b14      	ldr	r3, [pc, #80]	; (10002940 <XMC_VADC_GROUP_QueueInit+0x7c>)
100028ee:	4313      	orrs	r3, r2
100028f0:	2280      	movs	r2, #128	; 0x80
100028f2:	0052      	lsls	r2, r2, #1
100028f4:	5083      	str	r3, [r0, r2]
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
100028f6:	688b      	ldr	r3, [r1, #8]
100028f8:	3aff      	subs	r2, #255	; 0xff
100028fa:	4313      	orrs	r3, r2
100028fc:	3204      	adds	r2, #4
100028fe:	32ff      	adds	r2, #255	; 0xff
10002900:	5083      	str	r3, [r0, r2]

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
10002902:	2c02      	cmp	r4, #2
10002904:	d104      	bne.n	10002910 <XMC_VADC_GROUP_QueueInit+0x4c>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
10002906:	2180      	movs	r1, #128	; 0x80
10002908:	5883      	ldr	r3, [r0, r2]
1000290a:	0249      	lsls	r1, r1, #9
1000290c:	430b      	orrs	r3, r1
1000290e:	5083      	str	r3, [r0, r2]
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
10002910:	2284      	movs	r2, #132	; 0x84
10002912:	2180      	movs	r1, #128	; 0x80
10002914:	5883      	ldr	r3, [r0, r2]
10002916:	0449      	lsls	r1, r1, #17
10002918:	430b      	orrs	r3, r1
1000291a:	5083      	str	r3, [r0, r2]
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);

}
1000291c:	bd70      	pop	{r4, r5, r6, pc}
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
  }

  group_ptr->ARBPR = reg;
1000291e:	5143      	str	r3, [r0, r5]


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
10002920:	684a      	ldr	r2, [r1, #4]
10002922:	4b07      	ldr	r3, [pc, #28]	; (10002940 <XMC_VADC_GROUP_QueueInit+0x7c>)
10002924:	4313      	orrs	r3, r2
10002926:	2280      	movs	r2, #128	; 0x80
10002928:	0052      	lsls	r2, r2, #1
1000292a:	5083      	str	r3, [r0, r2]
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
1000292c:	688b      	ldr	r3, [r1, #8]
1000292e:	3aff      	subs	r2, #255	; 0xff
10002930:	4313      	orrs	r3, r2
10002932:	3204      	adds	r2, #4
10002934:	32ff      	adds	r2, #255	; 0xff
10002936:	5083      	str	r3, [r0, r2]
10002938:	e7ea      	b.n	10002910 <XMC_VADC_GROUP_QueueInit+0x4c>
1000293a:	46c0      	nop			; (mov r8, r8)
1000293c:	feffffff 	.word	0xfeffffff
10002940:	80808000 	.word	0x80808000

10002944 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                        const XMC_VADC_CHANNEL_CONFIG_t *config)
{
10002944:	b570      	push	{r4, r5, r6, lr}
  
  prio  = (uint32_t)config->channel_priority;

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
10002946:	2401      	movs	r4, #1
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
10002948:	2588      	movs	r5, #136	; 0x88
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
1000294a:	408c      	lsls	r4, r1
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
1000294c:	5943      	ldr	r3, [r0, r5]
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
1000294e:	43a3      	bics	r3, r4


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;
10002950:	7b14      	ldrb	r4, [r2, #12]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
  ch_assign |= (uint32_t)(prio << ch_num);
10002952:	408c      	lsls	r4, r1
10002954:	4323      	orrs	r3, r4
  group_ptr->CHASS = ch_assign;
10002956:	5143      	str	r3, [r0, r5]

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
10002958:	7b53      	ldrb	r3, [r2, #13]
1000295a:	b25c      	sxtb	r4, r3
1000295c:	2c00      	cmp	r4, #0
1000295e:	db0c      	blt.n	1000297a <XMC_VADC_GROUP_ChannelInit+0x36>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
10002960:	2901      	cmp	r1, #1
10002962:	d021      	beq.n	100029a8 <XMC_VADC_GROUP_ChannelInit+0x64>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
10002964:	2900      	cmp	r1, #0
10002966:	d017      	beq.n	10002998 <XMC_VADC_GROUP_ChannelInit+0x54>
10002968:	1c1c      	adds	r4, r3, #0
1000296a:	2300      	movs	r3, #0
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
1000296c:	b264      	sxtb	r4, r4
1000296e:	409c      	lsls	r4, r3
10002970:	26b0      	movs	r6, #176	; 0xb0
10002972:	1c23      	adds	r3, r4, #0
10002974:	5985      	ldr	r5, [r0, r6]
10002976:	432b      	orrs	r3, r5
10002978:	5183      	str	r3, [r0, r6]
  }

  group_ptr->BFL |= config->bfl;
1000297a:	24c8      	movs	r4, #200	; 0xc8
1000297c:	6855      	ldr	r5, [r2, #4]
1000297e:	5903      	ldr	r3, [r0, r4]

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
10002980:	3180      	adds	r1, #128	; 0x80
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
  }

  group_ptr->BFL |= config->bfl;
10002982:	432b      	orrs	r3, r5
10002984:	5103      	str	r3, [r0, r4]

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
10002986:	3408      	adds	r4, #8
10002988:	6895      	ldr	r5, [r2, #8]
1000298a:	5903      	ldr	r3, [r0, r4]
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
1000298c:	0089      	lsls	r1, r1, #2
  }

  group_ptr->BFL |= config->bfl;

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
1000298e:	432b      	orrs	r3, r5
10002990:	5103      	str	r3, [r0, r4]
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
10002992:	6813      	ldr	r3, [r2, #0]
10002994:	500b      	str	r3, [r1, r0]

}
10002996:	bd70      	pop	{r4, r5, r6, pc}
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
10002998:	24b0      	movs	r4, #176	; 0xb0
1000299a:	251f      	movs	r5, #31
1000299c:	5903      	ldr	r3, [r0, r4]
1000299e:	43ab      	bics	r3, r5
100029a0:	5103      	str	r3, [r0, r4]
100029a2:	7b54      	ldrb	r4, [r2, #13]
100029a4:	2300      	movs	r3, #0
100029a6:	e7e1      	b.n	1000296c <XMC_VADC_GROUP_ChannelInit+0x28>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
100029a8:	24b0      	movs	r4, #176	; 0xb0
100029aa:	4b03      	ldr	r3, [pc, #12]	; (100029b8 <XMC_VADC_GROUP_ChannelInit+0x74>)
100029ac:	5905      	ldr	r5, [r0, r4]
100029ae:	402b      	ands	r3, r5
100029b0:	5103      	str	r3, [r0, r4]
100029b2:	7b54      	ldrb	r4, [r2, #13]
100029b4:	2308      	movs	r3, #8
100029b6:	e7d9      	b.n	1000296c <XMC_VADC_GROUP_ChannelInit+0x28>
100029b8:	ffffe0ff 	.word	0xffffe0ff

100029bc <XMC_WDT_Init>:
  XMC_SCU_CLOCK_DisableClock(XMC_SCU_CLOCK_WDT);
#endif
}
/* Initializes and configures watchdog with configuration data pointed by \a config. */
void XMC_WDT_Init(const XMC_WDT_CONFIG_t *const config)
{
100029bc:	b510      	push	{r4, lr}
100029be:	1c04      	adds	r4, r0, #0
#if UC_FAMILY == XMC4
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_WDT);
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_WDT);
100029c0:	2080      	movs	r0, #128	; 0x80
100029c2:	0080      	lsls	r0, r0, #2
100029c4:	f7ff fcfe 	bl	100023c4 <XMC_SCU_CLOCK_UngatePeripheralClock>
}
/* Initializes and configures watchdog with configuration data pointed by \a config. */
void XMC_WDT_Init(const XMC_WDT_CONFIG_t *const config)
{
  XMC_WDT_Enable();
  WDT->CTR = config->wdt_ctr;
100029c8:	68a2      	ldr	r2, [r4, #8]
100029ca:	4b03      	ldr	r3, [pc, #12]	; (100029d8 <XMC_WDT_Init+0x1c>)
100029cc:	605a      	str	r2, [r3, #4]
  WDT->WLB = config->window_lower_bound;
100029ce:	6862      	ldr	r2, [r4, #4]
100029d0:	611a      	str	r2, [r3, #16]
  WDT->WUB = config->window_upper_bound;
100029d2:	6822      	ldr	r2, [r4, #0]
100029d4:	615a      	str	r2, [r3, #20]
}
100029d6:	bd10      	pop	{r4, pc}
100029d8:	40020000 	.word	0x40020000

100029dc <_init>:
 while(1){}
}

/* Init */
__attribute__((weak)) void _init(void)
{}
100029dc:	4770      	bx	lr
100029de:	46c0      	nop			; (mov r8, r8)

100029e0 <main>:
{

#if(uCPROBE_GUI == ENABLED)
  uint32_t * MotorCONF_Addr = MotorConfig_Addr;

  if ((*MotorCONF_Addr)!= PARAM_HEADER)
100029e0:	4825      	ldr	r0, [pc, #148]	; (10002a78 <main+0x98>)
100029e2:	4b26      	ldr	r3, [pc, #152]	; (10002a7c <main+0x9c>)
100029e4:	6802      	ldr	r2, [r0, #0]

extern void PMSM_FOC_Init (void);


int main(void)
{
100029e6:	b510      	push	{r4, lr}

#if(uCPROBE_GUI == ENABLED)
  uint32_t * MotorCONF_Addr = MotorConfig_Addr;

  if ((*MotorCONF_Addr)!= PARAM_HEADER)
100029e8:	429a      	cmp	r2, r3
100029ea:	d025      	beq.n	10002a38 <main+0x58>
  {
    uint32_t *MotorCONF_Address = MotorConfig_Addr;
    uint32_t *UserConfig_Address ;

    User_Para[0] = PARAM_HEADER;
100029ec:	4924      	ldr	r1, [pc, #144]	; (10002a80 <main+0xa0>)
    User_Para[1] = USER_PI_SPEED_KP;
    User_Para[2] = USER_PI_SPEED_KI;
    User_Para[3] = USER_PI_SPEED_SCALE_KPKI;
    User_Para[4] = USER_PI_TORQUE_KP;
    User_Para[5] = USER_PI_TORQUE_KI;
100029ee:	4a25      	ldr	r2, [pc, #148]	; (10002a84 <main+0xa4>)
  if ((*MotorCONF_Addr)!= PARAM_HEADER)
  {
    uint32_t *MotorCONF_Address = MotorConfig_Addr;
    uint32_t *UserConfig_Address ;

    User_Para[0] = PARAM_HEADER;
100029f0:	600b      	str	r3, [r1, #0]
    User_Para[1] = USER_PI_SPEED_KP;
100029f2:	4b25      	ldr	r3, [pc, #148]	; (10002a88 <main+0xa8>)
    User_Para[2] = USER_PI_SPEED_KI;
    User_Para[3] = USER_PI_SPEED_SCALE_KPKI;
    User_Para[4] = USER_PI_TORQUE_KP;
100029f4:	4c25      	ldr	r4, [pc, #148]	; (10002a8c <main+0xac>)
  {
    uint32_t *MotorCONF_Address = MotorConfig_Addr;
    uint32_t *UserConfig_Address ;

    User_Para[0] = PARAM_HEADER;
    User_Para[1] = USER_PI_SPEED_KP;
100029f6:	604b      	str	r3, [r1, #4]
    User_Para[2] = USER_PI_SPEED_KI;
100029f8:	2308      	movs	r3, #8
100029fa:	608b      	str	r3, [r1, #8]
    User_Para[3] = USER_PI_SPEED_SCALE_KPKI;
100029fc:	3307      	adds	r3, #7
100029fe:	60cb      	str	r3, [r1, #12]
    User_Para[4] = USER_PI_TORQUE_KP;
    User_Para[5] = USER_PI_TORQUE_KI;
    User_Para[6] = USER_PI_TORQUE_SCALE_KPKI;
10002a00:	3302      	adds	r3, #2
10002a02:	618b      	str	r3, [r1, #24]
    User_Para[7] = USER_PI_FLUX_KP;
    User_Para[8] = USER_PI_FLUX_KI;
    User_Para[9] = USER_PI_FLUX_SCALE_KPKI;
10002a04:	624b      	str	r3, [r1, #36]	; 0x24
    User_Para[10] = USER_PI_PLL_KP;
10002a06:	33b8      	adds	r3, #184	; 0xb8
10002a08:	33ff      	adds	r3, #255	; 0xff
10002a0a:	628b      	str	r3, [r1, #40]	; 0x28
    User_Para[11] = USER_PI_PLL_KI;
10002a0c:	3baf      	subs	r3, #175	; 0xaf
10002a0e:	3bff      	subs	r3, #255	; 0xff
10002a10:	62cb      	str	r3, [r1, #44]	; 0x2c
    User_Para[12] = USER_PI_PLL_SCALE_KPKI;
10002a12:	3b0a      	subs	r3, #10
10002a14:	630b      	str	r3, [r1, #48]	; 0x30
    User_Para[13] = USER_RES_INC;
10002a16:	3b0d      	subs	r3, #13

    User_Para[0] = PARAM_HEADER;
    User_Para[1] = USER_PI_SPEED_KP;
    User_Para[2] = USER_PI_SPEED_KI;
    User_Para[3] = USER_PI_SPEED_SCALE_KPKI;
    User_Para[4] = USER_PI_TORQUE_KP;
10002a18:	610c      	str	r4, [r1, #16]
    User_Para[5] = USER_PI_TORQUE_KI;
10002a1a:	614a      	str	r2, [r1, #20]
    User_Para[6] = USER_PI_TORQUE_SCALE_KPKI;
    User_Para[7] = USER_PI_FLUX_KP;
10002a1c:	61cc      	str	r4, [r1, #28]
    User_Para[8] = USER_PI_FLUX_KI;
10002a1e:	620a      	str	r2, [r1, #32]
    User_Para[9] = USER_PI_FLUX_SCALE_KPKI;
    User_Para[10] = USER_PI_PLL_KP;
    User_Para[11] = USER_PI_PLL_KI;
    User_Para[12] = USER_PI_PLL_SCALE_KPKI;
    User_Para[13] = USER_RES_INC;
10002a20:	634b      	str	r3, [r1, #52]	; 0x34

    UserConfig_Address = &User_Para[0];
    XMC_FLASH_ProgramVerifyPage(MotorCONF_Address,UserConfig_Address);
10002a22:	f7ff fc87 	bl	10002334 <XMC_FLASH_ProgramVerifyPage>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
10002a26:	f3bf 8f4f 	dsb	sy
10002a2a:	4a19      	ldr	r2, [pc, #100]	; (10002a90 <main+0xb0>)
10002a2c:	4b19      	ldr	r3, [pc, #100]	; (10002a94 <main+0xb4>)
10002a2e:	60da      	str	r2, [r3, #12]
10002a30:	f3bf 8f4f 	dsb	sy

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
10002a34:	46c0      	nop			; (mov r8, r8)
10002a36:	e7fd      	b.n	10002a34 <main+0x54>
    NVIC_SystemReset();
  }
  else
  {
    User_Para[0] = *MotorCONF_Addr;
10002a38:	4b11      	ldr	r3, [pc, #68]	; (10002a80 <main+0xa0>)
10002a3a:	601a      	str	r2, [r3, #0]
    User_Para[1] = *(MotorCONF_Addr+1);
10002a3c:	6842      	ldr	r2, [r0, #4]
10002a3e:	605a      	str	r2, [r3, #4]
    User_Para[2] = *(MotorCONF_Addr+2);
10002a40:	6882      	ldr	r2, [r0, #8]
10002a42:	609a      	str	r2, [r3, #8]
    User_Para[3] = *(MotorCONF_Addr+3);
10002a44:	68c2      	ldr	r2, [r0, #12]
10002a46:	60da      	str	r2, [r3, #12]
    User_Para[4] = *(MotorCONF_Addr+4);
10002a48:	6902      	ldr	r2, [r0, #16]
10002a4a:	611a      	str	r2, [r3, #16]
    User_Para[5] = *(MotorCONF_Addr+5);
10002a4c:	6942      	ldr	r2, [r0, #20]
10002a4e:	615a      	str	r2, [r3, #20]
    User_Para[6] = *(MotorCONF_Addr+6);
10002a50:	6982      	ldr	r2, [r0, #24]
10002a52:	619a      	str	r2, [r3, #24]
    User_Para[7] = *(MotorCONF_Addr+7);
10002a54:	69c2      	ldr	r2, [r0, #28]
10002a56:	61da      	str	r2, [r3, #28]
    User_Para[8] = *(MotorCONF_Addr+8);
10002a58:	6a02      	ldr	r2, [r0, #32]
10002a5a:	621a      	str	r2, [r3, #32]
    User_Para[9] = *(MotorCONF_Addr+9);
10002a5c:	6a42      	ldr	r2, [r0, #36]	; 0x24
10002a5e:	625a      	str	r2, [r3, #36]	; 0x24
    User_Para[10] = *(MotorCONF_Addr+10);
10002a60:	6a82      	ldr	r2, [r0, #40]	; 0x28
10002a62:	629a      	str	r2, [r3, #40]	; 0x28
    User_Para[11] = *(MotorCONF_Addr+11);
10002a64:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
10002a66:	62da      	str	r2, [r3, #44]	; 0x2c
    User_Para[12] = *(MotorCONF_Addr+12);
    User_Para[12] = *(MotorCONF_Addr+12);
10002a68:	6b02      	ldr	r2, [r0, #48]	; 0x30
10002a6a:	631a      	str	r2, [r3, #48]	; 0x30
    User_Para[13] = *(MotorCONF_Addr+13);
10002a6c:	6b42      	ldr	r2, [r0, #52]	; 0x34
10002a6e:	635a      	str	r2, [r3, #52]	; 0x34
  }
#endif


	PMSM_FOC_Init ();
10002a70:	f7fe ff6e 	bl	10001950 <PMSM_FOC_Init>
	 /* MCU main loop. Actually only require the processor to run when an interrupt occurs. */
	{



	}
10002a74:	e7fe      	b.n	10002a74 <main+0x94>
10002a76:	46c0      	nop			; (mov r8, r8)
10002a78:	10006800 	.word	0x10006800
10002a7c:	00001012 	.word	0x00001012
10002a80:	200012a8 	.word	0x200012a8
10002a84:	00005d79 	.word	0x00005d79
10002a88:	00007fff 	.word	0x00007fff
10002a8c:	00007d71 	.word	0x00007d71
10002a90:	05fa0004 	.word	0x05fa0004
10002a94:	e000ed00 	.word	0xe000ed00

10002a98 <__aeabi_cfrcmple>:
10002a98:	4684      	mov	ip, r0
10002a9a:	1c08      	adds	r0, r1, #0
10002a9c:	4661      	mov	r1, ip
10002a9e:	e7ff      	b.n	10002aa0 <__aeabi_cfcmpeq>

10002aa0 <__aeabi_cfcmpeq>:
10002aa0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
10002aa2:	f000 f8a7 	bl	10002bf4 <__lesf2>
10002aa6:	2800      	cmp	r0, #0
10002aa8:	d401      	bmi.n	10002aae <__aeabi_cfcmpeq+0xe>
10002aaa:	2100      	movs	r1, #0
10002aac:	42c8      	cmn	r0, r1
10002aae:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

10002ab0 <__aeabi_fcmpeq>:
10002ab0:	b510      	push	{r4, lr}
10002ab2:	f000 f82b 	bl	10002b0c <__eqsf2>
10002ab6:	4240      	negs	r0, r0
10002ab8:	3001      	adds	r0, #1
10002aba:	bd10      	pop	{r4, pc}

10002abc <__aeabi_fcmplt>:
10002abc:	b510      	push	{r4, lr}
10002abe:	f000 f899 	bl	10002bf4 <__lesf2>
10002ac2:	2800      	cmp	r0, #0
10002ac4:	db01      	blt.n	10002aca <__aeabi_fcmplt+0xe>
10002ac6:	2000      	movs	r0, #0
10002ac8:	bd10      	pop	{r4, pc}
10002aca:	2001      	movs	r0, #1
10002acc:	bd10      	pop	{r4, pc}
10002ace:	46c0      	nop			; (mov r8, r8)

10002ad0 <__aeabi_fcmple>:
10002ad0:	b510      	push	{r4, lr}
10002ad2:	f000 f88f 	bl	10002bf4 <__lesf2>
10002ad6:	2800      	cmp	r0, #0
10002ad8:	dd01      	ble.n	10002ade <__aeabi_fcmple+0xe>
10002ada:	2000      	movs	r0, #0
10002adc:	bd10      	pop	{r4, pc}
10002ade:	2001      	movs	r0, #1
10002ae0:	bd10      	pop	{r4, pc}
10002ae2:	46c0      	nop			; (mov r8, r8)

10002ae4 <__aeabi_fcmpgt>:
10002ae4:	b510      	push	{r4, lr}
10002ae6:	f000 f83b 	bl	10002b60 <__gesf2>
10002aea:	2800      	cmp	r0, #0
10002aec:	dc01      	bgt.n	10002af2 <__aeabi_fcmpgt+0xe>
10002aee:	2000      	movs	r0, #0
10002af0:	bd10      	pop	{r4, pc}
10002af2:	2001      	movs	r0, #1
10002af4:	bd10      	pop	{r4, pc}
10002af6:	46c0      	nop			; (mov r8, r8)

10002af8 <__aeabi_fcmpge>:
10002af8:	b510      	push	{r4, lr}
10002afa:	f000 f831 	bl	10002b60 <__gesf2>
10002afe:	2800      	cmp	r0, #0
10002b00:	da01      	bge.n	10002b06 <__aeabi_fcmpge+0xe>
10002b02:	2000      	movs	r0, #0
10002b04:	bd10      	pop	{r4, pc}
10002b06:	2001      	movs	r0, #1
10002b08:	bd10      	pop	{r4, pc}
10002b0a:	46c0      	nop			; (mov r8, r8)

10002b0c <__eqsf2>:
10002b0c:	0243      	lsls	r3, r0, #9
10002b0e:	b570      	push	{r4, r5, r6, lr}
10002b10:	0042      	lsls	r2, r0, #1
10002b12:	004c      	lsls	r4, r1, #1
10002b14:	0a5d      	lsrs	r5, r3, #9
10002b16:	0fc3      	lsrs	r3, r0, #31
10002b18:	0248      	lsls	r0, r1, #9
10002b1a:	0e12      	lsrs	r2, r2, #24
10002b1c:	0a46      	lsrs	r6, r0, #9
10002b1e:	0e24      	lsrs	r4, r4, #24
10002b20:	0fc9      	lsrs	r1, r1, #31
10002b22:	2aff      	cmp	r2, #255	; 0xff
10002b24:	d005      	beq.n	10002b32 <__eqsf2+0x26>
10002b26:	2cff      	cmp	r4, #255	; 0xff
10002b28:	d008      	beq.n	10002b3c <__eqsf2+0x30>
10002b2a:	2001      	movs	r0, #1
10002b2c:	42a2      	cmp	r2, r4
10002b2e:	d00b      	beq.n	10002b48 <__eqsf2+0x3c>
10002b30:	bd70      	pop	{r4, r5, r6, pc}
10002b32:	2001      	movs	r0, #1
10002b34:	2d00      	cmp	r5, #0
10002b36:	d1fb      	bne.n	10002b30 <__eqsf2+0x24>
10002b38:	2cff      	cmp	r4, #255	; 0xff
10002b3a:	d1f6      	bne.n	10002b2a <__eqsf2+0x1e>
10002b3c:	2001      	movs	r0, #1
10002b3e:	2e00      	cmp	r6, #0
10002b40:	d1f6      	bne.n	10002b30 <__eqsf2+0x24>
10002b42:	2001      	movs	r0, #1
10002b44:	42a2      	cmp	r2, r4
10002b46:	d1f3      	bne.n	10002b30 <__eqsf2+0x24>
10002b48:	42b5      	cmp	r5, r6
10002b4a:	d1f1      	bne.n	10002b30 <__eqsf2+0x24>
10002b4c:	428b      	cmp	r3, r1
10002b4e:	d005      	beq.n	10002b5c <__eqsf2+0x50>
10002b50:	2a00      	cmp	r2, #0
10002b52:	d1ed      	bne.n	10002b30 <__eqsf2+0x24>
10002b54:	1c28      	adds	r0, r5, #0
10002b56:	1e43      	subs	r3, r0, #1
10002b58:	4198      	sbcs	r0, r3
10002b5a:	e7e9      	b.n	10002b30 <__eqsf2+0x24>
10002b5c:	2000      	movs	r0, #0
10002b5e:	e7e7      	b.n	10002b30 <__eqsf2+0x24>

10002b60 <__gesf2>:
10002b60:	b5f0      	push	{r4, r5, r6, r7, lr}
10002b62:	0243      	lsls	r3, r0, #9
10002b64:	024d      	lsls	r5, r1, #9
10002b66:	004a      	lsls	r2, r1, #1
10002b68:	0044      	lsls	r4, r0, #1
10002b6a:	0a5e      	lsrs	r6, r3, #9
10002b6c:	0e24      	lsrs	r4, r4, #24
10002b6e:	0fc3      	lsrs	r3, r0, #31
10002b70:	0a6d      	lsrs	r5, r5, #9
10002b72:	0e12      	lsrs	r2, r2, #24
10002b74:	0fc9      	lsrs	r1, r1, #31
10002b76:	2cff      	cmp	r4, #255	; 0xff
10002b78:	d00d      	beq.n	10002b96 <__gesf2+0x36>
10002b7a:	2aff      	cmp	r2, #255	; 0xff
10002b7c:	d031      	beq.n	10002be2 <__gesf2+0x82>
10002b7e:	2c00      	cmp	r4, #0
10002b80:	d10d      	bne.n	10002b9e <__gesf2+0x3e>
10002b82:	4277      	negs	r7, r6
10002b84:	4177      	adcs	r7, r6
10002b86:	2a00      	cmp	r2, #0
10002b88:	d123      	bne.n	10002bd2 <__gesf2+0x72>
10002b8a:	2d00      	cmp	r5, #0
10002b8c:	d121      	bne.n	10002bd2 <__gesf2+0x72>
10002b8e:	2000      	movs	r0, #0
10002b90:	2f00      	cmp	r7, #0
10002b92:	d10b      	bne.n	10002bac <__gesf2+0x4c>
10002b94:	e007      	b.n	10002ba6 <__gesf2+0x46>
10002b96:	2e00      	cmp	r6, #0
10002b98:	d128      	bne.n	10002bec <__gesf2+0x8c>
10002b9a:	2aff      	cmp	r2, #255	; 0xff
10002b9c:	d021      	beq.n	10002be2 <__gesf2+0x82>
10002b9e:	2a00      	cmp	r2, #0
10002ba0:	d005      	beq.n	10002bae <__gesf2+0x4e>
10002ba2:	428b      	cmp	r3, r1
10002ba4:	d007      	beq.n	10002bb6 <__gesf2+0x56>
10002ba6:	4258      	negs	r0, r3
10002ba8:	2301      	movs	r3, #1
10002baa:	4318      	orrs	r0, r3
10002bac:	bdf0      	pop	{r4, r5, r6, r7, pc}
10002bae:	2d00      	cmp	r5, #0
10002bb0:	d0f9      	beq.n	10002ba6 <__gesf2+0x46>
10002bb2:	428b      	cmp	r3, r1
10002bb4:	d1f7      	bne.n	10002ba6 <__gesf2+0x46>
10002bb6:	4294      	cmp	r4, r2
10002bb8:	dcf5      	bgt.n	10002ba6 <__gesf2+0x46>
10002bba:	db04      	blt.n	10002bc6 <__gesf2+0x66>
10002bbc:	42ae      	cmp	r6, r5
10002bbe:	d8f2      	bhi.n	10002ba6 <__gesf2+0x46>
10002bc0:	2000      	movs	r0, #0
10002bc2:	42ae      	cmp	r6, r5
10002bc4:	d2f2      	bcs.n	10002bac <__gesf2+0x4c>
10002bc6:	4258      	negs	r0, r3
10002bc8:	4143      	adcs	r3, r0
10002bca:	2001      	movs	r0, #1
10002bcc:	425b      	negs	r3, r3
10002bce:	4318      	orrs	r0, r3
10002bd0:	e7ec      	b.n	10002bac <__gesf2+0x4c>
10002bd2:	2f00      	cmp	r7, #0
10002bd4:	d0e5      	beq.n	10002ba2 <__gesf2+0x42>
10002bd6:	4248      	negs	r0, r1
10002bd8:	4141      	adcs	r1, r0
10002bda:	2001      	movs	r0, #1
10002bdc:	4249      	negs	r1, r1
10002bde:	4308      	orrs	r0, r1
10002be0:	e7e4      	b.n	10002bac <__gesf2+0x4c>
10002be2:	2d00      	cmp	r5, #0
10002be4:	d102      	bne.n	10002bec <__gesf2+0x8c>
10002be6:	2c00      	cmp	r4, #0
10002be8:	d0cb      	beq.n	10002b82 <__gesf2+0x22>
10002bea:	e7da      	b.n	10002ba2 <__gesf2+0x42>
10002bec:	2002      	movs	r0, #2
10002bee:	4240      	negs	r0, r0
10002bf0:	e7dc      	b.n	10002bac <__gesf2+0x4c>
10002bf2:	46c0      	nop			; (mov r8, r8)

10002bf4 <__lesf2>:
10002bf4:	0243      	lsls	r3, r0, #9
10002bf6:	b5f0      	push	{r4, r5, r6, r7, lr}
10002bf8:	0042      	lsls	r2, r0, #1
10002bfa:	004c      	lsls	r4, r1, #1
10002bfc:	0a5e      	lsrs	r6, r3, #9
10002bfe:	0fc3      	lsrs	r3, r0, #31
10002c00:	0248      	lsls	r0, r1, #9
10002c02:	0e12      	lsrs	r2, r2, #24
10002c04:	0a45      	lsrs	r5, r0, #9
10002c06:	0e24      	lsrs	r4, r4, #24
10002c08:	0fc9      	lsrs	r1, r1, #31
10002c0a:	2aff      	cmp	r2, #255	; 0xff
10002c0c:	d00f      	beq.n	10002c2e <__lesf2+0x3a>
10002c0e:	2cff      	cmp	r4, #255	; 0xff
10002c10:	d01a      	beq.n	10002c48 <__lesf2+0x54>
10002c12:	2a00      	cmp	r2, #0
10002c14:	d110      	bne.n	10002c38 <__lesf2+0x44>
10002c16:	4277      	negs	r7, r6
10002c18:	4177      	adcs	r7, r6
10002c1a:	2c00      	cmp	r4, #0
10002c1c:	d029      	beq.n	10002c72 <__lesf2+0x7e>
10002c1e:	2f00      	cmp	r7, #0
10002c20:	d017      	beq.n	10002c52 <__lesf2+0x5e>
10002c22:	4248      	negs	r0, r1
10002c24:	4141      	adcs	r1, r0
10002c26:	2001      	movs	r0, #1
10002c28:	4249      	negs	r1, r1
10002c2a:	4308      	orrs	r0, r1
10002c2c:	e00b      	b.n	10002c46 <__lesf2+0x52>
10002c2e:	2002      	movs	r0, #2
10002c30:	2e00      	cmp	r6, #0
10002c32:	d108      	bne.n	10002c46 <__lesf2+0x52>
10002c34:	2cff      	cmp	r4, #255	; 0xff
10002c36:	d007      	beq.n	10002c48 <__lesf2+0x54>
10002c38:	2c00      	cmp	r4, #0
10002c3a:	d10a      	bne.n	10002c52 <__lesf2+0x5e>
10002c3c:	2d00      	cmp	r5, #0
10002c3e:	d108      	bne.n	10002c52 <__lesf2+0x5e>
10002c40:	4258      	negs	r0, r3
10002c42:	2301      	movs	r3, #1
10002c44:	4318      	orrs	r0, r3
10002c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
10002c48:	2002      	movs	r0, #2
10002c4a:	2d00      	cmp	r5, #0
10002c4c:	d1fb      	bne.n	10002c46 <__lesf2+0x52>
10002c4e:	2a00      	cmp	r2, #0
10002c50:	d0e1      	beq.n	10002c16 <__lesf2+0x22>
10002c52:	428b      	cmp	r3, r1
10002c54:	d1f4      	bne.n	10002c40 <__lesf2+0x4c>
10002c56:	42a2      	cmp	r2, r4
10002c58:	dcf2      	bgt.n	10002c40 <__lesf2+0x4c>
10002c5a:	db04      	blt.n	10002c66 <__lesf2+0x72>
10002c5c:	42ae      	cmp	r6, r5
10002c5e:	d8ef      	bhi.n	10002c40 <__lesf2+0x4c>
10002c60:	2000      	movs	r0, #0
10002c62:	42ae      	cmp	r6, r5
10002c64:	d2ef      	bcs.n	10002c46 <__lesf2+0x52>
10002c66:	4258      	negs	r0, r3
10002c68:	4143      	adcs	r3, r0
10002c6a:	2001      	movs	r0, #1
10002c6c:	425b      	negs	r3, r3
10002c6e:	4318      	orrs	r0, r3
10002c70:	e7e9      	b.n	10002c46 <__lesf2+0x52>
10002c72:	2d00      	cmp	r5, #0
10002c74:	d1d3      	bne.n	10002c1e <__lesf2+0x2a>
10002c76:	2000      	movs	r0, #0
10002c78:	2f00      	cmp	r7, #0
10002c7a:	d1e4      	bne.n	10002c46 <__lesf2+0x52>
10002c7c:	e7e0      	b.n	10002c40 <__lesf2+0x4c>
10002c7e:	46c0      	nop			; (mov r8, r8)

10002c80 <__aeabi_ui2f>:
10002c80:	b510      	push	{r4, lr}
10002c82:	1e04      	subs	r4, r0, #0
10002c84:	d035      	beq.n	10002cf2 <__aeabi_ui2f+0x72>
10002c86:	f000 f843 	bl	10002d10 <__clzsi2>
10002c8a:	219e      	movs	r1, #158	; 0x9e
10002c8c:	1a09      	subs	r1, r1, r0
10002c8e:	2996      	cmp	r1, #150	; 0x96
10002c90:	dc09      	bgt.n	10002ca6 <__aeabi_ui2f+0x26>
10002c92:	2808      	cmp	r0, #8
10002c94:	dd30      	ble.n	10002cf8 <__aeabi_ui2f+0x78>
10002c96:	1c02      	adds	r2, r0, #0
10002c98:	1c23      	adds	r3, r4, #0
10002c9a:	3a08      	subs	r2, #8
10002c9c:	4093      	lsls	r3, r2
10002c9e:	025b      	lsls	r3, r3, #9
10002ca0:	0a5b      	lsrs	r3, r3, #9
10002ca2:	b2c8      	uxtb	r0, r1
10002ca4:	e020      	b.n	10002ce8 <__aeabi_ui2f+0x68>
10002ca6:	2999      	cmp	r1, #153	; 0x99
10002ca8:	dd0c      	ble.n	10002cc4 <__aeabi_ui2f+0x44>
10002caa:	2205      	movs	r2, #5
10002cac:	1c23      	adds	r3, r4, #0
10002cae:	1a12      	subs	r2, r2, r0
10002cb0:	40d3      	lsrs	r3, r2
10002cb2:	1c1a      	adds	r2, r3, #0
10002cb4:	1c03      	adds	r3, r0, #0
10002cb6:	331b      	adds	r3, #27
10002cb8:	409c      	lsls	r4, r3
10002cba:	1c23      	adds	r3, r4, #0
10002cbc:	1e5c      	subs	r4, r3, #1
10002cbe:	41a3      	sbcs	r3, r4
10002cc0:	4313      	orrs	r3, r2
10002cc2:	1c1c      	adds	r4, r3, #0
10002cc4:	2805      	cmp	r0, #5
10002cc6:	dd01      	ble.n	10002ccc <__aeabi_ui2f+0x4c>
10002cc8:	1f43      	subs	r3, r0, #5
10002cca:	409c      	lsls	r4, r3
10002ccc:	4b0f      	ldr	r3, [pc, #60]	; (10002d0c <__aeabi_ui2f+0x8c>)
10002cce:	4023      	ands	r3, r4
10002cd0:	0762      	lsls	r2, r4, #29
10002cd2:	d004      	beq.n	10002cde <__aeabi_ui2f+0x5e>
10002cd4:	220f      	movs	r2, #15
10002cd6:	4014      	ands	r4, r2
10002cd8:	2c04      	cmp	r4, #4
10002cda:	d000      	beq.n	10002cde <__aeabi_ui2f+0x5e>
10002cdc:	3304      	adds	r3, #4
10002cde:	015a      	lsls	r2, r3, #5
10002ce0:	d40e      	bmi.n	10002d00 <__aeabi_ui2f+0x80>
10002ce2:	019b      	lsls	r3, r3, #6
10002ce4:	0a5b      	lsrs	r3, r3, #9
10002ce6:	b2c8      	uxtb	r0, r1
10002ce8:	025b      	lsls	r3, r3, #9
10002cea:	0a5b      	lsrs	r3, r3, #9
10002cec:	05c0      	lsls	r0, r0, #23
10002cee:	4318      	orrs	r0, r3
10002cf0:	bd10      	pop	{r4, pc}
10002cf2:	2000      	movs	r0, #0
10002cf4:	2300      	movs	r3, #0
10002cf6:	e7f7      	b.n	10002ce8 <__aeabi_ui2f+0x68>
10002cf8:	0263      	lsls	r3, r4, #9
10002cfa:	0a5b      	lsrs	r3, r3, #9
10002cfc:	b2c8      	uxtb	r0, r1
10002cfe:	e7f3      	b.n	10002ce8 <__aeabi_ui2f+0x68>
10002d00:	219f      	movs	r1, #159	; 0x9f
10002d02:	4a02      	ldr	r2, [pc, #8]	; (10002d0c <__aeabi_ui2f+0x8c>)
10002d04:	1a09      	subs	r1, r1, r0
10002d06:	4013      	ands	r3, r2
10002d08:	e7eb      	b.n	10002ce2 <__aeabi_ui2f+0x62>
10002d0a:	46c0      	nop			; (mov r8, r8)
10002d0c:	fbffffff 	.word	0xfbffffff

10002d10 <__clzsi2>:
10002d10:	211c      	movs	r1, #28
10002d12:	2301      	movs	r3, #1
10002d14:	041b      	lsls	r3, r3, #16
10002d16:	4298      	cmp	r0, r3
10002d18:	d301      	bcc.n	10002d1e <__clzsi2+0xe>
10002d1a:	0c00      	lsrs	r0, r0, #16
10002d1c:	3910      	subs	r1, #16
10002d1e:	0a1b      	lsrs	r3, r3, #8
10002d20:	4298      	cmp	r0, r3
10002d22:	d301      	bcc.n	10002d28 <__clzsi2+0x18>
10002d24:	0a00      	lsrs	r0, r0, #8
10002d26:	3908      	subs	r1, #8
10002d28:	091b      	lsrs	r3, r3, #4
10002d2a:	4298      	cmp	r0, r3
10002d2c:	d301      	bcc.n	10002d32 <__clzsi2+0x22>
10002d2e:	0900      	lsrs	r0, r0, #4
10002d30:	3904      	subs	r1, #4
10002d32:	a202      	add	r2, pc, #8	; (adr r2, 10002d3c <__clzsi2+0x2c>)
10002d34:	5c10      	ldrb	r0, [r2, r0]
10002d36:	1840      	adds	r0, r0, r1
10002d38:	4770      	bx	lr
10002d3a:	46c0      	nop			; (mov r8, r8)
10002d3c:	02020304 	.word	0x02020304
10002d40:	01010101 	.word	0x01010101
	...

10002d4c <__libc_init_array>:
10002d4c:	4b0e      	ldr	r3, [pc, #56]	; (10002d88 <__libc_init_array+0x3c>)
10002d4e:	b570      	push	{r4, r5, r6, lr}
10002d50:	2500      	movs	r5, #0
10002d52:	1c1e      	adds	r6, r3, #0
10002d54:	4c0d      	ldr	r4, [pc, #52]	; (10002d8c <__libc_init_array+0x40>)
10002d56:	1ae4      	subs	r4, r4, r3
10002d58:	10a4      	asrs	r4, r4, #2
10002d5a:	42a5      	cmp	r5, r4
10002d5c:	d004      	beq.n	10002d68 <__libc_init_array+0x1c>
10002d5e:	00ab      	lsls	r3, r5, #2
10002d60:	58f3      	ldr	r3, [r6, r3]
10002d62:	4798      	blx	r3
10002d64:	3501      	adds	r5, #1
10002d66:	e7f8      	b.n	10002d5a <__libc_init_array+0xe>
10002d68:	f7ff fe38 	bl	100029dc <_init>
10002d6c:	4b08      	ldr	r3, [pc, #32]	; (10002d90 <__libc_init_array+0x44>)
10002d6e:	2500      	movs	r5, #0
10002d70:	1c1e      	adds	r6, r3, #0
10002d72:	4c08      	ldr	r4, [pc, #32]	; (10002d94 <__libc_init_array+0x48>)
10002d74:	1ae4      	subs	r4, r4, r3
10002d76:	10a4      	asrs	r4, r4, #2
10002d78:	42a5      	cmp	r5, r4
10002d7a:	d004      	beq.n	10002d86 <__libc_init_array+0x3a>
10002d7c:	00ab      	lsls	r3, r5, #2
10002d7e:	58f3      	ldr	r3, [r6, r3]
10002d80:	4798      	blx	r3
10002d82:	3501      	adds	r5, #1
10002d84:	e7f8      	b.n	10002d78 <__libc_init_array+0x2c>
10002d86:	bd70      	pop	{r4, r5, r6, pc}
10002d88:	10002e08 	.word	0x10002e08
10002d8c:	10002e08 	.word	0x10002e08
10002d90:	10002e08 	.word	0x10002e08
10002d94:	10002e08 	.word	0x10002e08

10002d98 <__PLL_Vref_GetResult_veneer>:
10002d98:	b401      	push	{r0}
10002d9a:	4802      	ldr	r0, [pc, #8]	; (10002da4 <__PLL_Vref_GetResult_veneer+0xc>)
10002d9c:	4684      	mov	ip, r0
10002d9e:	bc01      	pop	{r0}
10002da0:	4760      	bx	ip
10002da2:	bf00      	nop
10002da4:	20000f19 	.word	0x20000f19

10002da8 <__Current_Reconstruction_veneer>:
10002da8:	b401      	push	{r0}
10002daa:	4802      	ldr	r0, [pc, #8]	; (10002db4 <__Current_Reconstruction_veneer+0xc>)
10002dac:	4684      	mov	ip, r0
10002dae:	bc01      	pop	{r0}
10002db0:	4760      	bx	ip
10002db2:	bf00      	nop
10002db4:	200008e9 	.word	0x200008e9

10002db8 <__PWMSVM01_Update_veneer>:
10002db8:	b401      	push	{r0}
10002dba:	4802      	ldr	r0, [pc, #8]	; (10002dc4 <__PWMSVM01_Update_veneer+0xc>)
10002dbc:	4684      	mov	ip, r0
10002dbe:	bc01      	pop	{r0}
10002dc0:	4760      	bx	ip
10002dc2:	bf00      	nop
10002dc4:	200006e9 	.word	0x200006e9

10002dc8 <__Get_ADCPhaseCurrent_veneer>:
10002dc8:	b401      	push	{r0}
10002dca:	4802      	ldr	r0, [pc, #8]	; (10002dd4 <__Get_ADCPhaseCurrent_veneer+0xc>)
10002dcc:	4684      	mov	ip, r0
10002dce:	bc01      	pop	{r0}
10002dd0:	4760      	bx	ip
10002dd2:	bf00      	nop
10002dd4:	20000661 	.word	0x20000661

10002dd8 <__PLL_Imag_GetResult_veneer>:
10002dd8:	b401      	push	{r0}
10002dda:	4802      	ldr	r0, [pc, #8]	; (10002de4 <__PLL_Imag_GetResult_veneer+0xc>)
10002ddc:	4684      	mov	ip, r0
10002dde:	bc01      	pop	{r0}
10002de0:	4760      	bx	ip
10002de2:	bf00      	nop
10002de4:	20000ebd 	.word	0x20000ebd

10002de8 <__PLL_Imag_veneer>:
10002de8:	b401      	push	{r0}
10002dea:	4802      	ldr	r0, [pc, #8]	; (10002df4 <__PLL_Imag_veneer+0xc>)
10002dec:	4684      	mov	ip, r0
10002dee:	bc01      	pop	{r0}
10002df0:	4760      	bx	ip
10002df2:	bf00      	nop
10002df4:	20000ea5 	.word	0x20000ea5

10002df8 <__PLL_Vref_veneer>:
10002df8:	b401      	push	{r0}
10002dfa:	4802      	ldr	r0, [pc, #8]	; (10002e04 <__PLL_Vref_veneer+0xc>)
10002dfc:	4684      	mov	ip, r0
10002dfe:	bc01      	pop	{r0}
10002e00:	4760      	bx	ip
10002e02:	bf00      	nop
10002e04:	20000ecd 	.word	0x20000ecd

Disassembly of section .VENEER_Code:

2000000c <HardFault_Veneer>:
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
2000000c:	482c      	ldr	r0, [pc, #176]	; (200000c0 <BCCU0_0_Veneer+0x4>)
    MOV PC,R0
2000000e:	4687      	mov	pc, r0
	...

2000002c <SVC_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
2000002c:	4825      	ldr	r0, [pc, #148]	; (200000c4 <BCCU0_0_Veneer+0x8>)
    MOV PC,R0
2000002e:	4687      	mov	pc, r0
	...

20000038 <PendSV_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
20000038:	4823      	ldr	r0, [pc, #140]	; (200000c8 <BCCU0_0_Veneer+0xc>)
    MOV PC,R0
2000003a:	4687      	mov	pc, r0

2000003c <SysTick_Veneer>:
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
2000003c:	4823      	ldr	r0, [pc, #140]	; (200000cc <BCCU0_0_Veneer+0x10>)
    MOV PC,R0
2000003e:	4687      	mov	pc, r0

20000040 <SCU_0_Veneer>:
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
20000040:	4823      	ldr	r0, [pc, #140]	; (200000d0 <BCCU0_0_Veneer+0x14>)
    MOV PC,R0
20000042:	4687      	mov	pc, r0

20000044 <SCU_1_Veneer>:
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
20000044:	4823      	ldr	r0, [pc, #140]	; (200000d4 <BCCU0_0_Veneer+0x18>)
    MOV PC,R0
20000046:	4687      	mov	pc, r0

20000048 <SCU_2_Veneer>:
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
20000048:	4823      	ldr	r0, [pc, #140]	; (200000d8 <BCCU0_0_Veneer+0x1c>)
    MOV PC,R0
2000004a:	4687      	mov	pc, r0

2000004c <SCU_3_Veneer>:
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
2000004c:	4823      	ldr	r0, [pc, #140]	; (200000dc <BCCU0_0_Veneer+0x20>)
    MOV PC,R0
2000004e:	4687      	mov	pc, r0

20000050 <SCU_4_Veneer>:
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
20000050:	4823      	ldr	r0, [pc, #140]	; (200000e0 <BCCU0_0_Veneer+0x24>)
    MOV PC,R0
20000052:	4687      	mov	pc, r0

20000054 <SCU_5_Veneer>:
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
20000054:	4823      	ldr	r0, [pc, #140]	; (200000e4 <BCCU0_0_Veneer+0x28>)
    MOV PC,R0
20000056:	4687      	mov	pc, r0

20000058 <SCU_6_Veneer>:
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
20000058:	4823      	ldr	r0, [pc, #140]	; (200000e8 <BCCU0_0_Veneer+0x2c>)
    MOV PC,R0
2000005a:	4687      	mov	pc, r0

2000005c <MATH_Veneer>:
/* ======================================================================== */
    .globl MATH_Veneer 
MATH_Veneer:
    LDR R0, =MATH0_0_IRQHandler
2000005c:	4823      	ldr	r0, [pc, #140]	; (200000ec <BCCU0_0_Veneer+0x30>)
    MOV PC,R0
2000005e:	4687      	mov	pc, r0
20000060:	00000000 	.word	0x00000000

20000064 <USIC0_0_Veneer>:
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
20000064:	4822      	ldr	r0, [pc, #136]	; (200000f0 <BCCU0_0_Veneer+0x34>)
    MOV PC,R0
20000066:	4687      	mov	pc, r0

20000068 <USIC0_1_Veneer>:
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
20000068:	4822      	ldr	r0, [pc, #136]	; (200000f4 <BCCU0_0_Veneer+0x38>)
    MOV PC,R0
2000006a:	4687      	mov	pc, r0

2000006c <USIC0_2_Veneer>:
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
2000006c:	4822      	ldr	r0, [pc, #136]	; (200000f8 <BCCU0_0_Veneer+0x3c>)
    MOV PC,R0
2000006e:	4687      	mov	pc, r0

20000070 <USIC0_3_Veneer>:
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
20000070:	4822      	ldr	r0, [pc, #136]	; (200000fc <BCCU0_0_Veneer+0x40>)
    MOV PC,R0
20000072:	4687      	mov	pc, r0

20000074 <USIC0_4_Veneer>:
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000074:	4822      	ldr	r0, [pc, #136]	; (20000100 <BCCU0_0_Veneer+0x44>)
    MOV PC,R0
20000076:	4687      	mov	pc, r0

20000078 <USIC0_5_Veneer>:
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000078:	4822      	ldr	r0, [pc, #136]	; (20000104 <BCCU0_0_Veneer+0x48>)
    MOV PC,R0
2000007a:	4687      	mov	pc, r0

2000007c <VADC0_C0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
2000007c:	4822      	ldr	r0, [pc, #136]	; (20000108 <BCCU0_0_Veneer+0x4c>)
    MOV PC,R0
2000007e:	4687      	mov	pc, r0

20000080 <VADC0_C0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
20000080:	4822      	ldr	r0, [pc, #136]	; (2000010c <BCCU0_0_Veneer+0x50>)
    MOV PC,R0
20000082:	4687      	mov	pc, r0

20000084 <VADC0_G0_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_G0_0_Veneer
VADC0_G0_0_Veneer:
    LDR R0, =VADC0_G0_0_IRQHandler
20000084:	4822      	ldr	r0, [pc, #136]	; (20000110 <BCCU0_0_Veneer+0x54>)
    MOV PC,R0
20000086:	4687      	mov	pc, r0

20000088 <VADC0_G0_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_G0_1_Veneer
VADC0_G0_1_Veneer:
    LDR R0, =VADC0_G0_1_IRQHandler
20000088:	4822      	ldr	r0, [pc, #136]	; (20000114 <BCCU0_0_Veneer+0x58>)
    MOV PC,R0
2000008a:	4687      	mov	pc, r0

2000008c <VADC0_G1_0_Veneer>:
/* ======================================================================== */
    .globl VADC0_G1_0_Veneer
VADC0_G1_0_Veneer:
    LDR R0, =VADC0_G1_0_IRQHandler
2000008c:	4822      	ldr	r0, [pc, #136]	; (20000118 <BCCU0_0_Veneer+0x5c>)
    MOV PC,R0
2000008e:	4687      	mov	pc, r0

20000090 <VADC0_G1_1_Veneer>:
/* ======================================================================== */
    .globl VADC0_G1_1_Veneer
VADC0_G1_1_Veneer:
    LDR R0, =VADC0_G1_1_IRQHandler
20000090:	4822      	ldr	r0, [pc, #136]	; (2000011c <BCCU0_0_Veneer+0x60>)
    MOV PC,R0
20000092:	4687      	mov	pc, r0

20000094 <CCU40_0_Veneer>:
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000094:	4822      	ldr	r0, [pc, #136]	; (20000120 <BCCU0_0_Veneer+0x64>)
    MOV PC,R0
20000096:	4687      	mov	pc, r0

20000098 <CCU40_1_Veneer>:
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000098:	4822      	ldr	r0, [pc, #136]	; (20000124 <BCCU0_0_Veneer+0x68>)
    MOV PC,R0
2000009a:	4687      	mov	pc, r0

2000009c <CCU40_2_Veneer>:
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
2000009c:	4822      	ldr	r0, [pc, #136]	; (20000128 <BCCU0_0_Veneer+0x6c>)
    MOV PC,R0
2000009e:	4687      	mov	pc, r0

200000a0 <CCU40_3_Veneer>:
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
200000a0:	4822      	ldr	r0, [pc, #136]	; (2000012c <BCCU0_0_Veneer+0x70>)
    MOV PC,R0
200000a2:	4687      	mov	pc, r0

200000a4 <CCU80_0_Veneer>:
/* ======================================================================== */
    .globl CCU80_0_Veneer
CCU80_0_Veneer:
    LDR R0, =CCU80_0_IRQHandler
200000a4:	4822      	ldr	r0, [pc, #136]	; (20000130 <BCCU0_0_Veneer+0x74>)
    MOV PC,R0
200000a6:	4687      	mov	pc, r0

200000a8 <CCU80_1_Veneer>:
/* ======================================================================== */
    .globl CCU80_1_Veneer
CCU80_1_Veneer:
    LDR R0, =CCU80_1_IRQHandler
200000a8:	4822      	ldr	r0, [pc, #136]	; (20000134 <BCCU0_0_Veneer+0x78>)
    MOV PC,R0
200000aa:	4687      	mov	pc, r0

200000ac <POSIF0_0_Veneer>:
/* ======================================================================== */
    .globl POSIF0_0_Veneer
POSIF0_0_Veneer:
    LDR R0, =POSIF0_0_IRQHandler
200000ac:	4822      	ldr	r0, [pc, #136]	; (20000138 <BCCU0_0_Veneer+0x7c>)
    MOV PC,R0
200000ae:	4687      	mov	pc, r0

200000b0 <POSIF0_1_Veneer>:
/* ======================================================================== */
    .globl POSIF0_1_Veneer
POSIF0_1_Veneer:
    LDR R0, =POSIF0_1_IRQHandler
200000b0:	4822      	ldr	r0, [pc, #136]	; (2000013c <BCCU0_0_Veneer+0x80>)
    MOV PC,R0
200000b2:	4687      	mov	pc, r0
	...

200000bc <BCCU0_0_Veneer>:
    .long 0
    .long 0
/* ======================================================================== */
    .globl BCCU0_0_Veneer
BCCU0_0_Veneer:
    LDR R0, =BCCU0_0_IRQHandler
200000bc:	4820      	ldr	r0, [pc, #128]	; (20000140 <BCCU0_0_Veneer+0x84>)
    MOV PC,R0
200000be:	4687      	mov	pc, r0
    
    .align 1
    
    .globl HardFault_Veneer
HardFault_Veneer:
    LDR R0, =HardFault_Handler
200000c0:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl SVC_Veneer
SVC_Veneer:
    LDR R0, =SVC_Handler
200000c4:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl PendSV_Veneer
PendSV_Veneer:
    LDR R0, =PendSV_Handler
200000c8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SysTick_Veneer 
SysTick_Veneer:
    LDR R0, =SysTick_Handler
200000cc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_0_Veneer 
SCU_0_Veneer:
    LDR R0, =SCU_0_IRQHandler
200000d0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_1_Veneer 
SCU_1_Veneer:
    LDR R0, =SCU_1_IRQHandler
200000d4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_2_Veneer
SCU_2_Veneer:
    LDR R0, =SCU_2_IRQHandler
200000d8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_3_Veneer 
SCU_3_Veneer:
    LDR R0, =ERU0_0_IRQHandler
200000dc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_4_Veneer 
SCU_4_Veneer:
    LDR R0, =ERU0_1_IRQHandler
200000e0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_5_Veneer 
SCU_5_Veneer:
    LDR R0, =ERU0_2_IRQHandler
200000e4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl SCU_6_Veneer 
SCU_6_Veneer:
    LDR R0, =ERU0_3_IRQHandler
200000e8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl MATH_Veneer 
MATH_Veneer:
    LDR R0, =MATH0_0_IRQHandler
200000ec:	10001099 	.word	0x10001099
    MOV PC,R0
    .long 0
/* ======================================================================== */
    .globl USIC0_0_Veneer
USIC0_0_Veneer:
    LDR R0, =USIC0_0_IRQHandler
200000f0:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_1_Veneer
USIC0_1_Veneer:
    LDR R0, =USIC0_1_IRQHandler
200000f4:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_2_Veneer
USIC0_2_Veneer:
    LDR R0, =USIC0_2_IRQHandler
200000f8:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_3_Veneer
USIC0_3_Veneer:
    LDR R0, =USIC0_3_IRQHandler
200000fc:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_4_Veneer
USIC0_4_Veneer:
    LDR R0, =USIC0_4_IRQHandler
20000100:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl USIC0_5_Veneer
USIC0_5_Veneer:
    LDR R0, =USIC0_5_IRQHandler
20000104:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_0_Veneer 
VADC0_C0_0_Veneer:
    LDR R0, =VADC0_C0_0_IRQHandler
20000108:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_C0_1_Veneer
VADC0_C0_1_Veneer:
    LDR R0, =VADC0_C0_1_IRQHandler
2000010c:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_G0_0_Veneer
VADC0_G0_0_Veneer:
    LDR R0, =VADC0_G0_0_IRQHandler
20000110:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_G0_1_Veneer
VADC0_G0_1_Veneer:
    LDR R0, =VADC0_G0_1_IRQHandler
20000114:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_G1_0_Veneer
VADC0_G1_0_Veneer:
    LDR R0, =VADC0_G1_0_IRQHandler
20000118:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl VADC0_G1_1_Veneer
VADC0_G1_1_Veneer:
    LDR R0, =VADC0_G1_1_IRQHandler
2000011c:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_0_Veneer
CCU40_0_Veneer:
    LDR R0, =CCU40_0_IRQHandler
20000120:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_1_Veneer
CCU40_1_Veneer:
    LDR R0, =CCU40_1_IRQHandler
20000124:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_2_Veneer
CCU40_2_Veneer:
    LDR R0, =CCU40_2_IRQHandler
20000128:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU40_3_Veneer
CCU40_3_Veneer:
    LDR R0, =CCU40_3_IRQHandler
2000012c:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl CCU80_0_Veneer
CCU80_0_Veneer:
    LDR R0, =CCU80_0_IRQHandler
20000130:	20000875 	.word	0x20000875
    MOV PC,R0
/* ======================================================================== */
    .globl CCU80_1_Veneer
CCU80_1_Veneer:
    LDR R0, =CCU80_1_IRQHandler
20000134:	10001bdd 	.word	0x10001bdd
    MOV PC,R0
/* ======================================================================== */
    .globl POSIF0_0_Veneer
POSIF0_0_Veneer:
    LDR R0, =POSIF0_0_IRQHandler
20000138:	10001099 	.word	0x10001099
    MOV PC,R0
/* ======================================================================== */
    .globl POSIF0_1_Veneer
POSIF0_1_Veneer:
    LDR R0, =POSIF0_1_IRQHandler
2000013c:	10001099 	.word	0x10001099
    .long 0
    .long 0
/* ======================================================================== */
    .globl BCCU0_0_Veneer
BCCU0_0_Veneer:
    LDR R0, =BCCU0_0_IRQHandler
20000140:	10001099 	.word	0x10001099

Disassembly of section .ram_code:

20000660 <Get_ADCPhaseCurrent>:

#if (CURRENT_SENSING ==  USER_THREE_SHUNT_SYNC_CONV)
/* API to read ADC result of the 3 shunt current */
RAM_ATTRIBUTE void Get_ADCPhaseCurrent(uint16_t Previous_SVM_SectorNo, uint16_t New_SVM_SectorNo,
                                       ADCType* const HandlePtr)
{
20000660:	b570      	push	{r4, r5, r6, lr}
  uint16_t I3;



  /* Read current ADC (ADC synchronous conversion) */
  I1 = VADC_I1_GROUP->RES[VADC_I1_RESULT_REG];
20000662:	24c0      	movs	r4, #192	; 0xc0
20000664:	4e1c      	ldr	r6, [pc, #112]	; (200006d8 <Get_ADCPhaseCurrent+0x78>)
20000666:	00a4      	lsls	r4, r4, #2
20000668:	5933      	ldr	r3, [r6, r4]
2000066a:	b29d      	uxth	r5, r3
  I2 = VADC_I2_GROUP->RES[VADC_I2_RESULT_REG];
2000066c:	4b1b      	ldr	r3, [pc, #108]	; (200006dc <Get_ADCPhaseCurrent+0x7c>)
2000066e:	591b      	ldr	r3, [r3, r4]
20000670:	b29c      	uxth	r4, r3
  I3 = VADC_I3_GROUP->RES[VADC_I3_RESULT_REG];
20000672:	23c1      	movs	r3, #193	; 0xc1
20000674:	009b      	lsls	r3, r3, #2
20000676:	58f3      	ldr	r3, [r6, r3]
20000678:	b29b      	uxth	r3, r3


  /* 3-phase current reconstruction */
  switch (Previous_SVM_SectorNo)
2000067a:	2802      	cmp	r0, #2
2000067c:	d817      	bhi.n	200006ae <Get_ADCPhaseCurrent+0x4e>
2000067e:	2800      	cmp	r0, #0
20000680:	d111      	bne.n	200006a6 <Get_ADCPhaseCurrent+0x46>
  {
    case 0:
    case 5:
      /* Sectors A and F. ADC sequences - Iw -> Iv -> Iu */
      HandlePtr->ADC_Iu = I3;
20000682:	8013      	strh	r3, [r2, #0]
      HandlePtr->ADC_Iv = I2;
20000684:	8054      	strh	r4, [r2, #2]
      HandlePtr->ADC_Iw = I1;
20000686:	8095      	strh	r5, [r2, #4]
      HandlePtr->ADC_Iw = I3;
      break;
  }

  /* If SVM sector changed */
  if (New_SVM_SectorNo != Previous_SVM_SectorNo)
20000688:	4281      	cmp	r1, r0
2000068a:	d00b      	beq.n	200006a4 <Get_ADCPhaseCurrent+0x44>
  {
    /* Rotating ADC alias */
    switch (New_SVM_SectorNo)
2000068c:	2902      	cmp	r1, #2
2000068e:	d81d      	bhi.n	200006cc <Get_ADCPhaseCurrent+0x6c>
20000690:	2900      	cmp	r1, #0
20000692:	d112      	bne.n	200006ba <Get_ADCPhaseCurrent+0x5a>
    {
      case 0:
      case 5:
         /* Sectors A and F. ADC sequences - Iw -> Iv -> Iu */
        VADC_G1->ALIAS = (((uint32_t)VADC_IU_G1_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IW_G1_CHANNEL);
20000694:	23b0      	movs	r3, #176	; 0xb0
20000696:	4912      	ldr	r1, [pc, #72]	; (200006e0 <Get_ADCPhaseCurrent+0x80>)
        VADC_G0->ALIAS = (((uint32_t)VADC_IDC_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IU_G0_CHANNEL);
        break;

      default:
        /* Process for all other cases, Sectors D and E. ADC sequences - Iu -> Iv -> Iw */
        VADC_G1->ALIAS = (((uint32_t)VADC_IW_G1_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IU_G1_CHANNEL);
20000698:	4a0f      	ldr	r2, [pc, #60]	; (200006d8 <Get_ADCPhaseCurrent+0x78>)
2000069a:	50d1      	str	r1, [r2, r3]
        VADC_G0->ALIAS = (((uint32_t)VADC_IDC_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IV_G0_CHANNEL);
2000069c:	2104      	movs	r1, #4
2000069e:	4a0f      	ldr	r2, [pc, #60]	; (200006dc <Get_ADCPhaseCurrent+0x7c>)
200006a0:	31ff      	adds	r1, #255	; 0xff
200006a2:	50d1      	str	r1, [r2, r3]
        break;
    }
  }
}
200006a4:	bd70      	pop	{r4, r5, r6, pc}
      HandlePtr->ADC_Iw = I1;
      break;
    case 1:
    case 2:
      /* Sectors B and C. ADC sequences - Iw -> Iu -> Iv */
      HandlePtr->ADC_Iu = I2;
200006a6:	8014      	strh	r4, [r2, #0]
      HandlePtr->ADC_Iv = I3;
200006a8:	8053      	strh	r3, [r2, #2]
      HandlePtr->ADC_Iw = I1;
200006aa:	8095      	strh	r5, [r2, #4]
      break;
200006ac:	e7ec      	b.n	20000688 <Get_ADCPhaseCurrent+0x28>
  I2 = VADC_I2_GROUP->RES[VADC_I2_RESULT_REG];
  I3 = VADC_I3_GROUP->RES[VADC_I3_RESULT_REG];


  /* 3-phase current reconstruction */
  switch (Previous_SVM_SectorNo)
200006ae:	2805      	cmp	r0, #5
200006b0:	d0e7      	beq.n	20000682 <Get_ADCPhaseCurrent+0x22>
      HandlePtr->ADC_Iw = I1;
      break;

    default:
      /* Process for all other cases, Sectors D and E. ADC sequences - Iu -> Iv -> Iw */
      HandlePtr->ADC_Iu = I1;
200006b2:	8015      	strh	r5, [r2, #0]
      HandlePtr->ADC_Iv = I2;
200006b4:	8054      	strh	r4, [r2, #2]
      HandlePtr->ADC_Iw = I3;
200006b6:	8093      	strh	r3, [r2, #4]
      break;
200006b8:	e7e6      	b.n	20000688 <Get_ADCPhaseCurrent+0x28>
        break;

      case 1:
      case 2:
        /*  Sectors B and C. ADC sequences - Iw -> Iu -> Iv */
        VADC_G1->ALIAS = (((uint32_t)VADC_IV_G1_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IW_G1_CHANNEL);
200006ba:	23b0      	movs	r3, #176	; 0xb0
200006bc:	4909      	ldr	r1, [pc, #36]	; (200006e4 <Get_ADCPhaseCurrent+0x84>)
200006be:	4a06      	ldr	r2, [pc, #24]	; (200006d8 <Get_ADCPhaseCurrent+0x78>)
200006c0:	50d1      	str	r1, [r2, r3]
        VADC_G0->ALIAS = (((uint32_t)VADC_IDC_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IU_G0_CHANNEL);
200006c2:	3902      	subs	r1, #2
200006c4:	4a05      	ldr	r2, [pc, #20]	; (200006dc <Get_ADCPhaseCurrent+0x7c>)
200006c6:	39ff      	subs	r1, #255	; 0xff
200006c8:	50d1      	str	r1, [r2, r3]
        break;
200006ca:	e7eb      	b.n	200006a4 <Get_ADCPhaseCurrent+0x44>

  /* If SVM sector changed */
  if (New_SVM_SectorNo != Previous_SVM_SectorNo)
  {
    /* Rotating ADC alias */
    switch (New_SVM_SectorNo)
200006cc:	2905      	cmp	r1, #5
200006ce:	d0e1      	beq.n	20000694 <Get_ADCPhaseCurrent+0x34>
        VADC_G0->ALIAS = (((uint32_t)VADC_IDC_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IU_G0_CHANNEL);
        break;

      default:
        /* Process for all other cases, Sectors D and E. ADC sequences - Iu -> Iv -> Iw */
        VADC_G1->ALIAS = (((uint32_t)VADC_IW_G1_CHANNEL << VADC_G_ALIAS_ALIAS1_Pos) | VADC_IU_G1_CHANNEL);
200006d0:	21c1      	movs	r1, #193	; 0xc1
200006d2:	23b0      	movs	r3, #176	; 0xb0
200006d4:	0089      	lsls	r1, r1, #2
200006d6:	e7df      	b.n	20000698 <Get_ADCPhaseCurrent+0x38>
200006d8:	48030800 	.word	0x48030800
200006dc:	48030400 	.word	0x48030400
200006e0:	00000403 	.word	0x00000403
200006e4:	00000203 	.word	0x00000203

200006e8 <PWMSVM01_Update>:

  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
200006e8:	22ff      	movs	r2, #255	; 0xff
  CCU8_MODULE->GCSS |= (uint32_t)(XMC_CCU8_SHADOW_TRANSFER_SLICE_0|XMC_CCU8_SHADOW_TRANSFER_SLICE_1|XMC_CCU8_SHADOW_TRANSFER_SLICE_2|XMC_CCU8_SHADOW_TRANSFER_SLICE_3 );
 }
#else
/* API to update SVPWM CCU8 duty cycles, use standard SVM (7-segment symmetric PWM) */
RAM_ATTRIBUTE void PWMSVM01_Update(uint16_t Amplitude, uint16_t Angle)
{
200006ea:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t T0;

  uint16_t AngleTemp;
  uint16_t SectorAngle;

  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */
200006ec:	4d54      	ldr	r5, [pc, #336]	; (20000840 <PWMSVM01_Update+0x158>)

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
200006ee:	0a09      	lsrs	r1, r1, #8
  uint16_t T0;

  uint16_t AngleTemp;
  uint16_t SectorAngle;

  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */
200006f0:	882b      	ldrh	r3, [r5, #0]

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
200006f2:	004c      	lsls	r4, r1, #1
  uint16_t T0;

  uint16_t AngleTemp;
  uint16_t SectorAngle;

  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */
200006f4:	806b      	strh	r3, [r5, #2]

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
200006f6:	1c13      	adds	r3, r2, #0
  uint16_t SectorAngle;

  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
200006f8:	1909      	adds	r1, r1, r4
200006fa:	0049      	lsls	r1, r1, #1
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
200006fc:	400b      	ands	r3, r1
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
200006fe:	4f51      	ldr	r7, [pc, #324]	; (20000844 <PWMSVM01_Update+0x15c>)
20000700:	1ad2      	subs	r2, r2, r3
20000702:	0052      	lsls	r2, r2, #1
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000704:	005b      	lsls	r3, r3, #1
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000706:	5bd4      	ldrh	r4, [r2, r7]
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000708:	5bdb      	ldrh	r3, [r3, r7]
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000070a:	4344      	muls	r4, r0
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000070c:	4358      	muls	r0, r3
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000070e:	4a4e      	ldr	r2, [pc, #312]	; (20000848 <PWMSVM01_Update+0x160>)
20000710:	13e4      	asrs	r4, r4, #15
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000712:	13c0      	asrs	r0, r0, #15
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000714:	4354      	muls	r4, r2
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000716:	4342      	muls	r2, r0
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
20000718:	0be4      	lsrs	r4, r4, #15
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000071a:	0bd2      	lsrs	r2, r2, #15
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000071c:	b2a6      	uxth	r6, r4
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
2000071e:	b293      	uxth	r3, r2

  T1nT2 = T1 + T2;												/* Temp variable for (T1+T2) <= PERIOD_REG. */
20000720:	18f2      	adds	r2, r6, r3
  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */
20000722:	0a09      	lsrs	r1, r1, #8

  /* Calculate T1 / T2 by LUT. */
  T1 = (((Amplitude * Sinus60_tab[MAX_LUT_INDEX - SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;
  T2 = (((Amplitude * Sinus60_tab[SectorAngle]) >> 15) * SVM_LUT_SCALE) >> 15;

  T1nT2 = T1 + T2;												/* Temp variable for (T1+T2) <= PERIOD_REG. */
20000724:	b297      	uxth	r7, r2
//  if (T1nT2 > PERIOD_REG)
//  {
//    T1nT2 = PERIOD_REG;       /* Make sure below T0/2 >= 0. */
//  }

  if (T1nT2 > PERIOD_OF_PWM)
20000726:	4a49      	ldr	r2, [pc, #292]	; (2000084c <PWMSVM01_Update+0x164>)
  SVM.PreviousSectorNo = SVM.CurrentSectorNo;           /* Record sector information of last PWM cycle. */

  /* Angle: 0 ~ 2^16 represent electrical angle 0° ~ 360°. Or = (uint16_t)(Angle >> 8) * 6; */
  AngleTemp = (Angle >> ANGLETEMP_SHIFT) * 6U;
  SectorAngle = AngleTemp & SECTOR_ANGLE_AND;					/* Relative angle θrel in each sector. */
  SVM.CurrentSectorNo = AngleTemp >> SECTOR_NO_SHIFT; /* Update new SVM sector number. Or = (AngleTemp >> 8) & 0x7U; */
20000728:	b289      	uxth	r1, r1
2000072a:	8029      	strh	r1, [r5, #0]
//  if (T1nT2 > PERIOD_REG)
//  {
//    T1nT2 = PERIOD_REG;       /* Make sure below T0/2 >= 0. */
//  }

  if (T1nT2 > PERIOD_OF_PWM)
2000072c:	4694      	mov	ip, r2
2000072e:	4297      	cmp	r7, r2
20000730:	d91d      	bls.n	2000076e <PWMSVM01_Update+0x86>
  {
    #define SHIFT_OVERMODULATION    (5U)
    MATH->DIVCON = (0x00008004 | (SHIFT_OVERMODULATION << 16U) | (SHIFT_OVERMODULATION << 8U));
20000732:	4a47      	ldr	r2, [pc, #284]	; (20000850 <PWMSVM01_Update+0x168>)
20000734:	4b47      	ldr	r3, [pc, #284]	; (20000854 <PWMSVM01_Update+0x16c>)
    MATH->DVD = T1 * PERIOD_OF_PWM;
20000736:	0424      	lsls	r4, r4, #16
//  }

  if (T1nT2 > PERIOD_OF_PWM)
  {
    #define SHIFT_OVERMODULATION    (5U)
    MATH->DIVCON = (0x00008004 | (SHIFT_OVERMODULATION << 16U) | (SHIFT_OVERMODULATION << 8U));
20000738:	6353      	str	r3, [r2, #52]	; 0x34
    MATH->DVD = T1 * PERIOD_OF_PWM;
2000073a:	4663      	mov	r3, ip
2000073c:	0c24      	lsrs	r4, r4, #16
2000073e:	4363      	muls	r3, r4
20000740:	6213      	str	r3, [r2, #32]
    MATH->DVS = T1nT2;
20000742:	6257      	str	r7, [r2, #36]	; 0x24

    T1nT2 = PERIOD_OF_PWM;

    while (MATH->DIVST)
20000744:	6b13      	ldr	r3, [r2, #48]	; 0x30
20000746:	2b00      	cmp	r3, #0
20000748:	d1fc      	bne.n	20000744 <PWMSVM01_Update+0x5c>
    {
      /* CPU wait */
    }

    T1 = MATH->QUOT;
2000074a:	4b41      	ldr	r3, [pc, #260]	; (20000850 <PWMSVM01_Update+0x168>)
    T2 = PERIOD_OF_PWM - T1;
2000074c:	4c42      	ldr	r4, [pc, #264]	; (20000858 <PWMSVM01_Update+0x170>)
    while (MATH->DIVST)
    {
      /* CPU wait */
    }

    T1 = MATH->QUOT;
2000074e:	6a9e      	ldr	r6, [r3, #40]	; 0x28
    T2 = PERIOD_OF_PWM - T1;
20000750:	4b3e      	ldr	r3, [pc, #248]	; (2000084c <PWMSVM01_Update+0x164>)
    while (MATH->DIVST)
    {
      /* CPU wait */
    }

    T1 = MATH->QUOT;
20000752:	b2b6      	uxth	r6, r6
    T2 = PERIOD_OF_PWM - T1;
20000754:	1b9b      	subs	r3, r3, r6
20000756:	4a41      	ldr	r2, [pc, #260]	; (2000085c <PWMSVM01_Update+0x174>)
20000758:	b29b      	uxth	r3, r3
  {
    SVM.Flag_3or2_ADC = USE_ALL_ADC;			/* To use all (e.g.: three) ADC samplings for current reconstruction. */
  }
  else
  {
    SVM.Flag_3or2_ADC = USE_2_ADC;				/* To use two ADC samplings for current reconstruction. */
2000075a:	20bb      	movs	r0, #187	; 0xbb
      uint16_t Half_T1nT2;
      uint16_t Half_T2;
      uint16_t Half_T1;

      Half_T1nT2 = T1nT2 >> 1;                // (T1+T2)/2.
      Half_T2 = T2 >> 1;                    // T2/2.
2000075c:	085b      	lsrs	r3, r3, #1
2000075e:	80a8      	strh	r0, [r5, #4]
      Half_T1 = T1 >> 1;                    // T1/2.
20000760:	0876      	lsrs	r6, r6, #1

      /* Standard 5-segment symmetric PWM: */
      switch (SVM.CurrentSectorNo)
20000762:	2904      	cmp	r1, #4
20000764:	d812      	bhi.n	2000078c <PWMSVM01_Update+0xa4>
20000766:	483e      	ldr	r0, [pc, #248]	; (20000860 <PWMSVM01_Update+0x178>)
20000768:	0089      	lsls	r1, r1, #2
2000076a:	5841      	ldr	r1, [r0, r1]
2000076c:	468f      	mov	pc, r1
    T1 = MATH->QUOT;
    T2 = PERIOD_OF_PWM - T1;

  }

  T0 = PERIOD_OF_PWM - T1nT2;
2000076e:	1bd0      	subs	r0, r2, r7

  if (T0 > T0_THRESHOLD)
20000770:	22e0      	movs	r2, #224	; 0xe0
20000772:	b280      	uxth	r0, r0
20000774:	0092      	lsls	r2, r2, #2
20000776:	4290      	cmp	r0, r2
20000778:	d95e      	bls.n	20000838 <PWMSVM01_Update+0x150>
2000077a:	4660      	mov	r0, ip
2000077c:	087a      	lsrs	r2, r7, #1
2000077e:	1a84      	subs	r4, r0, r2
  {
    SVM.Flag_3or2_ADC = USE_ALL_ADC;			/* To use all (e.g.: three) ADC samplings for current reconstruction. */
20000780:	2000      	movs	r0, #0
      uint16_t Half_T1nT2;
      uint16_t Half_T2;
      uint16_t Half_T1;

      Half_T1nT2 = T1nT2 >> 1;                // (T1+T2)/2.
      Half_T2 = T2 >> 1;                    // T2/2.
20000782:	085b      	lsrs	r3, r3, #1
20000784:	80a8      	strh	r0, [r5, #4]
      Half_T1 = T1 >> 1;                    // T1/2.
20000786:	0876      	lsrs	r6, r6, #1

      /* Standard 5-segment symmetric PWM: */
      switch (SVM.CurrentSectorNo)
20000788:	2904      	cmp	r1, #4
2000078a:	d9ec      	bls.n	20000766 <PWMSVM01_Update+0x7e>

        break;

      default:                      // Process for all other cases. Sector F.

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1nT2;
2000078c:	4b35      	ldr	r3, [pc, #212]	; (20000864 <PWMSVM01_Update+0x17c>)
2000078e:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) 0;
20000790:	2200      	movs	r2, #0
        break;

      default:                      // Process for all other cases. Sector F.

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1nT2;
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
20000792:	645c      	str	r4, [r3, #68]	; 0x44

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) 0;
20000794:	4b34      	ldr	r3, [pc, #208]	; (20000868 <PWMSVM01_Update+0x180>)
20000796:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);
20000798:	4a34      	ldr	r2, [pc, #208]	; (2000086c <PWMSVM01_Update+0x184>)
2000079a:	645a      	str	r2, [r3, #68]	; 0x44

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T1;
2000079c:	4a34      	ldr	r2, [pc, #208]	; (20000870 <PWMSVM01_Update+0x188>)
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
2000079e:	4b2b      	ldr	r3, [pc, #172]	; (2000084c <PWMSVM01_Update+0x164>)
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) 0;
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T1;
200007a0:	63d6      	str	r6, [r2, #60]	; 0x3c
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
200007a2:	1b9e      	subs	r6, r3, r6
200007a4:	6456      	str	r6, [r2, #68]	; 0x44

        break;
200007a6:	e00c      	b.n	200007c2 <PWMSVM01_Update+0xda>

        break;

      case 3:                       // Sector D

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) 0;
200007a8:	2100      	movs	r1, #0
200007aa:	4b2e      	ldr	r3, [pc, #184]	; (20000864 <PWMSVM01_Update+0x17c>)
200007ac:	63d9      	str	r1, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);
200007ae:	492f      	ldr	r1, [pc, #188]	; (2000086c <PWMSVM01_Update+0x184>)
200007b0:	6459      	str	r1, [r3, #68]	; 0x44

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1;
200007b2:	492d      	ldr	r1, [pc, #180]	; (20000868 <PWMSVM01_Update+0x180>)
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
200007b4:	4b25      	ldr	r3, [pc, #148]	; (2000084c <PWMSVM01_Update+0x164>)
      case 3:                       // Sector D

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) 0;
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1;
200007b6:	63ce      	str	r6, [r1, #60]	; 0x3c
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
200007b8:	1b9e      	subs	r6, r3, r6

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T1nT2;
200007ba:	4b2d      	ldr	r3, [pc, #180]	; (20000870 <PWMSVM01_Update+0x188>)

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) 0;
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1;
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
200007bc:	644e      	str	r6, [r1, #68]	; 0x44

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T1nT2;
200007be:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
200007c0:	645c      	str	r4, [r3, #68]	; 0x44
        break;
      }

#endif
  /* Enable shadow transfer for slice 0,1,2 for CCU80 Kernel. */
  CCU8_MODULE->GCSS |= (uint32_t)(XMC_CCU8_SHADOW_TRANSFER_SLICE_0|XMC_CCU8_SHADOW_TRANSFER_SLICE_1|XMC_CCU8_SHADOW_TRANSFER_SLICE_2);
200007c2:	22a0      	movs	r2, #160	; 0xa0
200007c4:	2112      	movs	r1, #18
200007c6:	05d2      	lsls	r2, r2, #23
200007c8:	6913      	ldr	r3, [r2, #16]
200007ca:	31ff      	adds	r1, #255	; 0xff
200007cc:	430b      	orrs	r3, r1
200007ce:	6113      	str	r3, [r2, #16]
  /* ADC triggered always at centre of [000] (fixed centre position in one PWM). */
}
200007d0:	bdf0      	pop	{r4, r5, r6, r7, pc}

        break;

      case 4:                       // Sector E

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T2;
200007d2:	4824      	ldr	r0, [pc, #144]	; (20000864 <PWMSVM01_Update+0x17c>)
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
200007d4:	491d      	ldr	r1, [pc, #116]	; (2000084c <PWMSVM01_Update+0x164>)

        break;

      case 4:                       // Sector E

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T2;
200007d6:	63c3      	str	r3, [r0, #60]	; 0x3c
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
200007d8:	1acb      	subs	r3, r1, r3

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) 0;
200007da:	2100      	movs	r1, #0
        break;

      case 4:                       // Sector E

        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T2;
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
200007dc:	6443      	str	r3, [r0, #68]	; 0x44

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) 0;
200007de:	4b22      	ldr	r3, [pc, #136]	; (20000868 <PWMSVM01_Update+0x180>)
200007e0:	63d9      	str	r1, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);
200007e2:	4922      	ldr	r1, [pc, #136]	; (2000086c <PWMSVM01_Update+0x184>)
200007e4:	6459      	str	r1, [r3, #68]	; 0x44

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T1nT2;
200007e6:	4b22      	ldr	r3, [pc, #136]	; (20000870 <PWMSVM01_Update+0x188>)
200007e8:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
200007ea:	645c      	str	r4, [r3, #68]	; 0x44

        break;
200007ec:	e7e9      	b.n	200007c2 <PWMSVM01_Update+0xda>

      /* Standard 5-segment symmetric PWM: */
      switch (SVM.CurrentSectorNo)
      {
        case 0:                        // Sector A
          CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1nT2;
200007ee:	491d      	ldr	r1, [pc, #116]	; (20000864 <PWMSVM01_Update+0x17c>)
200007f0:	63ca      	str	r2, [r1, #60]	; 0x3c
          CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
200007f2:	644c      	str	r4, [r1, #68]	; 0x44

          CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T2;
          CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
200007f4:	4a15      	ldr	r2, [pc, #84]	; (2000084c <PWMSVM01_Update+0x164>)
      {
        case 0:                        // Sector A
          CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1nT2;
          CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);

          CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T2;
200007f6:	491c      	ldr	r1, [pc, #112]	; (20000868 <PWMSVM01_Update+0x180>)
200007f8:	63cb      	str	r3, [r1, #60]	; 0x3c
          CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
200007fa:	1ad3      	subs	r3, r2, r3
200007fc:	644b      	str	r3, [r1, #68]	; 0x44
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1nT2;
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) 0;
200007fe:	2200      	movs	r2, #0
20000800:	4b1b      	ldr	r3, [pc, #108]	; (20000870 <PWMSVM01_Update+0x188>)
20000802:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);
20000804:	4a19      	ldr	r2, [pc, #100]	; (2000086c <PWMSVM01_Update+0x184>)
20000806:	645a      	str	r2, [r3, #68]	; 0x44

        break;
20000808:	e7db      	b.n	200007c2 <PWMSVM01_Update+0xda>
          CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        break;

      case 1:                       // Sector B
        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1;
2000080a:	4916      	ldr	r1, [pc, #88]	; (20000864 <PWMSVM01_Update+0x17c>)
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
2000080c:	4b0f      	ldr	r3, [pc, #60]	; (2000084c <PWMSVM01_Update+0x164>)
          CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        break;

      case 1:                       // Sector B
        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1;
2000080e:	63ce      	str	r6, [r1, #60]	; 0x3c
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
20000810:	1b9e      	subs	r6, r3, r6

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1nT2;
20000812:	4b15      	ldr	r3, [pc, #84]	; (20000868 <PWMSVM01_Update+0x180>)

        break;

      case 1:                       // Sector B
        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) Half_T1;
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1);
20000814:	644e      	str	r6, [r1, #68]	; 0x44

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1nT2;
20000816:	63da      	str	r2, [r3, #60]	; 0x3c
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
20000818:	645c      	str	r4, [r3, #68]	; 0x44
2000081a:	e7f0      	b.n	200007fe <PWMSVM01_Update+0x116>
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        break;

      case 2:                       // Sector C
        CCU8_MODULE_PHASE_U->CR1S = (uint32_t) 0;
2000081c:	2000      	movs	r0, #0
2000081e:	4911      	ldr	r1, [pc, #68]	; (20000864 <PWMSVM01_Update+0x17c>)
20000820:	63c8      	str	r0, [r1, #60]	; 0x3c
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);
20000822:	4812      	ldr	r0, [pc, #72]	; (2000086c <PWMSVM01_Update+0x184>)
20000824:	6448      	str	r0, [r1, #68]	; 0x44

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1nT2;
20000826:	4910      	ldr	r1, [pc, #64]	; (20000868 <PWMSVM01_Update+0x180>)
20000828:	63ca      	str	r2, [r1, #60]	; 0x3c
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);
2000082a:	644c      	str	r4, [r1, #68]	; 0x44

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T2;
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
2000082c:	4a07      	ldr	r2, [pc, #28]	; (2000084c <PWMSVM01_Update+0x164>)
        CCU8_MODULE_PHASE_U->CR2S = (uint32_t) (PERIOD_OF_PWM + 1);

        CCU8_MODULE_PHASE_V->CR1S = (uint32_t) Half_T1nT2;
        CCU8_MODULE_PHASE_V->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T1nT2);

        CCU8_MODULE_PHASE_W->CR1S = (uint32_t) Half_T2;
2000082e:	4910      	ldr	r1, [pc, #64]	; (20000870 <PWMSVM01_Update+0x188>)
20000830:	63cb      	str	r3, [r1, #60]	; 0x3c
        CCU8_MODULE_PHASE_W->CR2S = (uint32_t) (PERIOD_OF_PWM - Half_T2);
20000832:	1ad3      	subs	r3, r2, r3
20000834:	644b      	str	r3, [r1, #68]	; 0x44

        break;
20000836:	e7c4      	b.n	200007c2 <PWMSVM01_Update+0xda>
20000838:	4660      	mov	r0, ip
2000083a:	087a      	lsrs	r2, r7, #1
2000083c:	1a84      	subs	r4, r0, r2
2000083e:	e78c      	b.n	2000075a <PWMSVM01_Update+0x72>
20000840:	20001018 	.word	0x20001018
20000844:	1000302c 	.word	0x1000302c
20000848:	000010aa 	.word	0x000010aa
2000084c:	000010ab 	.word	0x000010ab
20000850:	40030000 	.word	0x40030000
20000854:	00058504 	.word	0x00058504
20000858:	00000856 	.word	0x00000856
2000085c:	00000855 	.word	0x00000855
20000860:	10002ff4 	.word	0x10002ff4
20000864:	50000100 	.word	0x50000100
20000868:	50000200 	.word	0x50000200
2000086c:	000010ac 	.word	0x000010ac
20000870:	50000300 	.word	0x50000300

20000874 <CCU80_0_IRQHandler>:
/*
 * Periodic CCU80 Period Match Interrupt, function called every CCU8 PWM cycle
 * It is the state machine of Sensorless FOC
 */
RAM_ATTRIBUTE void DirectFOCIQStartUp_CCU80_0_IRQHandler(void)
{
20000874:	b510      	push	{r4, lr}


  switch (Motor.State)
20000876:	4c18      	ldr	r4, [pc, #96]	; (200008d8 <CCU80_0_IRQHandler+0x64>)
20000878:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
2000087a:	2b02      	cmp	r3, #2
2000087c:	d028      	beq.n	200008d0 <CCU80_0_IRQHandler+0x5c>
2000087e:	d912      	bls.n	200008a6 <CCU80_0_IRQHandler+0x32>
20000880:	2b03      	cmp	r3, #3
20000882:	d00d      	beq.n	200008a0 <CCU80_0_IRQHandler+0x2c>
20000884:	2b06      	cmp	r3, #6
20000886:	d120      	bne.n	200008ca <CCU80_0_IRQHandler+0x56>
				Stop_Motor ();
				break;

			case PRE_POSITIONING:

				DirectFOCRotor_Pre_Positioning ();
20000888:	f000 fba6 	bl	20000fd8 <__DirectFOCRotor_Pre_Positioning_veneer>
   * Miscellaneous works in CCU80_0_IRQHandler, such as tasks that don't need real-time computing.
   * Execution time: 1.65us
   */
  /**********************************   Misc_Works_of_IRQ ();**************************************************/

  Misc_Works_of_IRQ ();
2000088c:	f000 f950 	bl	20000b30 <Misc_Works_of_IRQ>
  Motor.speed_in_rpm = (Motor.Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM;
20000890:	68a2      	ldr	r2, [r4, #8]
20000892:	00d3      	lsls	r3, r2, #3
20000894:	189b      	adds	r3, r3, r2
20000896:	019a      	lsls	r2, r3, #6
20000898:	189b      	adds	r3, r3, r2
2000089a:	0adb      	lsrs	r3, r3, #11
2000089c:	6123      	str	r3, [r4, #16]

}
2000089e:	bd10      	pop	{r4, pc}
				DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge ();
				break;

			case STOP_MOTOR:

				Stop_Motor ();
200008a0:	f000 fba2 	bl	20000fe8 <__Stop_Motor_veneer>
				break;
200008a4:	e7f2      	b.n	2000088c <CCU80_0_IRQHandler+0x18>
 */
RAM_ATTRIBUTE void DirectFOCIQStartUp_CCU80_0_IRQHandler(void)
{


  switch (Motor.State)
200008a6:	2b00      	cmp	r3, #0
200008a8:	d10f      	bne.n	200008ca <CCU80_0_IRQHandler+0x56>

#endif

      /* Execution time: 22us */
      //XMC_GPIO_SetOutputHigh(P1_2);
      FOC_Torque_Controller();                          /* Toggle LED in Main.c, CPU load = 28.2 us */
200008aa:	f000 f975 	bl	20000b98 <FOC_Torque_Controller>
      //XMC_GPIO_SetOutputLow(P1_2);


      /********************************** Misc_Works_of_FOC ();**************************************************/
      Misc_Works_of_FOC();
200008ae:	f000 f82f 	bl	20000910 <Misc_Works_of_FOC>


/**********************************   PWMSVM01_Update((Car2Polar.Vref32 >> CORDIC_SHIFT), (Car2Polar.Vref_AngleQ31 >> 16U));**************************************************/

      PWMSVM01_Update(Car2Polar.Vref32 >> CORDIC_SHIFT, Car2Polar.Vref_AngleQ31 >> 16U);
200008b2:	4b0a      	ldr	r3, [pc, #40]	; (200008dc <CCU80_0_IRQHandler+0x68>)
200008b4:	689a      	ldr	r2, [r3, #8]
200008b6:	89d9      	ldrh	r1, [r3, #14]
200008b8:	0b90      	lsrs	r0, r2, #14
200008ba:	b280      	uxth	r0, r0
200008bc:	f7ff ff14 	bl	200006e8 <PWMSVM01_Update>

      /* Record SVM sector information. */
      FOCOutput.New_SVM_SectorNo = SVM.CurrentSectorNo;
200008c0:	4b07      	ldr	r3, [pc, #28]	; (200008e0 <CCU80_0_IRQHandler+0x6c>)
200008c2:	881a      	ldrh	r2, [r3, #0]
200008c4:	4b07      	ldr	r3, [pc, #28]	; (200008e4 <CCU80_0_IRQHandler+0x70>)
200008c6:	835a      	strh	r2, [r3, #26]

        break;
200008c8:	e7e0      	b.n	2000088c <CCU80_0_IRQHandler+0x18>
				DirectFOCRotor_Pre_Positioning ();
				break;

			default:
				/* For trap protection if CCU8_TRAP_ENABLE (CCU8 TRAP functionality enabled)*/
				Error_Handling ();
200008ca:	f000 fb6d 	bl	20000fa8 <__Error_Handling_veneer>

				break;
200008ce:	e7dd      	b.n	2000088c <CCU80_0_IRQHandler+0x18>
      FOCOutput.New_SVM_SectorNo = SVM.CurrentSectorNo;

        break;
			case BRAKE_BOOTSTRAP:
			  /* Brake the motor before motor startup. Charge gate driver bootstrap capacitors (if any)*/
				DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge ();
200008d0:	f000 fb7a 	bl	20000fc8 <__DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge_veneer>
				break;
200008d4:	e7da      	b.n	2000088c <CCU80_0_IRQHandler+0x18>
200008d6:	46c0      	nop			; (mov r8, r8)
200008d8:	20001244 	.word	0x20001244
200008dc:	2000109c 	.word	0x2000109c
200008e0:	20001018 	.word	0x20001018
200008e4:	20001198 	.word	0x20001198

200008e8 <Current_Reconstruction>:
  }
  CCU4_Debug3Output (HandlePtr->I_U, 1,13,HandlePtr->I_V ,1,13);
}
#else
RAM_ATTRIBUTE void Current_Reconstruction (int32_t ADC_Iu, int32_t ADC_Iv, int32_t ADC_Iw, CurrentType * const HandlePtr)
{
200008e8:	b530      	push	{r4, r5, lr}

	/* Motor phase current, Iu, Iv, Iw*/
	HandlePtr->I_U = ((int16_t)(ADC.ADC_Bias_Iu - ADC_Iu)) << 3;
200008ea:	4c08      	ldr	r4, [pc, #32]	; (2000090c <Current_Reconstruction+0x24>)
200008ec:	68a5      	ldr	r5, [r4, #8]
200008ee:	1a28      	subs	r0, r5, r0
200008f0:	b200      	sxth	r0, r0
200008f2:	00c0      	lsls	r0, r0, #3
200008f4:	6018      	str	r0, [r3, #0]
	HandlePtr->I_V = ((int16_t)(ADC.ADC_Bias_Iv - ADC_Iv)) << 3;
200008f6:	68e0      	ldr	r0, [r4, #12]
200008f8:	1a41      	subs	r1, r0, r1
200008fa:	b209      	sxth	r1, r1
200008fc:	00c9      	lsls	r1, r1, #3
200008fe:	6059      	str	r1, [r3, #4]
	HandlePtr->I_W = ((int16_t)(ADC.ADC_Bias_Iw - ADC_Iw)) << 3;
20000900:	6921      	ldr	r1, [r4, #16]
20000902:	1a8a      	subs	r2, r1, r2
20000904:	b212      	sxth	r2, r2
20000906:	00d2      	lsls	r2, r2, #3
20000908:	609a      	str	r2, [r3, #8]

	//CCU4_Debug3Output (HandlePtr->I_V, 1,11,HandlePtr->I_U ,1,11);

}
2000090a:	bd30      	pop	{r4, r5, pc}
2000090c:	20001050 	.word	0x20001050

20000910 <Misc_Works_of_FOC>:
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GLOBAL_BackgroundTriggerConversion(XMC_VADC_GLOBAL_t *const global_ptr)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundTriggerConversion:Wrong Module Pointer", (global_ptr == VADC))
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
20000910:	2281      	movs	r2, #129	; 0x81
20000912:	2080      	movs	r0, #128	; 0x80
20000914:	492b      	ldr	r1, [pc, #172]	; (200009c4 <Misc_Works_of_FOC+0xb4>)
20000916:	0092      	lsls	r2, r2, #2
20000918:	588b      	ldr	r3, [r1, r2]
2000091a:	0080      	lsls	r0, r0, #2
2000091c:	4303      	orrs	r3, r0

	/** Miscellaneous works in FOC, such as ramp up, speed adjustment, stop motor, etc
	 ** Do NOT add any CORDIC calculations in this function.
		 * -----------------------------------------------------------------------------------*/
RAM_ATTRIBUTE void Misc_Works_of_FOC (void)
{
2000091e:	b570      	push	{r4, r5, r6, lr}
20000920:	508b      	str	r3, [r1, r2]
	  uint16_t DCLink_adc_result;
      uint16_t IDCLink_adc_result;
      XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);
      /* DC link ADC LPF. Read RES5 for ADC result (Previous ADC result) */
	  DCLink_adc_result = VADC_VDC_GROUP->RES[VADC_VDC_RESULT_REG];
20000922:	23c6      	movs	r3, #198	; 0xc6
		ADC.ADC_DCLink = (ADC.ADC_DCLink * ((1<<ADCLPF)-1) + DCLink_adc_result) >> ADCLPF;
20000924:	4c28      	ldr	r4, [pc, #160]	; (200009c8 <Misc_Works_of_FOC+0xb8>)
{
	  uint16_t DCLink_adc_result;
      uint16_t IDCLink_adc_result;
      XMC_VADC_GLOBAL_BackgroundTriggerConversion(VADC);
      /* DC link ADC LPF. Read RES5 for ADC result (Previous ADC result) */
	  DCLink_adc_result = VADC_VDC_GROUP->RES[VADC_VDC_RESULT_REG];
20000926:	4a29      	ldr	r2, [pc, #164]	; (200009cc <Misc_Works_of_FOC+0xbc>)
20000928:	009b      	lsls	r3, r3, #2
2000092a:	58d3      	ldr	r3, [r2, r3]
		ADC.ADC_DCLink = (ADC.ADC_DCLink * ((1<<ADCLPF)-1) + DCLink_adc_result) >> ADCLPF;
2000092c:	6a61      	ldr	r1, [r4, #36]	; 0x24
2000092e:	041b      	lsls	r3, r3, #16
20000930:	014a      	lsls	r2, r1, #5
20000932:	1a52      	subs	r2, r2, r1
20000934:	0c1b      	lsrs	r3, r3, #16
20000936:	18d3      	adds	r3, r2, r3
20000938:	115b      	asrs	r3, r3, #5
2000093a:	6263      	str	r3, [r4, #36]	; 0x24

		/* IDC link ADC LPF.  */
	   IDCLink_adc_result = VADC_IDC_GROUP->RES[VADC_IDC_RESULT_REG];
2000093c:	23c1      	movs	r3, #193	; 0xc1
2000093e:	4a24      	ldr	r2, [pc, #144]	; (200009d0 <Misc_Works_of_FOC+0xc0>)
20000940:	009b      	lsls	r3, r3, #2
	   ADC.ADC_IDCLink = (ADC.ADC_IDCLink * ((1 << ADCLPF) - 1) + IDCLink_adc_result) >> ADCLPF;
20000942:	6aa1      	ldr	r1, [r4, #40]	; 0x28
      /* DC link ADC LPF. Read RES5 for ADC result (Previous ADC result) */
	  DCLink_adc_result = VADC_VDC_GROUP->RES[VADC_VDC_RESULT_REG];
		ADC.ADC_DCLink = (ADC.ADC_DCLink * ((1<<ADCLPF)-1) + DCLink_adc_result) >> ADCLPF;

		/* IDC link ADC LPF.  */
	   IDCLink_adc_result = VADC_IDC_GROUP->RES[VADC_IDC_RESULT_REG];
20000944:	58d3      	ldr	r3, [r2, r3]
	   ADC.ADC_IDCLink = (ADC.ADC_IDCLink * ((1 << ADCLPF) - 1) + IDCLink_adc_result) >> ADCLPF;
20000946:	014a      	lsls	r2, r1, #5
20000948:	041b      	lsls	r3, r3, #16
2000094a:	1a52      	subs	r2, r2, r1
2000094c:	0c1b      	lsrs	r3, r3, #16
2000094e:	18d3      	adds	r3, r2, r3

    #if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
		Linear_Torque_Ramp_Generator(Motor.Speed_by_POT_PWM,USER_IQ_RAMPUP, USER_IQ_RAMPDOWN, &FOCInput);
20000950:	4d20      	ldr	r5, [pc, #128]	; (200009d4 <Misc_Works_of_FOC+0xc4>)
20000952:	4e21      	ldr	r6, [pc, #132]	; (200009d8 <Misc_Works_of_FOC+0xc8>)
	  DCLink_adc_result = VADC_VDC_GROUP->RES[VADC_VDC_RESULT_REG];
		ADC.ADC_DCLink = (ADC.ADC_DCLink * ((1<<ADCLPF)-1) + DCLink_adc_result) >> ADCLPF;

		/* IDC link ADC LPF.  */
	   IDCLink_adc_result = VADC_IDC_GROUP->RES[VADC_IDC_RESULT_REG];
	   ADC.ADC_IDCLink = (ADC.ADC_IDCLink * ((1 << ADCLPF) - 1) + IDCLink_adc_result) >> ADCLPF;
20000954:	115b      	asrs	r3, r3, #5
20000956:	62a3      	str	r3, [r4, #40]	; 0x28

    #if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
		Linear_Torque_Ramp_Generator(Motor.Speed_by_POT_PWM,USER_IQ_RAMPUP, USER_IQ_RAMPDOWN, &FOCInput);
20000958:	68e8      	ldr	r0, [r5, #12]
2000095a:	1c33      	adds	r3, r6, #0
2000095c:	2101      	movs	r1, #1
2000095e:	2201      	movs	r2, #1
20000960:	f000 fa74 	bl	20000e4c <Linear_Torque_Ramp_Generator>
		if((SYSTEM_BE_IDLE) && (FOCInput.Ref_Iq <= Motor.Speed_by_POT_PWM) && Motor.Speed < FOC_EXIT_SPEED)
20000964:	6a23      	ldr	r3, [r4, #32]
20000966:	2b31      	cmp	r3, #49	; 0x31
20000968:	dc03      	bgt.n	20000972 <Misc_Works_of_FOC+0x62>
2000096a:	6d33      	ldr	r3, [r6, #80]	; 0x50
2000096c:	68ea      	ldr	r2, [r5, #12]
2000096e:	4293      	cmp	r3, r2
20000970:	dd1b      	ble.n	200009aa <Misc_Works_of_FOC+0x9a>
		  Motor.Counter = 0;
		  Motor.State = STOP_MOTOR;
		}
    #endif

		if (Motor.Mode_Flag == MOTOR_TRANSITION)
20000972:	8e6b      	ldrh	r3, [r5, #50]	; 0x32
20000974:	2b00      	cmp	r3, #0
20000976:	d017      	beq.n	200009a8 <Misc_Works_of_FOC+0x98>
		else   /* else, FOC is in stable mode.*/
		{
		    /* Over/under voltage protection */
        #if(VDC_UNDER_OVERVOLTAGE_PROTECTION == ENABLED)

          if(VADC_VDC_GROUP->CEFLAG & (1 << VADC_VDC_CHANNEL))
20000978:	23c0      	movs	r3, #192	; 0xc0
2000097a:	4a14      	ldr	r2, [pc, #80]	; (200009cc <Misc_Works_of_FOC+0xbc>)
2000097c:	005b      	lsls	r3, r3, #1
2000097e:	58d3      	ldr	r3, [r2, r3]
20000980:	065b      	lsls	r3, r3, #25
20000982:	d511      	bpl.n	200009a8 <Misc_Works_of_FOC+0x98>
          {
            if (ADC.ADC_DCLink > VDC_OVER_LIMIT)
20000984:	22d8      	movs	r2, #216	; 0xd8
20000986:	6a63      	ldr	r3, [r4, #36]	; 0x24
20000988:	0112      	lsls	r2, r2, #4
2000098a:	4293      	cmp	r3, r2
2000098c:	dd16      	ble.n	200009bc <Misc_Works_of_FOC+0xac>
              XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, DISABLE_LEVEL);
            }
            else if(ADC.ADC_DCLink < VDC_MIN_LIMIT)
            {
              /* Motor.error_status =  PMSM_FOC_EID_UNDER_VOLT; */
              Motor.State = DCLINK_OVER_UNDER_VOLTAGE;
2000098e:	2307      	movs	r3, #7
20000990:	2280      	movs	r2, #128	; 0x80
20000992:	62eb      	str	r3, [r5, #44]	; 0x2c
20000994:	4b11      	ldr	r3, [pc, #68]	; (200009dc <Misc_Works_of_FOC+0xcc>)
20000996:	0512      	lsls	r2, r2, #20
20000998:	605a      	str	r2, [r3, #4]
              /* Disable gate driver. */
              XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, DISABLE_LEVEL);
            }
          VADC_VDC_GROUP->CEFCLR |= (1 << VADC_VDC_CHANNEL);
2000099a:	22c8      	movs	r2, #200	; 0xc8
2000099c:	2340      	movs	r3, #64	; 0x40
2000099e:	490b      	ldr	r1, [pc, #44]	; (200009cc <Misc_Works_of_FOC+0xbc>)
200009a0:	0052      	lsls	r2, r2, #1
200009a2:	5888      	ldr	r0, [r1, r2]
200009a4:	4303      	orrs	r3, r0
200009a6:	508b      	str	r3, [r1, r2]
              Motor.Ramp_Counter = 0;
              Motor.State = STOP_MOTOR;						/* Next, go to Motor Stop (may brake motor and cause vibration). */
          }
        #endif
		}
}
200009a8:	bd70      	pop	{r4, r5, r6, pc}
	   IDCLink_adc_result = VADC_IDC_GROUP->RES[VADC_IDC_RESULT_REG];
	   ADC.ADC_IDCLink = (ADC.ADC_IDCLink * ((1 << ADCLPF) - 1) + IDCLink_adc_result) >> ADCLPF;

    #if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
		Linear_Torque_Ramp_Generator(Motor.Speed_by_POT_PWM,USER_IQ_RAMPUP, USER_IQ_RAMPDOWN, &FOCInput);
		if((SYSTEM_BE_IDLE) && (FOCInput.Ref_Iq <= Motor.Speed_by_POT_PWM) && Motor.Speed < FOC_EXIT_SPEED)
200009aa:	4b0d      	ldr	r3, [pc, #52]	; (200009e0 <Misc_Works_of_FOC+0xd0>)
200009ac:	68aa      	ldr	r2, [r5, #8]
200009ae:	429a      	cmp	r2, r3
200009b0:	d8df      	bhi.n	20000972 <Misc_Works_of_FOC+0x62>
		{
		  /* Clear counters.*/
      Motor.Counter = 0;
200009b2:	2300      	movs	r3, #0
200009b4:	63eb      	str	r3, [r5, #60]	; 0x3c
      /* Next, go to Motor Stop (may brake motor and cause vibration).*/
      Motor.State = STOP_MOTOR;
200009b6:	3303      	adds	r3, #3
200009b8:	62eb      	str	r3, [r5, #44]	; 0x2c
200009ba:	e7da      	b.n	20000972 <Misc_Works_of_FOC+0x62>
              /* Motor.error_status = PMSM_FOC_EID_OVER_VOLT;*/
              Motor.State = DCLINK_OVER_UNDER_VOLTAGE;
              /* Disable gate driver. */
              XMC_GPIO_SetOutputLevel(INVERTER_EN_PIN, DISABLE_LEVEL);
            }
            else if(ADC.ADC_DCLink < VDC_MIN_LIMIT)
200009bc:	4a09      	ldr	r2, [pc, #36]	; (200009e4 <Misc_Works_of_FOC+0xd4>)
200009be:	4293      	cmp	r3, r2
200009c0:	dceb      	bgt.n	2000099a <Misc_Works_of_FOC+0x8a>
200009c2:	e7e4      	b.n	2000098e <Misc_Works_of_FOC+0x7e>
200009c4:	48030000 	.word	0x48030000
200009c8:	20001050 	.word	0x20001050
200009cc:	48030800 	.word	0x48030800
200009d0:	48030400 	.word	0x48030400
200009d4:	20001244 	.word	0x20001244
200009d8:	200011c8 	.word	0x200011c8
200009dc:	40040000 	.word	0x40040000
200009e0:	000006cb 	.word	0x000006cb
200009e4:	000008ff 	.word	0x000008ff

200009e8 <Adjust_FOC_Parameters>:
** Execution time: ?us (O3 - Optimize most).
 * ----------------------------------------------------------------------*/
RAM_ATTRIBUTE void Adjust_FOC_Parameters (void)
{
     /* Parameter adjustment not finished yet. */
    if (Motor.Adjust_Para_Flag != ADJUST_DONE)
200009e8:	490c      	ldr	r1, [pc, #48]	; (20000a1c <Adjust_FOC_Parameters+0x34>)
/** Adjust parameters, e.g.: for PI controllers, in FOC stable state
** Scheduling - using different parameters in different operating regions.
** Execution time: ?us (O3 - Optimize most).
 * ----------------------------------------------------------------------*/
RAM_ATTRIBUTE void Adjust_FOC_Parameters (void)
{
200009ea:	b510      	push	{r4, lr}
     /* Parameter adjustment not finished yet. */
    if (Motor.Adjust_Para_Flag != ADJUST_DONE)
200009ec:	6b8b      	ldr	r3, [r1, #56]	; 0x38
200009ee:	2b00      	cmp	r3, #0
200009f0:	d00a      	beq.n	20000a08 <Adjust_FOC_Parameters+0x20>
    {
      /* 1). Ik limit scheduling for Speed PI controller:*/
      if (PI_Speed.Ik_limit_max < PI_SPEED_IK_LIMIT_FINAL)
200009f2:	4a0b      	ldr	r2, [pc, #44]	; (20000a20 <Adjust_FOC_Parameters+0x38>)
200009f4:	480b      	ldr	r0, [pc, #44]	; (20000a24 <Adjust_FOC_Parameters+0x3c>)
200009f6:	68d4      	ldr	r4, [r2, #12]
200009f8:	22c0      	movs	r2, #192	; 0xc0
200009fa:	6983      	ldr	r3, [r0, #24]
200009fc:	01d2      	lsls	r2, r2, #7
200009fe:	40a2      	lsls	r2, r4
20000a00:	4293      	cmp	r3, r2
20000a02:	d302      	bcc.n	20000a0a <Adjust_FOC_Parameters+0x22>
        PI_Speed.Ik_limit_min = - PI_Speed.Ik_limit_max;
      }
      else
      {
        /* To indicate that adjustment of this parameter is done. */
        Motor.Adjust_Para_Flag = ADJUST_DONE;
20000a04:	2300      	movs	r3, #0
20000a06:	638b      	str	r3, [r1, #56]	; 0x38
      }
    }
}
20000a08:	bd10      	pop	{r4, pc}
    {
      /* 1). Ik limit scheduling for Speed PI controller:*/
      if (PI_Speed.Ik_limit_max < PI_SPEED_IK_LIMIT_FINAL)
      {
        /* Parameter adjusted gradually and regularly every PWM cycle. */
        PI_Speed.Ik_limit_max += SPEED_IK_ADJUST_STEP;
20000a0a:	2280      	movs	r2, #128	; 0x80
20000a0c:	01d2      	lsls	r2, r2, #7
20000a0e:	4694      	mov	ip, r2
20000a10:	4463      	add	r3, ip
20000a12:	6183      	str	r3, [r0, #24]
        PI_Speed.Ik_limit_min = - PI_Speed.Ik_limit_max;
20000a14:	425b      	negs	r3, r3
20000a16:	6143      	str	r3, [r0, #20]
20000a18:	e7f6      	b.n	20000a08 <Adjust_FOC_Parameters+0x20>
20000a1a:	46c0      	nop			; (mov r8, r8)
20000a1c:	20001244 	.word	0x20001244
20000a20:	200012a8 	.word	0x200012a8
20000a24:	200010f8 	.word	0x200010f8

20000a28 <Linear_Ramp_Generator>:

}

RAM_ATTRIBUTE void Linear_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rate,
                                         int32_t speedrampstep, int32_t *reference_val)
{
20000a28:	b530      	push	{r4, r5, lr}
20000a2a:	9c03      	ldr	r4, [sp, #12]
  if (*reference_val != set_val)
20000a2c:	6825      	ldr	r5, [r4, #0]
20000a2e:	4285      	cmp	r5, r0
20000a30:	d01e      	beq.n	20000a70 <Linear_Ramp_Generator+0x48>
  {
    /* in FOC, ωref not reach the target speed.*/
    if (*reference_val < set_val)
20000a32:	da11      	bge.n	20000a58 <Linear_Ramp_Generator+0x30>
    {
      /* Speed ramp counter ++.*/
      Motor.Ramp_Counter ++;
20000a34:	4814      	ldr	r0, [pc, #80]	; (20000a88 <Linear_Ramp_Generator+0x60>)
20000a36:	6c02      	ldr	r2, [r0, #64]	; 0x40
      if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
20000a38:	6a45      	ldr	r5, [r0, #36]	; 0x24
  {
    /* in FOC, ωref not reach the target speed.*/
    if (*reference_val < set_val)
    {
      /* Speed ramp counter ++.*/
      Motor.Ramp_Counter ++;
20000a3a:	3201      	adds	r2, #1
20000a3c:	6402      	str	r2, [r0, #64]	; 0x40
      if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
20000a3e:	42aa      	cmp	r2, r5
20000a40:	d909      	bls.n	20000a56 <Linear_Ramp_Generator+0x2e>
      {
        /* Ramp up slowly (if needed) at start of FOC.*/
        if (Motor.Ramp_Up_Rate > rampup_rate)
20000a42:	428d      	cmp	r5, r1
20000a44:	dd01      	ble.n	20000a4a <Linear_Ramp_Generator+0x22>
        {
          /* Increase acceleration step by step.*/
          Motor.Ramp_Up_Rate --;
20000a46:	3d01      	subs	r5, #1
20000a48:	6245      	str	r5, [r0, #36]	; 0x24
        }

        /*  ωref ++.*/
        *reference_val += speedrampstep;
20000a4a:	6822      	ldr	r2, [r4, #0]
20000a4c:	4694      	mov	ip, r2
20000a4e:	4463      	add	r3, ip
20000a50:	6023      	str	r3, [r4, #0]
        /* Clear ramp counter. */
        Motor.Ramp_Counter = 0;
20000a52:	2300      	movs	r3, #0
20000a54:	6403      	str	r3, [r0, #64]	; 0x40
      Motor.Counter = 0;
      /* Clear counter */
      Motor.Ramp_Counter = 0;
    }
  }
}
20000a56:	bd30      	pop	{r4, r5, pc}
      }
    }
    else
    {
      /* Speed ramp counter ++.*/
      Motor.Ramp_Counter ++;
20000a58:	480b      	ldr	r0, [pc, #44]	; (20000a88 <Linear_Ramp_Generator+0x60>)
20000a5a:	6c01      	ldr	r1, [r0, #64]	; 0x40
20000a5c:	3101      	adds	r1, #1
20000a5e:	6401      	str	r1, [r0, #64]	; 0x40
      if (Motor.Ramp_Counter > rampdown_rate)
20000a60:	4291      	cmp	r1, r2
20000a62:	d9f8      	bls.n	20000a56 <Linear_Ramp_Generator+0x2e>
      {
        /* ωref --.*/
        *reference_val -= speedrampstep;
20000a64:	6822      	ldr	r2, [r4, #0]
20000a66:	1ad3      	subs	r3, r2, r3
20000a68:	6023      	str	r3, [r4, #0]
        Motor.Ramp_Counter = 0;
20000a6a:	2300      	movs	r3, #0
20000a6c:	6403      	str	r3, [r0, #64]	; 0x40
20000a6e:	e7f2      	b.n	20000a56 <Linear_Ramp_Generator+0x2e>
  }
  else
  {
    /* ωref reach the target speed */
    /* Update counter */
    Motor.Counter ++;
20000a70:	4a05      	ldr	r2, [pc, #20]	; (20000a88 <Linear_Ramp_Generator+0x60>)
20000a72:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
20000a74:	3301      	adds	r3, #1
20000a76:	63d3      	str	r3, [r2, #60]	; 0x3c
    /*15, 150 or 1500. Time that FOC becomes stable, x PWM period.*/
    if (Motor.Counter > 2U)
20000a78:	2b02      	cmp	r3, #2
20000a7a:	d9ec      	bls.n	20000a56 <Linear_Ramp_Generator+0x2e>
    {
      /* Change flag: in FOC stable mode. */
      Motor.Mode_Flag = MOTOR_STABLE;
20000a7c:	23ab      	movs	r3, #171	; 0xab
20000a7e:	8653      	strh	r3, [r2, #50]	; 0x32
      Motor.Counter = 0;
20000a80:	2300      	movs	r3, #0
20000a82:	63d3      	str	r3, [r2, #60]	; 0x3c
      /* Clear counter */
      Motor.Ramp_Counter = 0;
20000a84:	6413      	str	r3, [r2, #64]	; 0x40
20000a86:	e7e6      	b.n	20000a56 <Linear_Ramp_Generator+0x2e>
20000a88:	20001244 	.word	0x20001244

20000a8c <SCurve_Ramp_Generator>:
/* Speed threshold for entering second S-curve of ramp up / down. */
#define SPEED_TH_2ND_S    (SPEED_LOW_LIMIT >> 0U)

RAM_ATTRIBUTE void SCurve_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rate,
                                         int32_t speedrampstep, int32_t *reference_val)
{
20000a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
20000a8e:	9d05      	ldr	r5, [sp, #20]
  if (*reference_val == set_val)
20000a90:	682c      	ldr	r4, [r5, #0]
20000a92:	4284      	cmp	r4, r0
20000a94:	d03f      	beq.n	20000b16 <SCurve_Ramp_Generator+0x8a>
    Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;

    /* Reset to slower ramp up and ramp down for S-curve profile. */
    Motor.Ramp_Dn_Rate = rampdown_rate << (RATIO_S - 1);
  }
  else if (*reference_val < set_val)
20000a96:	da17      	bge.n	20000ac8 <SCurve_Ramp_Generator+0x3c>
  {
    /* Motor ref speed lower than speed set by POT or PWM. */
    /* Speed ramp counter ++. */
    Motor.Ramp_Counter++;
20000a98:	4c22      	ldr	r4, [pc, #136]	; (20000b24 <SCurve_Ramp_Generator+0x98>)
20000a9a:	6c22      	ldr	r2, [r4, #64]	; 0x40
    if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
20000a9c:	6a66      	ldr	r6, [r4, #36]	; 0x24
  }
  else if (*reference_val < set_val)
  {
    /* Motor ref speed lower than speed set by POT or PWM. */
    /* Speed ramp counter ++. */
    Motor.Ramp_Counter++;
20000a9e:	3201      	adds	r2, #1
20000aa0:	6422      	str	r2, [r4, #64]	; 0x40
    if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
20000aa2:	42b2      	cmp	r2, r6
20000aa4:	d90f      	bls.n	20000ac6 <SCurve_Ramp_Generator+0x3a>
    {
      if ((set_val - *reference_val) > SPEED_TH_2ND_S)
20000aa6:	2791      	movs	r7, #145	; 0x91
20000aa8:	682a      	ldr	r2, [r5, #0]
20000aaa:	00bf      	lsls	r7, r7, #2
20000aac:	1a80      	subs	r0, r0, r2
20000aae:	42b8      	cmp	r0, r7
20000ab0:	d826      	bhi.n	20000b00 <SCurve_Ramp_Generator+0x74>
        }
      }
      else
      {
        /* Second S-curve of ramp up. */
        if (Motor.Ramp_Up_Rate < (rampup_rate << RATIO_S))
20000ab2:	0049      	lsls	r1, r1, #1
20000ab4:	428e      	cmp	r6, r1
20000ab6:	da02      	bge.n	20000abe <SCurve_Ramp_Generator+0x32>
        {
          Motor.Ramp_Up_Rate++;
20000ab8:	3601      	adds	r6, #1
20000aba:	6266      	str	r6, [r4, #36]	; 0x24
20000abc:	682a      	ldr	r2, [r5, #0]
        }
      }
      /* Motor ref speed ++. */
      *reference_val += speedrampstep;
20000abe:	189b      	adds	r3, r3, r2
20000ac0:	602b      	str	r3, [r5, #0]
      Motor.Ramp_Counter = 0;
20000ac2:	2300      	movs	r3, #0
20000ac4:	6423      	str	r3, [r4, #64]	; 0x40
        Motor.Ramp_Counter = 0;
      }

    }

 }
20000ac6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }
  else
  {
    /* Motor ref speed higher than speed set by POT or PWM. */
    /* Speed ramp counter ++. */
    Motor.Ramp_Counter++;
20000ac8:	4c16      	ldr	r4, [pc, #88]	; (20000b24 <SCurve_Ramp_Generator+0x98>)
20000aca:	6c21      	ldr	r1, [r4, #64]	; 0x40
    if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
20000acc:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  }
  else
  {
    /* Motor ref speed higher than speed set by POT or PWM. */
    /* Speed ramp counter ++. */
    Motor.Ramp_Counter++;
20000ace:	3101      	adds	r1, #1
20000ad0:	6421      	str	r1, [r4, #64]	; 0x40
    if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
20000ad2:	42b1      	cmp	r1, r6
20000ad4:	d9f7      	bls.n	20000ac6 <SCurve_Ramp_Generator+0x3a>
    {
      if ((*reference_val - set_val) > SPEED_TH_2ND_S)
20000ad6:	6829      	ldr	r1, [r5, #0]
20000ad8:	1a08      	subs	r0, r1, r0
20000ada:	2191      	movs	r1, #145	; 0x91
20000adc:	0089      	lsls	r1, r1, #2
20000ade:	4288      	cmp	r0, r1
20000ae0:	d814      	bhi.n	20000b0c <SCurve_Ramp_Generator+0x80>
        }
      }
      else
      {
        /* Second S-curve of ramp down. */
        if (Motor.Ramp_Dn_Rate < (rampdown_rate << (RATIO_S - 1)))
20000ae2:	42b2      	cmp	r2, r6
20000ae4:	dd01      	ble.n	20000aea <SCurve_Ramp_Generator+0x5e>
        {
          Motor.Ramp_Dn_Rate++;
20000ae6:	3601      	adds	r6, #1
20000ae8:	62a6      	str	r6, [r4, #40]	; 0x28
        }
      }

        if (ADC.ADC_DCLink < VDC_MAX_LIMIT)
20000aea:	4a0f      	ldr	r2, [pc, #60]	; (20000b28 <SCurve_Ramp_Generator+0x9c>)
20000aec:	6a51      	ldr	r1, [r2, #36]	; 0x24
20000aee:	4a0f      	ldr	r2, [pc, #60]	; (20000b2c <SCurve_Ramp_Generator+0xa0>)
20000af0:	4291      	cmp	r1, r2
20000af2:	dc02      	bgt.n	20000afa <SCurve_Ramp_Generator+0x6e>
        {
          /* If DC link voltage Vdc is too high, stop ramp-down motor.*/
          /* Motor ref speed --.*/
          *reference_val -= speedrampstep;
20000af4:	682a      	ldr	r2, [r5, #0]
20000af6:	1ad3      	subs	r3, r2, r3
20000af8:	602b      	str	r3, [r5, #0]
        }
        Motor.Ramp_Counter = 0;
20000afa:	2300      	movs	r3, #0
20000afc:	6423      	str	r3, [r4, #64]	; 0x40
20000afe:	e7e2      	b.n	20000ac6 <SCurve_Ramp_Generator+0x3a>
    if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
    {
      if ((set_val - *reference_val) > SPEED_TH_2ND_S)
      {
        /* First S-curve of ramp up, and constant acceleration. */
        if (Motor.Ramp_Up_Rate > rampup_rate)
20000b00:	42b1      	cmp	r1, r6
20000b02:	dadc      	bge.n	20000abe <SCurve_Ramp_Generator+0x32>
        {
          /* Increase acceleration step by step. */
          Motor.Ramp_Up_Rate--;
20000b04:	3e01      	subs	r6, #1
20000b06:	6266      	str	r6, [r4, #36]	; 0x24
20000b08:	682a      	ldr	r2, [r5, #0]
20000b0a:	e7d8      	b.n	20000abe <SCurve_Ramp_Generator+0x32>
    if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
    {
      if ((*reference_val - set_val) > SPEED_TH_2ND_S)
      {
        /* First S-curve of ramp down, and constant deceleration. */
        if (Motor.Ramp_Dn_Rate > rampdown_rate)
20000b0c:	42b2      	cmp	r2, r6
20000b0e:	daec      	bge.n	20000aea <SCurve_Ramp_Generator+0x5e>
        {
          /* Increase deceleration step by step. */
          Motor.Ramp_Dn_Rate--;
20000b10:	3e01      	subs	r6, #1
20000b12:	62a6      	str	r6, [r4, #40]	; 0x28
20000b14:	e7e9      	b.n	20000aea <SCurve_Ramp_Generator+0x5e>
                                         int32_t speedrampstep, int32_t *reference_val)
{
  if (*reference_val == set_val)
  {
    /* For most of the time, motor ref speed = speed set by POT ADC or PWM. */
    Motor.Ramp_Counter = 0;
20000b16:	2000      	movs	r0, #0
20000b18:	4b02      	ldr	r3, [pc, #8]	; (20000b24 <SCurve_Ramp_Generator+0x98>)
    Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;
20000b1a:	0049      	lsls	r1, r1, #1
                                         int32_t speedrampstep, int32_t *reference_val)
{
  if (*reference_val == set_val)
  {
    /* For most of the time, motor ref speed = speed set by POT ADC or PWM. */
    Motor.Ramp_Counter = 0;
20000b1c:	6418      	str	r0, [r3, #64]	; 0x40
    Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;
20000b1e:	6259      	str	r1, [r3, #36]	; 0x24

    /* Reset to slower ramp up and ramp down for S-curve profile. */
    Motor.Ramp_Dn_Rate = rampdown_rate << (RATIO_S - 1);
20000b20:	629a      	str	r2, [r3, #40]	; 0x28
20000b22:	e7d0      	b.n	20000ac6 <SCurve_Ramp_Generator+0x3a>
20000b24:	20001244 	.word	0x20001244
20000b28:	20001050 	.word	0x20001050
20000b2c:	00000d5b 	.word	0x00000d5b

20000b30 <Misc_Works_of_IRQ>:
#define NON_REALTIME_RATE 64
#define POTADC_LPF    (5U)          // (5U). ADC uses LPF.
/** Miscellaneous works in CCU80_0_IRQHandler, such as tasks that don't need real-time computing
	* -------------------------------------------------------------------------------------------------*/
RAM_ATTRIBUTE void Misc_Works_of_IRQ (void)
{
20000b30:	b508      	push	{r3, lr}
  /* Handle tasks that don't need real-time computing:*/
  #if(UART_ENABLE == USIC_DISABLED_ALL)
      uint16_t pot_adc_result;
  #endif
  /* Counter ++. */
	Motor.Non_RealTime_Counter ++;
20000b32:	4b14      	ldr	r3, [pc, #80]	; (20000b84 <Misc_Works_of_IRQ+0x54>)
20000b34:	6c9a      	ldr	r2, [r3, #72]	; 0x48
20000b36:	3201      	adds	r2, #1
	if (Motor.Non_RealTime_Counter > NON_REALTIME_RATE)
20000b38:	2a40      	cmp	r2, #64	; 0x40
20000b3a:	d921      	bls.n	20000b80 <Misc_Works_of_IRQ+0x50>
	{
	    /* Reset counter.*/
		  Motor.Non_RealTime_Counter = 0;
20000b3c:	2200      	movs	r2, #0
20000b3e:	649a      	str	r2, [r3, #72]	; 0x48
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, SPEED_HIGH_LIMIT, SPEED_LOW_LIMIT);
      #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
        /* POT ADC values 0 ~ 2^12 represent motor target speed of SPEED_LOW_LIMIT ~ SPEED_HIGH_LIMIT:*/


        Motor.Speed_by_POT_PWM = USER_IQ_REF_LOW_LIMIT + (((USER_IQ_REF_HIGH_LIMIT - USER_IQ_REF_LOW_LIMIT) * ADC.ADC_POT) >> 12);
20000b40:	4a11      	ldr	r2, [pc, #68]	; (20000b88 <Misc_Works_of_IRQ+0x58>)
20000b42:	4912      	ldr	r1, [pc, #72]	; (20000b8c <Misc_Works_of_IRQ+0x5c>)
20000b44:	6a12      	ldr	r2, [r2, #32]
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
  {
    return_val = higher_limit;
20000b46:	1c08      	adds	r0, r1, #0
20000b48:	434a      	muls	r2, r1
20000b4a:	0b12      	lsrs	r2, r2, #12
 * API IMPLEMENTATION
 ********************************************************************************************************************/
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
20000b4c:	428a      	cmp	r2, r1
20000b4e:	d909      	bls.n	20000b64 <Misc_Works_of_IRQ+0x34>
 * \par<b>Related APIs:</b><BR>
 * XMC_WDT_GetCounter(), XMC_WDT_SetWindowBounds(), XMC_WDT_SetServicePulseWidth()
 */
__STATIC_INLINE void XMC_WDT_Service(void)
{
  WDT->SRV = XMC_WDT_MAGIC_WORD;
20000b50:	4a0f      	ldr	r2, [pc, #60]	; (20000b90 <Misc_Works_of_IRQ+0x60>)
20000b52:	4910      	ldr	r1, [pc, #64]	; (20000b94 <Misc_Works_of_IRQ+0x64>)
        /* Limit speed, in case ADC values not 0 ~ 2^12.*/
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_IQ_REF_HIGH_LIMIT, USER_IQ_REF_LOW_LIMIT);
20000b54:	60d8      	str	r0, [r3, #12]
20000b56:	6091      	str	r1, [r2, #8]
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_VQ_REF_HIGH_LIMIT, USER_VQ_REF_LOW_LIMIT);
      #endif
			/* Service watchdog. Without WDT service regularly , it will reset system.*/
			XMC_WDT_Service();

			Motor.UART_Counter ++;
20000b58:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20000b5a:	3201      	adds	r2, #1
			if (Motor.UART_Counter > (3U))
20000b5c:	2a03      	cmp	r2, #3
20000b5e:	d80a      	bhi.n	20000b76 <Misc_Works_of_IRQ+0x46>
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_VQ_REF_HIGH_LIMIT, USER_VQ_REF_LOW_LIMIT);
      #endif
			/* Service watchdog. Without WDT service regularly , it will reset system.*/
			XMC_WDT_Service();

			Motor.UART_Counter ++;
20000b60:	651a      	str	r2, [r3, #80]	; 0x50
        #endif
			}

	}

}
20000b62:	bd08      	pop	{r3, pc}
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, SPEED_HIGH_LIMIT, SPEED_LOW_LIMIT);
      #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
        /* POT ADC values 0 ~ 2^12 represent motor target speed of SPEED_LOW_LIMIT ~ SPEED_HIGH_LIMIT:*/


        Motor.Speed_by_POT_PWM = USER_IQ_REF_LOW_LIMIT + (((USER_IQ_REF_HIGH_LIMIT - USER_IQ_REF_LOW_LIMIT) * ADC.ADC_POT) >> 12);
20000b64:	1c10      	adds	r0, r2, #0
20000b66:	490b      	ldr	r1, [pc, #44]	; (20000b94 <Misc_Works_of_IRQ+0x64>)
20000b68:	4a09      	ldr	r2, [pc, #36]	; (20000b90 <Misc_Works_of_IRQ+0x60>)
        /* Limit speed, in case ADC values not 0 ~ 2^12.*/
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_IQ_REF_HIGH_LIMIT, USER_IQ_REF_LOW_LIMIT);
20000b6a:	60d8      	str	r0, [r3, #12]
20000b6c:	6091      	str	r1, [r2, #8]
        Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_VQ_REF_HIGH_LIMIT, USER_VQ_REF_LOW_LIMIT);
      #endif
			/* Service watchdog. Without WDT service regularly , it will reset system.*/
			XMC_WDT_Service();

			Motor.UART_Counter ++;
20000b6e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
20000b70:	3201      	adds	r2, #1
			if (Motor.UART_Counter > (3U))
20000b72:	2a03      	cmp	r2, #3
20000b74:	d9f4      	bls.n	20000b60 <Misc_Works_of_IRQ+0x30>
			{
        /* Reset counter.*/
        Motor.UART_Counter = 0;
20000b76:	2200      	movs	r2, #0
20000b78:	651a      	str	r2, [r3, #80]	; 0x50
        Speed_in_rpm = (Motor.Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM;

        #else
        /* Use UART to adjust POT ADC values, and hence motor speed.*/
        /* Use UART to set POT ADC, by polling.*/
        UART_Set_POT_ADC ();
20000b7a:	f000 fa1d 	bl	20000fb8 <__UART_Set_POT_ADC_veneer>
20000b7e:	e7f0      	b.n	20000b62 <Misc_Works_of_IRQ+0x32>
  /* Handle tasks that don't need real-time computing:*/
  #if(UART_ENABLE == USIC_DISABLED_ALL)
      uint16_t pot_adc_result;
  #endif
  /* Counter ++. */
	Motor.Non_RealTime_Counter ++;
20000b80:	649a      	str	r2, [r3, #72]	; 0x48
20000b82:	e7ee      	b.n	20000b62 <Misc_Works_of_IRQ+0x32>
20000b84:	20001244 	.word	0x20001244
20000b88:	20001050 	.word	0x20001050
20000b8c:	0000b7ae 	.word	0x0000b7ae
20000b90:	40020000 	.word	0x40020000
20000b94:	abadcafe 	.word	0xabadcafe

20000b98 <FOC_Torque_Controller>:
#define CORDIC_ROTATION_MODE    (0x6A)


#if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
__attribute__((section(".ram_code")))  void FOC_Torque_Controller (void)
{
20000b98:	b5f0      	push	{r4, r5, r6, r7, lr}
20000b9a:	4645      	mov	r5, r8
20000b9c:	4657      	mov	r7, sl
20000b9e:	464e      	mov	r6, r9

  /********************************** Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC); **************************************************/
  Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC);
20000ba0:	4b95      	ldr	r3, [pc, #596]	; (20000df8 <FOC_Torque_Controller+0x260>)
#define CORDIC_ROTATION_MODE    (0x6A)


#if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
__attribute__((section(".ram_code")))  void FOC_Torque_Controller (void)
{
20000ba2:	b4e0      	push	{r5, r6, r7}

  /********************************** Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC); **************************************************/
  Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC);
20000ba4:	4698      	mov	r8, r3
20000ba6:	4c95      	ldr	r4, [pc, #596]	; (20000dfc <FOC_Torque_Controller+0x264>)
20000ba8:	1c1a      	adds	r2, r3, #0
#define CORDIC_ROTATION_MODE    (0x6A)


#if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
__attribute__((section(".ram_code")))  void FOC_Torque_Controller (void)
{
20000baa:	b082      	sub	sp, #8

  /********************************** Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC); **************************************************/
  Get_ADCPhaseCurrent(FOCOutput.Previous_SVM_SectorNo, FOCOutput.New_SVM_SectorNo, &ADC);
20000bac:	8b20      	ldrh	r0, [r4, #24]
20000bae:	8b61      	ldrh	r1, [r4, #26]
20000bb0:	f7ff fd56 	bl	20000660 <Get_ADCPhaseCurrent>


  /********************************** Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current); **************************************************/
  Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
20000bb4:	4643      	mov	r3, r8
20000bb6:	4e92      	ldr	r6, [pc, #584]	; (20000e00 <FOC_Torque_Controller+0x268>)
20000bb8:	8818      	ldrh	r0, [r3, #0]
20000bba:	889a      	ldrh	r2, [r3, #4]
20000bbc:	8859      	ldrh	r1, [r3, #2]
20000bbe:	1c33      	adds	r3, r6, #0
20000bc0:	f7ff fe92 	bl	200008e8 <Current_Reconstruction>

  Motor.Speed = PLL_Estimator.RotorSpeed_In;
20000bc4:	4d8f      	ldr	r5, [pc, #572]	; (20000e04 <FOC_Torque_Controller+0x26c>)
20000bc6:	4b90      	ldr	r3, [pc, #576]	; (20000e08 <FOC_Torque_Controller+0x270>)
20000bc8:	692a      	ldr	r2, [r5, #16]
  /* Motor reference speed */
  FOCInput.Ref_Speed = Motor.Ref_Speed;
20000bca:	4f90      	ldr	r7, [pc, #576]	; (20000e0c <FOC_Torque_Controller+0x274>)


  /********************************** Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current); **************************************************/
  Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);

  Motor.Speed = PLL_Estimator.RotorSpeed_In;
20000bcc:	609a      	str	r2, [r3, #8]
  /* Motor reference speed */
  FOCInput.Ref_Speed = Motor.Ref_Speed;
20000bce:	685b      	ldr	r3, [r3, #4]
  HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
  HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));

#else

  if(SVM.Flag_3or2_ADC == 0){
20000bd0:	4a8f      	ldr	r2, [pc, #572]	; (20000e10 <FOC_Torque_Controller+0x278>)
20000bd2:	643b      	str	r3, [r7, #64]	; 0x40
20000bd4:	8892      	ldrh	r2, [r2, #4]

  /**********************************  ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);**************************************************/

  ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
20000bd6:	6873      	ldr	r3, [r6, #4]
20000bd8:	6830      	ldr	r0, [r6, #0]
20000bda:	469c      	mov	ip, r3
20000bdc:	68b3      	ldr	r3, [r6, #8]
20000bde:	2a00      	cmp	r2, #0
20000be0:	d000      	beq.n	20000be4 <FOC_Torque_Controller+0x4c>
20000be2:	e0c2      	b.n	20000d6a <FOC_Torque_Controller+0x1d2>
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
20000be4:	4661      	mov	r1, ip
20000be6:	0042      	lsls	r2, r0, #1
20000be8:	18c9      	adds	r1, r1, r3
20000bea:	1a50      	subs	r0, r2, r1

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000bec:	4662      	mov	r2, ip

#else

  if(SVM.Flag_3or2_ADC == 0){
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
20000bee:	4989      	ldr	r1, [pc, #548]	; (20000e14 <FOC_Torque_Controller+0x27c>)

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000bf0:	1ad3      	subs	r3, r2, r3
20000bf2:	4a89      	ldr	r2, [pc, #548]	; (20000e18 <FOC_Torque_Controller+0x280>)

#else

  if(SVM.Flag_3or2_ADC == 0){
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
20000bf4:	4341      	muls	r1, r0

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000bf6:	435a      	muls	r2, r3

#else

  if(SVM.Flag_3or2_ADC == 0){
    /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
    HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << (CORDIC_SHIFT-14));
20000bf8:	4888      	ldr	r0, [pc, #544]	; (20000e1c <FOC_Torque_Controller+0x284>)
20000bfa:	6001      	str	r1, [r0, #0]

    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000bfc:	6042      	str	r2, [r0, #4]
 *      MATH->CORRY
 */
inline RAM_ATTRIBUTE void ParkTransform (int32_t I_Alpha1Q31, int32_t I_Beta_1Q31, int32_t RotorAngleQ31)
{
  /* General control of CORDIC Control Register */
  MATH->CON = CORDIC_ROTATION_MODE;
20000bfe:	206a      	movs	r0, #106	; 0x6a
 *      FOCOutput.I_d
 */
inline RAM_ATTRIBUTE void ParkTransform_GetResult(ParkTransformType* const HandlePtr)
{
  /* Wait if CORDIC is still running calculation */
  while (MATH->STATC & 0x01)
20000c00:	2601      	movs	r6, #1
 *      MATH->CORRY
 */
inline RAM_ATTRIBUTE void ParkTransform (int32_t I_Alpha1Q31, int32_t I_Beta_1Q31, int32_t RotorAngleQ31)
{
  /* General control of CORDIC Control Register */
  MATH->CON = CORDIC_ROTATION_MODE;
20000c02:	4b87      	ldr	r3, [pc, #540]	; (20000e20 <FOC_Torque_Controller+0x288>)
20000c04:	6458      	str	r0, [r3, #68]	; 0x44

  /* Z = φ, Hall rotor angle, or estimated rotor angle of last PWM cycle from PLL */
  MATH->CORDZ = RotorAngleQ31;
20000c06:	68e8      	ldr	r0, [r5, #12]
20000c08:	6518      	str	r0, [r3, #80]	; 0x50

  /* Y = I_Alpha */
  MATH->CORDY = I_Alpha1Q31;
20000c0a:	64d9      	str	r1, [r3, #76]	; 0x4c

  /* X = I_Beta. Input CORDX data, and auto start of CORDIC calculation (~62 kernel clock cycles) */
  MATH->CORDX = I_Beta_1Q31;
20000c0c:	649a      	str	r2, [r3, #72]	; 0x48

  /**********************************  ParkTransform(Clarke_Transform.I_Alpha_1Q31, Clarke_Transform.I_Beta_1Q31, PLL_Estimator.RotorAngleQ31);**************************************************/
  ParkTransform(Clarke_Transform.I_Alpha_1Q31, Clarke_Transform.I_Beta_1Q31, PLL_Estimator.RotorAngleQ31);

  /* Record previous SVM sector number */
  FOCOutput.Previous_SVM_SectorNo = FOCOutput.New_SVM_SectorNo;
20000c0e:	8b60      	ldrh	r0, [r4, #26]
20000c10:	8320      	strh	r0, [r4, #24]
 *      FOCOutput.I_d
 */
inline RAM_ATTRIBUTE void ParkTransform_GetResult(ParkTransformType* const HandlePtr)
{
  /* Wait if CORDIC is still running calculation */
  while (MATH->STATC & 0x01)
20000c12:	6c1c      	ldr	r4, [r3, #64]	; 0x40
20000c14:	4882      	ldr	r0, [pc, #520]	; (20000e20 <FOC_Torque_Controller+0x288>)
20000c16:	4226      	tst	r6, r4
20000c18:	d1fb      	bne.n	20000c12 <FOC_Torque_Controller+0x7a>
  {
    continue;
  }
  /* Read CORDIC results Iq and Id - 32-bit. CORDIC Result Register [7:0] are 0x00 */
  HandlePtr->Iq = MATH->CORRX;
20000c1a:	6d43      	ldr	r3, [r0, #84]	; 0x54
  HandlePtr->Id = MATH->CORRY;
20000c1c:	6d84      	ldr	r4, [r0, #88]	; 0x58
  HandlePtr->Iq >>= CORDIC_SHIFT;

  /* Shift to get real results */
  HandlePtr->Id >>= CORDIC_SHIFT;

  HandlePtr->Iq = (HandlePtr->Iq * 311) >> 8;   // x MPS/K.;
20000c1e:	4881      	ldr	r0, [pc, #516]	; (20000e24 <FOC_Torque_Controller+0x28c>)
  /* Read CORDIC results Iq and Id - 32-bit. CORDIC Result Register [7:0] are 0x00 */
  HandlePtr->Iq = MATH->CORRX;
  HandlePtr->Id = MATH->CORRY;

  /*CPU computes the following simultaneously when CORDIC #2 is computing */
  HandlePtr->Iq >>= CORDIC_SHIFT;
20000c20:	139b      	asrs	r3, r3, #14

  /* Shift to get real results */
  HandlePtr->Id >>= CORDIC_SHIFT;

  HandlePtr->Iq = (HandlePtr->Iq * 311) >> 8;   // x MPS/K.;
20000c22:	4681      	mov	r9, r0
20000c24:	2038      	movs	r0, #56	; 0x38
20000c26:	464e      	mov	r6, r9
20000c28:	30ff      	adds	r0, #255	; 0xff
20000c2a:	4343      	muls	r3, r0
20000c2c:	121b      	asrs	r3, r3, #8
20000c2e:	6073      	str	r3, [r6, #4]

  /*CPU computes the following simultaneously when CORDIC #2 is computing */
  HandlePtr->Iq >>= CORDIC_SHIFT;

  /* Shift to get real results */
  HandlePtr->Id >>= CORDIC_SHIFT;
20000c30:	13a3      	asrs	r3, r4, #14

  HandlePtr->Iq = (HandlePtr->Iq * 311) >> 8;   // x MPS/K.;

  HandlePtr->Id = (HandlePtr->Id * 311) >> 8;   // x MPS/K.;
20000c32:	4358      	muls	r0, r3

  /**********************************  ParkTransform_GetResult(&Park_Transform);**************************************************/
  ParkTransform_GetResult(&Park_Transform);

  /**********************************  PLL_Imag(Car2Polar.Vref_AngleQ31, Clarke_Transform.I_Alpha_1Q31,Clarke_Transform.I_Beta_1Q31);**************************************************/
  PLL_Imag(Car2Polar.Vref_AngleQ31, Clarke_Transform.I_Alpha_1Q31,Clarke_Transform.I_Beta_1Q31);
20000c34:	4c7c      	ldr	r4, [pc, #496]	; (20000e28 <FOC_Torque_Controller+0x290>)
20000c36:	1200      	asrs	r0, r0, #8
20000c38:	6030      	str	r0, [r6, #0]
20000c3a:	68e0      	ldr	r0, [r4, #12]
20000c3c:	f000 f932 	bl	20000ea4 <PLL_Imag>

  /**********************************    PI_controller(FOCInput.Ref_Iq, Park_Transform.Iq, &PI_Torque);**************************************************/
  PI_controller_anti_windup(FOCInput.Ref_Iq, Park_Transform.Iq, &PI_Torque);
20000c40:	6873      	ldr	r3, [r6, #4]
20000c42:	469c      	mov	ip, r3
__STATIC_INLINE RAM_ATTRIBUTE void PI_controller_anti_windup(int32_t reference, int32_t feedback,
                                                             PI_Coefs_Type *PI_data)
{
  static int32_t Tmp_Ik_Uk;

  PI_data->error = reference - feedback;
20000c44:	4662      	mov	r2, ip
20000c46:	6d3b      	ldr	r3, [r7, #80]	; 0x50
20000c48:	1a9e      	subs	r6, r3, r2

  if(PI_data->Uk_limit_status == 0)
20000c4a:	2224      	movs	r2, #36	; 0x24
__STATIC_INLINE RAM_ATTRIBUTE void PI_controller_anti_windup(int32_t reference, int32_t feedback,
                                                             PI_Coefs_Type *PI_data)
{
  static int32_t Tmp_Ik_Uk;

  PI_data->error = reference - feedback;
20000c4c:	4b77      	ldr	r3, [pc, #476]	; (20000e2c <FOC_Torque_Controller+0x294>)
20000c4e:	601e      	str	r6, [r3, #0]

  if(PI_data->Uk_limit_status == 0)
20000c50:	5c9a      	ldrb	r2, [r3, r2]
20000c52:	2a00      	cmp	r2, #0
20000c54:	d100      	bne.n	20000c58 <FOC_Torque_Controller+0xc0>
20000c56:	e07c      	b.n	20000d52 <FOC_Torque_Controller+0x1ba>
20000c58:	6898      	ldr	r0, [r3, #8]
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
  }

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
20000c5a:	899a      	ldrh	r2, [r3, #12]
20000c5c:	4372      	muls	r2, r6
20000c5e:	1811      	adds	r1, r2, r0
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
20000c60:	2010      	movs	r0, #16
20000c62:	5e1a      	ldrsh	r2, [r3, r0]
20000c64:	4e72      	ldr	r6, [pc, #456]	; (20000e30 <FOC_Torque_Controller+0x298>)
20000c66:	4111      	asrs	r1, r2
20000c68:	1e0a      	subs	r2, r1, #0
20000c6a:	6031      	str	r1, [r6, #0]
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000c6c:	6a19      	ldr	r1, [r3, #32]
20000c6e:	69d8      	ldr	r0, [r3, #28]
 * API IMPLEMENTATION
 ********************************************************************************************************************/
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
20000c70:	428a      	cmp	r2, r1
20000c72:	dc03      	bgt.n	20000c7c <FOC_Torque_Controller+0xe4>
  {
    return_val = higher_limit;
  }
  else if ( input_val < lower_limit )
20000c74:	4282      	cmp	r2, r0
20000c76:	db00      	blt.n	20000c7a <FOC_Torque_Controller+0xe2>
20000c78:	e092      	b.n	20000da0 <FOC_Torque_Controller+0x208>
20000c7a:	1c01      	adds	r1, r0, #0
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
  if(PI_data->Uk != Tmp_Ik_Uk)
  {
    PI_data->Uk_limit_status = 1;
20000c7c:	2201      	movs	r2, #1

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000c7e:	6059      	str	r1, [r3, #4]
20000c80:	2024      	movs	r0, #36	; 0x24
20000c82:	541a      	strb	r2, [r3, r0]
__STATIC_INLINE RAM_ATTRIBUTE void Over_current_Protection_check(int32_t IDCLink, int32_t current_iq, uint16_t *factor)
{

    uint8_t status;

    if(IDCLink > IDC_MAX_LIMIT)
20000c84:	4643      	mov	r3, r8
20000c86:	6a9a      	ldr	r2, [r3, #40]	; 0x28
20000c88:	4b6a      	ldr	r3, [pc, #424]	; (20000e34 <FOC_Torque_Controller+0x29c>)

  Car2Polar.Torque_Vq = PI_Torque.Uk;
20000c8a:	6061      	str	r1, [r4, #4]
20000c8c:	429a      	cmp	r2, r3
20000c8e:	d803      	bhi.n	20000c98 <FOC_Torque_Controller+0x100>
    {
      status = 1;
    }
    #if((MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC) || (MY_FOC_CONTROL_SCHEME == CONSTANT_VQ_DIRECT_FOC))
    else if(current_iq > USER_IQ_REF_HIGH_LIMIT)
20000c90:	4b69      	ldr	r3, [pc, #420]	; (20000e38 <FOC_Torque_Controller+0x2a0>)
20000c92:	459c      	cmp	ip, r3
20000c94:	d800      	bhi.n	20000c98 <FOC_Torque_Controller+0x100>
20000c96:	e07b      	b.n	20000d90 <FOC_Torque_Controller+0x1f8>
      status = 0;
    }

    if(status)
    {
      if(*factor > 5)
20000c98:	8bfb      	ldrh	r3, [r7, #30]
20000c9a:	2b05      	cmp	r3, #5
20000c9c:	d900      	bls.n	20000ca0 <FOC_Torque_Controller+0x108>
20000c9e:	e074      	b.n	20000d8a <FOC_Torque_Controller+0x1f2>

  #if(OVERCURRENT_PROTECTION == ENABLED)
    Over_current_Protection_check(ADC.ADC_IDCLink, Park_Transform.Iq, &FOCInput.overcurrent_factor);
  #endif

  PLL_Imag_GetResult(&PLL_Estimator);
20000ca0:	1c28      	adds	r0, r5, #0
20000ca2:	f000 f90b 	bl	20000ebc <PLL_Imag_GetResult>

  PLL_Vref(PLL_Estimator.Delta_IV, Car2Polar.Vref32, PI_PLL.Uk, FOCInput.Phase_L,&PLL_Estimator);
20000ca6:	4b65      	ldr	r3, [pc, #404]	; (20000e3c <FOC_Torque_Controller+0x2a4>)
20000ca8:	685a      	ldr	r2, [r3, #4]
20000caa:	9500      	str	r5, [sp, #0]
20000cac:	68a1      	ldr	r1, [r4, #8]
20000cae:	683b      	ldr	r3, [r7, #0]
20000cb0:	6868      	ldr	r0, [r5, #4]
20000cb2:	f000 f90b 	bl	20000ecc <PLL_Vref>
__STATIC_INLINE RAM_ATTRIBUTE void PI_controller_anti_windup(int32_t reference, int32_t feedback,
                                                             PI_Coefs_Type *PI_data)
{
  static int32_t Tmp_Ik_Uk;

  PI_data->error = reference - feedback;
20000cb6:	464b      	mov	r3, r9

  if(PI_data->Uk_limit_status == 0)
20000cb8:	2124      	movs	r1, #36	; 0x24
__STATIC_INLINE RAM_ATTRIBUTE void PI_controller_anti_windup(int32_t reference, int32_t feedback,
                                                             PI_Coefs_Type *PI_data)
{
  static int32_t Tmp_Ik_Uk;

  PI_data->error = reference - feedback;
20000cba:	681b      	ldr	r3, [r3, #0]
20000cbc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
20000cbe:	1ad2      	subs	r2, r2, r3
20000cc0:	4b5f      	ldr	r3, [pc, #380]	; (20000e40 <FOC_Torque_Controller+0x2a8>)
20000cc2:	601a      	str	r2, [r3, #0]

  if(PI_data->Uk_limit_status == 0)
20000cc4:	5c59      	ldrb	r1, [r3, r1]
20000cc6:	2900      	cmp	r1, #0
20000cc8:	d037      	beq.n	20000d3a <FOC_Torque_Controller+0x1a2>
20000cca:	6898      	ldr	r0, [r3, #8]
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
  }

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
20000ccc:	8999      	ldrh	r1, [r3, #12]
20000cce:	434a      	muls	r2, r1
20000cd0:	1811      	adds	r1, r2, r0
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
20000cd2:	2010      	movs	r0, #16
20000cd4:	5e1a      	ldrsh	r2, [r3, r0]
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000cd6:	69d8      	ldr	r0, [r3, #28]
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
  }

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
20000cd8:	4111      	asrs	r1, r2
20000cda:	1e0a      	subs	r2, r1, #0
20000cdc:	6031      	str	r1, [r6, #0]
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000cde:	6a19      	ldr	r1, [r3, #32]
 * API IMPLEMENTATION
 ********************************************************************************************************************/
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
20000ce0:	428a      	cmp	r2, r1
20000ce2:	dc03      	bgt.n	20000cec <FOC_Torque_Controller+0x154>
  {
    return_val = higher_limit;
  }
  else if ( input_val < lower_limit )
20000ce4:	4282      	cmp	r2, r0
20000ce6:	db00      	blt.n	20000cea <FOC_Torque_Controller+0x152>
20000ce8:	e06c      	b.n	20000dc4 <FOC_Torque_Controller+0x22c>
20000cea:	1c01      	adds	r1, r0, #0
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
  if(PI_data->Uk != Tmp_Ik_Uk)
  {
    PI_data->Uk_limit_status = 1;
20000cec:	2201      	movs	r2, #1

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000cee:	6059      	str	r1, [r3, #4]
20000cf0:	2024      	movs	r0, #36	; 0x24
20000cf2:	541a      	strb	r2, [r3, r0]

  Car2Polar.Flux_Vd = PI_Flux.Uk;

  /**********************************   PLL_Vref_GetResult(&PLL_Estimator);**************************************************/

  PLL_Vref_GetResult(&PLL_Estimator);
20000cf4:	1c28      	adds	r0, r5, #0

  /**********************************     PI_controller(FOCInput.Ref_Id, Park_Transform.Id, &PI_Flux);**************************************************/

  PI_controller_anti_windup(FOCInput.Ref_Id, Park_Transform.Id, &PI_Flux);

  Car2Polar.Flux_Vd = PI_Flux.Uk;
20000cf6:	6021      	str	r1, [r4, #0]

  /**********************************   PLL_Vref_GetResult(&PLL_Estimator);**************************************************/

  PLL_Vref_GetResult(&PLL_Estimator);
20000cf8:	f000 f90e 	bl	20000f18 <PLL_Vref_GetResult>
 */
inline RAM_ATTRIBUTE void Cart2Polar(int32_t Torque_Vq, int32_t Flux_Vd, int32_t RotorAngleQ31)
{

  /* General control of CORDIC Control Register */
  MATH->CON = CORDIC_VECTORING_MODE;
20000cfc:	2262      	movs	r2, #98	; 0x62
20000cfe:	4e48      	ldr	r6, [pc, #288]	; (20000e20 <FOC_Torque_Controller+0x288>)

  /**********************************    Cart2Polar(Car2Polar.Torque_Vq, Car2Polar.Flux_Vd,PLL_Estimator.RotorAngleQ31);**************************************************/
  Cart2Polar(Car2Polar.Torque_Vq, Car2Polar.Flux_Vd,PLL_Estimator.RotorAngleQ31);
20000d00:	6823      	ldr	r3, [r4, #0]
20000d02:	6472      	str	r2, [r6, #68]	; 0x44

  /* Z = φ. Θ = atan(Vq/Vd) + rotor angle φ, equivalent to Inv. Park Transform */
  MATH->CORDZ = RotorAngleQ31;
20000d04:	68ea      	ldr	r2, [r5, #12]

  /* Y = Vq = PI_Torque.Uk */
  MATH->CORDY = Torque_Vq << CORDIC_SHIFT;

  /* X = Vd = PI_Flux.Uk. Input CORDX data, and auto start of CORDIC calculation */
  MATH->CORDX = Flux_Vd << CORDIC_SHIFT;
20000d06:	039b      	lsls	r3, r3, #14

  /* General control of CORDIC Control Register */
  MATH->CON = CORDIC_VECTORING_MODE;

  /* Z = φ. Θ = atan(Vq/Vd) + rotor angle φ, equivalent to Inv. Park Transform */
  MATH->CORDZ = RotorAngleQ31;
20000d08:	6532      	str	r2, [r6, #80]	; 0x50

  /* Y = Vq = PI_Torque.Uk */
  MATH->CORDY = Torque_Vq << CORDIC_SHIFT;
20000d0a:	6862      	ldr	r2, [r4, #4]

  PLL_GetPosSpd(&PLL_Estimator);
20000d0c:	1c28      	adds	r0, r5, #0
20000d0e:	0392      	lsls	r2, r2, #14
20000d10:	64f2      	str	r2, [r6, #76]	; 0x4c

  /* X = Vd = PI_Flux.Uk. Input CORDX data, and auto start of CORDIC calculation */
  MATH->CORDX = Flux_Vd << CORDIC_SHIFT;
20000d12:	64b3      	str	r3, [r6, #72]	; 0x48
20000d14:	f000 f906 	bl	20000f24 <PLL_GetPosSpd>
 *      FOCInput.Vref_AngleQ31
 */
inline RAM_ATTRIBUTE void Car2Pol_GetResult(Car2PolType * const HandlePtr)
{
  /* Read CORDIC result |Vref| - 32-bit unsigned */
  HandlePtr->Vref32 = MATH->CORRX;
20000d18:	6d73      	ldr	r3, [r6, #84]	; 0x54
20000d1a:	60a3      	str	r3, [r4, #8]

  /* Angle addition by CORDIC directly, where Θ = atan(Vq/Vd), φ is rotor angle */
  HandlePtr->Vref_AngleQ31 = MATH->CORRZ;
20000d1c:	6df2      	ldr	r2, [r6, #92]	; 0x5c

  /**********************************   Car2Pol_GetResult(&Car2Polar);**************************************************/
  Car2Pol_GetResult(&Car2Polar);

  uint32_t SVM_Vref16;
  SVM_Vref16 = Car2Polar.Vref32 >>CORDIC_SHIFT;
20000d1e:	0b9b      	lsrs	r3, r3, #14
20000d20:	60e2      	str	r2, [r4, #12]

  SVM_Vref16 = (SVM_Vref16 * 311) >> 8;
20000d22:	2238      	movs	r2, #56	; 0x38
20000d24:	32ff      	adds	r2, #255	; 0xff
20000d26:	4353      	muls	r3, r2
20000d28:	0a1b      	lsrs	r3, r3, #8
  Car2Polar.Vref32 = SVM_Vref16 << CORDIC_SHIFT;
20000d2a:	039b      	lsls	r3, r3, #14
20000d2c:	60a3      	str	r3, [r4, #8]


}
20000d2e:	b002      	add	sp, #8
20000d30:	bc1c      	pop	{r2, r3, r4}
20000d32:	4690      	mov	r8, r2
20000d34:	4699      	mov	r9, r3
20000d36:	46a2      	mov	sl, r4
20000d38:	bdf0      	pop	{r4, r5, r6, r7, pc}
  PI_data->error = reference - feedback;

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
20000d3a:	6899      	ldr	r1, [r3, #8]
20000d3c:	89d8      	ldrh	r0, [r3, #14]
20000d3e:	468c      	mov	ip, r1
20000d40:	4350      	muls	r0, r2
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d42:	6999      	ldr	r1, [r3, #24]
  PI_data->error = reference - feedback;

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
20000d44:	4460      	add	r0, ip
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d46:	695f      	ldr	r7, [r3, #20]
 * API IMPLEMENTATION
 ********************************************************************************************************************/
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
20000d48:	4288      	cmp	r0, r1
20000d4a:	dd34      	ble.n	20000db6 <FOC_Torque_Controller+0x21e>

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d4c:	6099      	str	r1, [r3, #8]
20000d4e:	1c08      	adds	r0, r1, #0
20000d50:	e7bc      	b.n	20000ccc <FOC_Torque_Controller+0x134>
  PI_data->error = reference - feedback;

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
20000d52:	689a      	ldr	r2, [r3, #8]
20000d54:	89d8      	ldrh	r0, [r3, #14]
20000d56:	4692      	mov	sl, r2
20000d58:	4370      	muls	r0, r6
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d5a:	6999      	ldr	r1, [r3, #24]
  PI_data->error = reference - feedback;

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
20000d5c:	4450      	add	r0, sl
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d5e:	695a      	ldr	r2, [r3, #20]
 * API IMPLEMENTATION
 ********************************************************************************************************************/
__STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t lower_limit)
{
  int32_t return_val;
  if ( input_val > higher_limit )
20000d60:	4288      	cmp	r0, r1
20000d62:	dd21      	ble.n	20000da8 <FOC_Torque_Controller+0x210>

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000d64:	6099      	str	r1, [r3, #8]
20000d66:	1c08      	adds	r0, r1, #0
20000d68:	e777      	b.n	20000c5a <FOC_Torque_Controller+0xc2>
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
20000d6a:	8b22      	ldrh	r2, [r4, #24]
20000d6c:	2a02      	cmp	r2, #2
20000d6e:	d82d      	bhi.n	20000dcc <FOC_Torque_Controller+0x234>
20000d70:	2a00      	cmp	r2, #0
20000d72:	d137      	bne.n	20000de4 <FOC_Torque_Controller+0x24c>
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
20000d74:	4662      	mov	r2, ip
20000d76:	18d1      	adds	r1, r2, r3
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000d78:	1ad3      	subs	r3, r2, r3
20000d7a:	4a27      	ldr	r2, [pc, #156]	; (20000e18 <FOC_Torque_Controller+0x280>)
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
20000d7c:	4827      	ldr	r0, [pc, #156]	; (20000e1c <FOC_Torque_Controller+0x284>)
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000d7e:	435a      	muls	r2, r3
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
    {
      case 0:
      case 5:
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
20000d80:	4249      	negs	r1, r1
20000d82:	0389      	lsls	r1, r1, #14
20000d84:	6001      	str	r1, [r0, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
20000d86:	6042      	str	r2, [r0, #4]
20000d88:	e739      	b.n	20000bfe <FOC_Torque_Controller+0x66>

    if(status)
    {
      if(*factor > 5)
      {
        *factor -= 4;
20000d8a:	3b04      	subs	r3, #4
20000d8c:	83fb      	strh	r3, [r7, #30]
20000d8e:	e787      	b.n	20000ca0 <FOC_Torque_Controller+0x108>
      }
    }
    else
    {
      if(*factor < 4096)
20000d90:	8bfb      	ldrh	r3, [r7, #30]
20000d92:	4a2c      	ldr	r2, [pc, #176]	; (20000e44 <FOC_Torque_Controller+0x2ac>)
20000d94:	4293      	cmp	r3, r2
20000d96:	d900      	bls.n	20000d9a <FOC_Torque_Controller+0x202>
20000d98:	e782      	b.n	20000ca0 <FOC_Torque_Controller+0x108>
      {
        *factor += 2;
20000d9a:	3302      	adds	r3, #2
20000d9c:	83fb      	strh	r3, [r7, #30]
20000d9e:	e77f      	b.n	20000ca0 <FOC_Torque_Controller+0x108>

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000da0:	605a      	str	r2, [r3, #4]
20000da2:	1c11      	adds	r1, r2, #0
  {
    PI_data->Uk_limit_status = 1;
  }
  else
  {
    PI_data->Uk_limit_status = 0;
20000da4:	2200      	movs	r2, #0
20000da6:	e76b      	b.n	20000c80 <FOC_Torque_Controller+0xe8>
20000da8:	1e01      	subs	r1, r0, #0
20000daa:	4291      	cmp	r1, r2
20000dac:	dada      	bge.n	20000d64 <FOC_Torque_Controller+0x1cc>
20000dae:	1c11      	adds	r1, r2, #0

  if(PI_data->Uk_limit_status == 0)
  {
    /* Integral output I[k] = I[k-1] + Ki * error[k] */
    Tmp_Ik_Uk = ((int32_t)PI_data->Ki * PI_data->error) + PI_data->Ik;
    PI_data->Ik = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Ik_limit_max, PI_data->Ik_limit_min);
20000db0:	6099      	str	r1, [r3, #8]
20000db2:	1c08      	adds	r0, r1, #0
20000db4:	e751      	b.n	20000c5a <FOC_Torque_Controller+0xc2>
20000db6:	1e01      	subs	r1, r0, #0
20000db8:	42b9      	cmp	r1, r7
20000dba:	dac7      	bge.n	20000d4c <FOC_Torque_Controller+0x1b4>
20000dbc:	1c39      	adds	r1, r7, #0
20000dbe:	6099      	str	r1, [r3, #8]
20000dc0:	1c08      	adds	r0, r1, #0
20000dc2:	e783      	b.n	20000ccc <FOC_Torque_Controller+0x134>

  /* PI output U[k] = Kp * error[k] + I[k] */
  Tmp_Ik_Uk = ((int32_t)PI_data->Kp * PI_data->error) + PI_data->Ik;
  Tmp_Ik_Uk = Tmp_Ik_Uk >> PI_data->Scale_KpKi;
  /* Check U[k] output limit */
  PI_data->Uk = MIN_MAX_LIMIT(Tmp_Ik_Uk, PI_data->Uk_limit_max, PI_data->Uk_limit_min);
20000dc4:	605a      	str	r2, [r3, #4]
20000dc6:	1c11      	adds	r1, r2, #0
  {
    PI_data->Uk_limit_status = 1;
  }
  else
  {
    PI_data->Uk_limit_status = 0;
20000dc8:	2200      	movs	r2, #0
20000dca:	e791      	b.n	20000cf0 <FOC_Torque_Controller+0x158>
    /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
    HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
  }
  else
  {
    switch(FOCOutput.Previous_SVM_SectorNo)
20000dcc:	2a05      	cmp	r2, #5
20000dce:	d0d1      	beq.n	20000d74 <FOC_Torque_Controller+0x1dc>
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
20000dd0:	4663      	mov	r3, ip
20000dd2:	005b      	lsls	r3, r3, #1
20000dd4:	18c2      	adds	r2, r0, r3
20000dd6:	4b10      	ldr	r3, [pc, #64]	; (20000e18 <FOC_Torque_Controller+0x280>)
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
20000dd8:	4e10      	ldr	r6, [pc, #64]	; (20000e1c <FOC_Torque_Controller+0x284>)
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
20000dda:	435a      	muls	r2, r3
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
        break;
      default:
          HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
20000ddc:	0381      	lsls	r1, r0, #14
20000dde:	6031      	str	r1, [r6, #0]
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14));
20000de0:	6072      	str	r2, [r6, #4]
20000de2:	e70c      	b.n	20000bfe <FOC_Torque_Controller+0x66>
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
20000de4:	005b      	lsls	r3, r3, #1
20000de6:	18c2      	adds	r2, r0, r3
20000de8:	4b17      	ldr	r3, [pc, #92]	; (20000e48 <FOC_Torque_Controller+0x2b0>)
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
20000dea:	4e0c      	ldr	r6, [pc, #48]	; (20000e1c <FOC_Torque_Controller+0x284>)
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
20000dec:	435a      	muls	r2, r3
          HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
          HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14));
      break;
      case 1:
      case 2:
          HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
20000dee:	0381      	lsls	r1, r0, #14
20000df0:	6031      	str	r1, [r6, #0]
          HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CORDIC_SHIFT-14)));
20000df2:	6072      	str	r2, [r6, #4]
20000df4:	e703      	b.n	20000bfe <FOC_Torque_Controller+0x66>
20000df6:	46c0      	nop			; (mov r8, r8)
20000df8:	20001050 	.word	0x20001050
20000dfc:	20001198 	.word	0x20001198
20000e00:	200010c4 	.word	0x200010c4
20000e04:	20001354 	.word	0x20001354
20000e08:	20001244 	.word	0x20001244
20000e0c:	200011c8 	.word	0x200011c8
20000e10:	20001018 	.word	0x20001018
20000e14:	00001555 	.word	0x00001555
20000e18:	000024f3 	.word	0x000024f3
20000e1c:	200010bc 	.word	0x200010bc
20000e20:	40030000 	.word	0x40030000
20000e24:	200010d8 	.word	0x200010d8
20000e28:	2000109c 	.word	0x2000109c
20000e2c:	20001170 	.word	0x20001170
20000e30:	2000100c 	.word	0x2000100c
20000e34:	000009d7 	.word	0x000009d7
20000e38:	0000b7ae 	.word	0x0000b7ae
20000e3c:	20001120 	.word	0x20001120
20000e40:	20001148 	.word	0x20001148
20000e44:	00000fff 	.word	0x00000fff
20000e48:	ffffdb0d 	.word	0xffffdb0d

20000e4c <Linear_Torque_Ramp_Generator>:


__attribute__((section(".ram_code"))) void Linear_Torque_Ramp_Generator(int32_t current_set, int32_t inc_step, int32_t dec_step, FOCInputType* const HandlePtr)
{
20000e4c:	b530      	push	{r4, r5, lr}
    static uint32_t Iq_counter = 0;

    Iq_counter++;
20000e4e:	4d10      	ldr	r5, [pc, #64]	; (20000e90 <Linear_Torque_Ramp_Generator+0x44>)
20000e50:	682c      	ldr	r4, [r5, #0]
20000e52:	3401      	adds	r4, #1
20000e54:	602c      	str	r4, [r5, #0]
    if(Iq_counter >= USER_IQ_RAMP_SLEWRATE)
20000e56:	2c00      	cmp	r4, #0
20000e58:	d106      	bne.n	20000e68 <Linear_Torque_Ramp_Generator+0x1c>
20000e5a:	6d1c      	ldr	r4, [r3, #80]	; 0x50

        }
    }

    /* Limit protection for ref_iq, the max value is capped up to 1Q15*/
    if(HandlePtr->Ref_Iq > USER_IQ_REF_HIGH_LIMIT)
20000e5c:	4a0d      	ldr	r2, [pc, #52]	; (20000e94 <Linear_Torque_Ramp_Generator+0x48>)
20000e5e:	4294      	cmp	r4, r2
20000e60:	d901      	bls.n	20000e66 <Linear_Torque_Ramp_Generator+0x1a>
      HandlePtr->Ref_Iq = USER_IQ_REF_HIGH_LIMIT - 1;
20000e62:	4a0d      	ldr	r2, [pc, #52]	; (20000e98 <Linear_Torque_Ramp_Generator+0x4c>)
20000e64:	651a      	str	r2, [r3, #80]	; 0x50

}
20000e66:	bd30      	pop	{r4, r5, pc}
    static uint32_t Iq_counter = 0;

    Iq_counter++;
    if(Iq_counter >= USER_IQ_RAMP_SLEWRATE)
    {
        Iq_counter = 0;
20000e68:	2400      	movs	r4, #0
20000e6a:	602c      	str	r4, [r5, #0]
        if( HandlePtr->Ref_Iq < current_set)
20000e6c:	6d1c      	ldr	r4, [r3, #80]	; 0x50
20000e6e:	4284      	cmp	r4, r0
20000e70:	da02      	bge.n	20000e78 <Linear_Torque_Ramp_Generator+0x2c>
        {
          HandlePtr->Ref_Iq += inc_step;
20000e72:	1864      	adds	r4, r4, r1
20000e74:	651c      	str	r4, [r3, #80]	; 0x50
20000e76:	e7f1      	b.n	20000e5c <Linear_Torque_Ramp_Generator+0x10>
        }
        else if(HandlePtr->Ref_Iq > current_set)
20000e78:	4284      	cmp	r4, r0
20000e7a:	ddef      	ble.n	20000e5c <Linear_Torque_Ramp_Generator+0x10>
        {
          if((HandlePtr->Ref_Iq >= dec_step )&& (ADC.ADC_DCLink < VDC_MAX_LIMIT))
20000e7c:	4294      	cmp	r4, r2
20000e7e:	dbed      	blt.n	20000e5c <Linear_Torque_Ramp_Generator+0x10>
20000e80:	4906      	ldr	r1, [pc, #24]	; (20000e9c <Linear_Torque_Ramp_Generator+0x50>)
20000e82:	6a48      	ldr	r0, [r1, #36]	; 0x24
20000e84:	4906      	ldr	r1, [pc, #24]	; (20000ea0 <Linear_Torque_Ramp_Generator+0x54>)
20000e86:	4288      	cmp	r0, r1
20000e88:	dce8      	bgt.n	20000e5c <Linear_Torque_Ramp_Generator+0x10>
          {
            HandlePtr->Ref_Iq -=  dec_step;
20000e8a:	1aa4      	subs	r4, r4, r2
20000e8c:	651c      	str	r4, [r3, #80]	; 0x50
20000e8e:	e7e5      	b.n	20000e5c <Linear_Torque_Ramp_Generator+0x10>
20000e90:	20001008 	.word	0x20001008
20000e94:	0000b7ae 	.word	0x0000b7ae
20000e98:	0000b7ad 	.word	0x0000b7ad
20000e9c:	20001050 	.word	0x20001050
20000ea0:	00000d5b 	.word	0x00000d5b

20000ea4 <PLL_Imag>:
20000ea4:	b510      	push	{r4, lr}
20000ea6:	2462      	movs	r4, #98	; 0x62
20000ea8:	4b03      	ldr	r3, [pc, #12]	; (20000eb8 <PLL_Imag+0x14>)
20000eaa:	4240      	negs	r0, r0
20000eac:	645c      	str	r4, [r3, #68]	; 0x44
20000eae:	6518      	str	r0, [r3, #80]	; 0x50
20000eb0:	64da      	str	r2, [r3, #76]	; 0x4c
20000eb2:	6499      	str	r1, [r3, #72]	; 0x48
20000eb4:	bd10      	pop	{r4, pc}
20000eb6:	46c0      	nop			; (mov r8, r8)
20000eb8:	40030000 	.word	0x40030000

20000ebc <PLL_Imag_GetResult>:
20000ebc:	4b02      	ldr	r3, [pc, #8]	; (20000ec8 <PLL_Imag_GetResult+0xc>)
20000ebe:	6d5a      	ldr	r2, [r3, #84]	; 0x54
20000ec0:	6002      	str	r2, [r0, #0]
20000ec2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
20000ec4:	6043      	str	r3, [r0, #4]
20000ec6:	4770      	bx	lr
20000ec8:	40030000 	.word	0x40030000

20000ecc <PLL_Vref>:
20000ecc:	b530      	push	{r4, r5, lr}
20000ece:	256a      	movs	r5, #106	; 0x6a
20000ed0:	4b0f      	ldr	r3, [pc, #60]	; (20000f10 <PLL_Vref+0x44>)
20000ed2:	9c03      	ldr	r4, [sp, #12]
20000ed4:	645d      	str	r5, [r3, #68]	; 0x44
20000ed6:	6518      	str	r0, [r3, #80]	; 0x50
20000ed8:	2000      	movs	r0, #0
20000eda:	64d8      	str	r0, [r3, #76]	; 0x4c
20000edc:	6499      	str	r1, [r3, #72]	; 0x48
20000ede:	2138      	movs	r1, #56	; 0x38
20000ee0:	6823      	ldr	r3, [r4, #0]
20000ee2:	31ff      	adds	r1, #255	; 0xff
20000ee4:	0b9b      	lsrs	r3, r3, #14
20000ee6:	434b      	muls	r3, r1
20000ee8:	0a1b      	lsrs	r3, r3, #8
20000eea:	0059      	lsls	r1, r3, #1
20000eec:	18c9      	adds	r1, r1, r3
20000eee:	0089      	lsls	r1, r1, #2
20000ef0:	6023      	str	r3, [r4, #0]
20000ef2:	10d2      	asrs	r2, r2, #3
20000ef4:	18cb      	adds	r3, r1, r3
20000ef6:	4353      	muls	r3, r2
20000ef8:	0bda      	lsrs	r2, r3, #15
20000efa:	2301      	movs	r3, #1
20000efc:	4805      	ldr	r0, [pc, #20]	; (20000f14 <PLL_Vref+0x48>)
20000efe:	8a01      	ldrh	r1, [r0, #16]
20000f00:	408b      	lsls	r3, r1
20000f02:	6a41      	ldr	r1, [r0, #36]	; 0x24
20000f04:	3b01      	subs	r3, #1
20000f06:	4359      	muls	r1, r3
20000f08:	1853      	adds	r3, r2, r1
20000f0a:	089b      	lsrs	r3, r3, #2
20000f0c:	6243      	str	r3, [r0, #36]	; 0x24
20000f0e:	bd30      	pop	{r4, r5, pc}
20000f10:	40030000 	.word	0x40030000
20000f14:	200011c8 	.word	0x200011c8

20000f18 <PLL_Vref_GetResult>:
20000f18:	4b01      	ldr	r3, [pc, #4]	; (20000f20 <PLL_Vref_GetResult+0x8>)
20000f1a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
20000f1c:	6083      	str	r3, [r0, #8]
20000f1e:	4770      	bx	lr
20000f20:	40030000 	.word	0x40030000

20000f24 <PLL_GetPosSpd>:
20000f24:	6883      	ldr	r3, [r0, #8]
20000f26:	491e      	ldr	r1, [pc, #120]	; (20000fa0 <PLL_GetPosSpd+0x7c>)
20000f28:	139a      	asrs	r2, r3, #14
20000f2a:	2338      	movs	r3, #56	; 0x38
20000f2c:	33ff      	adds	r3, #255	; 0xff
20000f2e:	4353      	muls	r3, r2
20000f30:	121a      	asrs	r2, r3, #8
20000f32:	6a0b      	ldr	r3, [r1, #32]
20000f34:	b530      	push	{r4, r5, lr}
20000f36:	005c      	lsls	r4, r3, #1
20000f38:	18e3      	adds	r3, r4, r3
20000f3a:	6082      	str	r2, [r0, #8]
20000f3c:	18d3      	adds	r3, r2, r3
20000f3e:	6a4a      	ldr	r2, [r1, #36]	; 0x24
20000f40:	109b      	asrs	r3, r3, #2
20000f42:	620b      	str	r3, [r1, #32]
20000f44:	189a      	adds	r2, r3, r2
20000f46:	4b17      	ldr	r3, [pc, #92]	; (20000fa4 <PLL_GetPosSpd+0x80>)
20000f48:	4252      	negs	r2, r2
20000f4a:	689c      	ldr	r4, [r3, #8]
20000f4c:	89d9      	ldrh	r1, [r3, #14]
20000f4e:	46a4      	mov	ip, r4
20000f50:	4351      	muls	r1, r2
20000f52:	699c      	ldr	r4, [r3, #24]
20000f54:	4461      	add	r1, ip
20000f56:	695d      	ldr	r5, [r3, #20]
20000f58:	42a1      	cmp	r1, r4
20000f5a:	dc02      	bgt.n	20000f62 <PLL_GetPosSpd+0x3e>
20000f5c:	1e0c      	subs	r4, r1, #0
20000f5e:	42ac      	cmp	r4, r5
20000f60:	db1b      	blt.n	20000f9a <PLL_GetPosSpd+0x76>
20000f62:	8999      	ldrh	r1, [r3, #12]
20000f64:	609c      	str	r4, [r3, #8]
20000f66:	434a      	muls	r2, r1
20000f68:	18a2      	adds	r2, r4, r2
20000f6a:	2410      	movs	r4, #16
20000f6c:	5f19      	ldrsh	r1, [r3, r4]
20000f6e:	69dc      	ldr	r4, [r3, #28]
20000f70:	410a      	asrs	r2, r1
20000f72:	6a19      	ldr	r1, [r3, #32]
20000f74:	428a      	cmp	r2, r1
20000f76:	dc02      	bgt.n	20000f7e <PLL_GetPosSpd+0x5a>
20000f78:	1e11      	subs	r1, r2, #0
20000f7a:	42a1      	cmp	r1, r4
20000f7c:	db0b      	blt.n	20000f96 <PLL_GetPosSpd+0x72>
20000f7e:	68c2      	ldr	r2, [r0, #12]
20000f80:	6059      	str	r1, [r3, #4]
20000f82:	4694      	mov	ip, r2
20000f84:	034b      	lsls	r3, r1, #13
20000f86:	4463      	add	r3, ip
20000f88:	60c3      	str	r3, [r0, #12]
20000f8a:	6903      	ldr	r3, [r0, #16]
20000f8c:	469c      	mov	ip, r3
20000f8e:	4461      	add	r1, ip
20000f90:	0849      	lsrs	r1, r1, #1
20000f92:	6101      	str	r1, [r0, #16]
20000f94:	bd30      	pop	{r4, r5, pc}
20000f96:	1c21      	adds	r1, r4, #0
20000f98:	e7f1      	b.n	20000f7e <PLL_GetPosSpd+0x5a>
20000f9a:	1c2c      	adds	r4, r5, #0
20000f9c:	e7e1      	b.n	20000f62 <PLL_GetPosSpd+0x3e>
20000f9e:	46c0      	nop			; (mov r8, r8)
20000fa0:	200011c8 	.word	0x200011c8
20000fa4:	20001120 	.word	0x20001120

20000fa8 <__Error_Handling_veneer>:
20000fa8:	b401      	push	{r0}
20000faa:	4802      	ldr	r0, [pc, #8]	; (20000fb4 <__Error_Handling_veneer+0xc>)
20000fac:	4684      	mov	ip, r0
20000fae:	bc01      	pop	{r0}
20000fb0:	4760      	bx	ip
20000fb2:	bf00      	nop
20000fb4:	10001c01 	.word	0x10001c01

20000fb8 <__UART_Set_POT_ADC_veneer>:
20000fb8:	b401      	push	{r0}
20000fba:	4802      	ldr	r0, [pc, #8]	; (20000fc4 <__UART_Set_POT_ADC_veneer+0xc>)
20000fbc:	4684      	mov	ip, r0
20000fbe:	bc01      	pop	{r0}
20000fc0:	4760      	bx	ip
20000fc2:	bf00      	nop
20000fc4:	10001145 	.word	0x10001145

20000fc8 <__DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge_veneer>:
20000fc8:	b401      	push	{r0}
20000fca:	4802      	ldr	r0, [pc, #8]	; (20000fd4 <__DirectFOC_StartUp_Brake_Motor_Bootstrap_Charge_veneer+0xc>)
20000fcc:	4684      	mov	ip, r0
20000fce:	bc01      	pop	{r0}
20000fd0:	4760      	bx	ip
20000fd2:	bf00      	nop
20000fd4:	10001c5d 	.word	0x10001c5d

20000fd8 <__DirectFOCRotor_Pre_Positioning_veneer>:
20000fd8:	b401      	push	{r0}
20000fda:	4802      	ldr	r0, [pc, #8]	; (20000fe4 <__DirectFOCRotor_Pre_Positioning_veneer+0xc>)
20000fdc:	4684      	mov	ip, r0
20000fde:	bc01      	pop	{r0}
20000fe0:	4760      	bx	ip
20000fe2:	bf00      	nop
20000fe4:	10001ce5 	.word	0x10001ce5

20000fe8 <__Stop_Motor_veneer>:
20000fe8:	b401      	push	{r0}
20000fea:	4802      	ldr	r0, [pc, #8]	; (20000ff4 <__Stop_Motor_veneer+0xc>)
20000fec:	4684      	mov	ip, r0
20000fee:	bc01      	pop	{r0}
20000ff0:	4760      	bx	ip
20000ff2:	bf00      	nop
20000ff4:	10001fc1 	.word	0x10001fc1
