   1              	 .cpu cortex-m0
   2              	 .fpu softvfp
   3              	 .eabi_attribute 20,1
   4              	 .eabi_attribute 21,1
   5              	 .eabi_attribute 23,3
   6              	 .eabi_attribute 24,1
   7              	 .eabi_attribute 25,1
   8              	 .eabi_attribute 26,1
   9              	 .eabi_attribute 30,2
  10              	 .eabi_attribute 34,0
  11              	 .eabi_attribute 18,4
  12              	 .code 16
  13              	 .file "pmsm_foc_interface.c"
  14              	 .text
  15              	.Ltext0:
  16              	 .cfi_sections .debug_frame
  17              	 .section .text.Init_Smooth_Transition_To_FOC,"ax",%progbits
  18              	 .align 2
  19              	 .global Init_Smooth_Transition_To_FOC
  20              	 .code 16
  21              	 .thumb_func
  23              	Init_Smooth_Transition_To_FOC:
  24              	.LFB203:
  25              	 .file 1 "../PMSM_FOC/ControlModules/pmsm_foc_interface.c"
   1:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /**
   2:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @file pmsm_foc_interface.c
   3:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @date 2015-12-16
   4:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
   5:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @cond
   6:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  **************************************************************************************************
   7:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * PMSM FOC Motor Control Library
   8:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
   9:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * All rights reserved.
  11:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  12:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * following conditions are met:
  14:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  15:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  16:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   disclaimer.
  17:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  18:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  19:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  20:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  21:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  22:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *   products derived from this software without specific prior written permission.
  23:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  24:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  32:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * with Infineon Technologies AG (dave@infineon.com).
  34:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  **************************************************************************************************
  35:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  36:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @file pmsm_foc_interface.c
  37:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @date 16 Dec, 2015
  38:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @version 1.0.0
  39:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  40:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @brief ACMP low level driver API prototype definition for XMC1 <br>
  41:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  42:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * <b>Detailed description of file</b> <br>
  43:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * APIs provided in this file mainly cover the following functionality:
  44:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * ---- Filter, Hysterisis, Output inversion
  45:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  46:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * History
  47:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  48:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * 16 Dec 2015 Version 1.0.0 <br>:
  49:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *      Initial version
  50:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * @endcond
  51:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  *
  52:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  */
  53:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
  54:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /**************************************************************************************************
  55:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * HEADER FILES
  56:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  **************************************************************************************************
  57:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #include <XMC1300.h>                      // SFR declarations of the selected device
  58:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #include "pmsm_foc_interface.h"
  59:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
  60:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /**************************************************************************************************
  61:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * DATA STRUCTURES
  62:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  **************************************************************************************************
  63:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Global variables:*/
  64:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern ClarkeTransformType Clarke_Transform;
  65:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern Car2PolType Car2Polar;
  66:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern PLL_EstimatorType PLL_Estimator;
  67:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Angle γ (1Q23 << 8) of current space vector, from last PWM cycle */
  68:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern int32_t I_AngleQ31;
  69:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* ε = |Vref|sin(γ-θ)+ωL|I| */
  70:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** int32_t Epsilon;
  71:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* ADC results, trigger positions. */
  72:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern ADCType ADC;
  73:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Motor control information */
  74:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern MotorControlType Motor;
  75:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Motor current and current space vector. */
  76:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern CurrentType Current;
  77:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* For trip / over-current detection, and protection. */
  78:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern TripType Trip;
  79:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* For motor startup lock / fail / stall detection, and protection. */
  80:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern StallType Stall;
  81:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* For Hall signal processing. */
  82:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern HallType Hall;
  83:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* SVM information, such as sector 0 ~ 5 (A ~ F) in SVM space vector hexagon. */
  84:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern SVMType SVM;
  85:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Output for FOC LIB. */
  86:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern FOCOutputType FOCOutput;
  87:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Parameters input for FOC LIB. */
  88:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern FOCInputType FOCInput;
  89:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Speed PI controller. */
  90:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern PI_Coefs_Type PI_Speed;
  91:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Torque / Iq PI controller. */
  92:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern PI_Coefs_Type PI_Torque;
  93:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Flux /Id PI controller. */
  94:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern PI_Coefs_Type PI_Flux;
  95:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* PLL rotor speed PI controller. */
  96:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern PI_Coefs_Type PI_PLL;
  97:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
  98:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Data Structure initialization */
  99:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 100:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 101:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 102:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Global variable. MCU Reset Status Information, reason of last reset. */
 103:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern uint32_t * NEW_SHS0_CALOC1;
 104:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern uint32_t g_mcu_reset_status;
 105:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 106:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* 0.05s, time that motor keeps in Stop Mode, x PWM period. */
 107:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define TIME_OF_STOP 	(200U)
 108:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 109:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define TIME_OF_VFRAMP		(750U)
 110:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Step that voltage increases. */
 111:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define ALIGNMENT_STEP		(32U)
 112:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Voltage for rotor preposition/alignment. */
 113:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define ALIGNMENT_VOLT		((VQ_VF_OFFSET * 2) >> 1)
 114:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Ratio for ramp up slowly in V/f open loop.*/
 115:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define RAMP_RATIO_VF		(1U)
 116:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Indicates a running CORDIC calculation if MATH->STATC[0] (i.e.: BSY) = 1. */
 117:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define CORDIC_IS_BSY (MATH->STATC & 0x01)
 118:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 119:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #if(uCPROBE_GUI == ENABLED)
 120:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** extern uint32_t Update_KpKi;                      /* uCProbe Save KPKi to flash button variable */
 121:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** uint32_t Speed_in_rpm;                     /* uC_Probe variable */
 122:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** uint32_t Real_Speed_in_rpm;                /* uC_Probe variable */
 123:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #endif
 124:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 125:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 126:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* V/f Only, with rotor initial preposition/alignment
 127:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  * ----------------------------------------------------------*/
 128:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   void VF_ONLY_OpenLoop_RampUp (void)
 129:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 130:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 131:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Cu
 132:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 133:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 134:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
 135:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 136:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
 137:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 138:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* To get I_Alpha and I_Beta of last PWM cycle, scale down I_Mag (i.e.: |I|) by 2/3. */
 139:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
 140:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 141:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Update V/f voltage amplitude, Vref = Offset + Kω. */
 142:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.SVM_Vref16 = VQ_VF_OFFSET + (VQ_VF_SLEW * (Motor.Speed >> RES_INC));
 143:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 144:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* To update angle θ (16-bit) of SVM reference vector Vref. */
 145:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Update_Vref_Angle (Motor.Speed);
 146:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 147:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Mode_Flag == MOTOR_TRANSITION)
 148:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {       /* Motor is in transition mode */
 149:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Speed < VF_TRANSITION_SPEED)
 150:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 151:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Motor speed not reach V/f open-loop to MET/FOC transition speed */
 152:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Speed ramp counter ++. */
 153:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter ++;
 154:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 155:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 156:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             /* Ramp up slowly in V/f.*/
 157:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             if (Motor.Ramp_Up_Rate > (RAMPUP_RATE << RAMP_RATIO_VF))
 158:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             {
 159:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****               /* Increase acceleration step by step.*/
 160:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****               Motor.Ramp_Up_Rate --;
 161:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             }
 162:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             /* Motor speed ++. */
 163:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             Motor.Speed += SPEEDRAMPSTEP;
 164:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             /* Clear ramp counter.*/
 165:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             Motor.Ramp_Counter = 0;
 166:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 167:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 168:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 169:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 170:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Motor run at V/f constant speed for a while.*/
 171:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Counter ++;
 172:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 173:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 174:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Change flag: motor in stable mode of V/f ramp-up. */
 175:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Mode_Flag = MOTOR_STABLE;
 176:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 177:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 178:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 179:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 180:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     else
 181:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 182:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (SYSTEM_BE_IDLE)
 183:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       { /* If PWM duty cycle or POT ADC too low, */
 184:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Counter = 0;                /* Clear counters. */
 185:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 186:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.State = STOP_MOTOR;         /* Next, go to Motor Stop. */
 187:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 188:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 189:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 190:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Limit of |Vref| (16-bit). */
 191:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #define SVM_VREF16_MAX    (32767U)
 192:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Car2Polar.SVM_Vref16 > SVM_VREF16_MAX)
 193:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 194:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /*  Limit |Vref| maximum value.*/
 195:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Car2Polar.SVM_Vref16 = SVM_VREF16_MAX;
 196:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 197:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 198:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /*  Update SVM PWM. */
 199:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PWMSVM01_Update(Car2Polar.SVM_Vref16, Car2Polar.SVM_Angle16);
 200:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 201:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Record SVM reference vector magnitude (32-bit) of last PWM cycle.*/
 202:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32_Previous = Car2Polar.Vref32;
 203:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 204:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 205:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Init for smooth transition from V/f to FOC closed-loop.*/
 206:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Init_Smooth_Transition_To_FOC (Motor.Speed);
 207:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 208:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 209:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 210:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 211:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** V/f Ramp-Up, with rotor initial preposition/alignment ####
 212:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** ** Execution time: ?us (O3 - Optimize most).
 213:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** * ----------------------------------------------------------*/
 214:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	void VF_FOC_OpenLoop_RampUp (void)
 215:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 216:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 217:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     //  Get_ADC_SingleShuntCurrent(&ADC);
 218:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Curr
 219:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 220:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 221:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
 222:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
 223:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 224:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 225:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* To get I_Alpha and I_Beta of last PWM cycle, scale down I_Mag (i.e.: |I|) by 2/3.*/
 226:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
 227:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 228:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Update V/f voltage amplitude, Vref = Offset + Kω. */
 229:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.SVM_Vref16 = VQ_VF_OFFSET + (VQ_VF_SLEW * (Motor.Speed >> RES_INC));
 230:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 231:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* To update angle θ (16-bit) of SVM reference vector Vref.*/
 232:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Update_Vref_Angle (Motor.Speed);
 233:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 234:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Motor is in transition mode,*/
 235:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Mode_Flag == MOTOR_TRANSITION)
 236:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 237:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Speed < VF_TRANSITION_SPEED)
 238:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {			/* Motor speed not reach V/f open-loop to MET/FOC transition speed.*/
 239:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter ++;
 240:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 241:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {	  /* Ramp up slowly in V/f.*/
 242:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           if (Motor.Ramp_Up_Rate > (RAMPUP_RATE << RAMP_RATIO_VF))
 243:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           {
 244:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             Motor.Ramp_Up_Rate --;
 245:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           }
 246:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Motor speed ++.*/
 247:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Speed += SPEEDRAMPSTEP;
 248:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Clear ramp counter.*/
 249:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Counter = 0;
 250:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 251:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 252:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 253:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 254:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Motor run at V/f constant speed for a while.*/
 255:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Counter ++;
 256:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 257:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 258:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Change flag: motor in stable mode of V/f ramp-up.*/
 259:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Mode_Flag = MOTOR_STABLE;
 260:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 261:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 262:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 263:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 264:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     else
 265:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 266:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Next, go to MET (Maximum Efficiency Tracking) closed-loop control. */
 267:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.State = MET_FOC;
 268:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 269:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.BEMF1 = 0;
 270:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.BEMF2 = 0;
 271:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 272:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* MET loop unlocked, Init ε Threshold LOW. (Initially, ε_Th = ε_Th_L.) */
 273:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold_LOW = THRESHOLD_LOW;
 274:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold_HIGH = THRESHOLD_HIGH;
 275:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold = (Motor.Speed * THRESHOLD_LOW) >> RES_INC;
 276:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 277:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Phase_L = L_OMEGALI;
 278:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Phase_L_Scale = SCALE_L;
 279:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 280:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Resolution increase, use (16 + Res_Inc) bit to represent 360 deg. */
 281:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Res_Inc = RES_INC;
 282:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.LPF_N_BEMF = SHIFT_MET_PLL;
 283:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 284:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Motor in transition mode.*/
 285:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Mode_Flag = MOTOR_TRANSITION;
 286:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Counter = 0;
 287:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter = 0;
 288:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Alignment_Counter = 0;
 289:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Slower ramp up and ramp down for S-curve profile.*/
 290:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Up_Rate = RAMPUP_RATE << RATIO_S;
 291:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 292:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 293:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Limit of |Vref| (16-bit). */
 294:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #define SVM_VREF16_MAX		(32767U)
 295:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Car2Polar.SVM_Vref16 > SVM_VREF16_MAX)
 296:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 297:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Limit |Vref| maximum value.*/
 298:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Car2Polar.SVM_Vref16 = SVM_VREF16_MAX;
 299:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 300:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 301:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Update SVM PWM.*/
 302:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PWMSVM01_Update(Car2Polar.SVM_Vref16, Car2Polar.SVM_Angle16);
 303:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 304:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Record SVM reference vector magnitude (32-bit) of last PWM cycle. */
 305:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32_Previous = Car2Polar.Vref32;
 306:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 307:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 308:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Init for smooth transition from V/f to FOC closed-loop.*/
 309:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Init_Smooth_Transition_To_FOC (Motor.Speed);
 310:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 311:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 312:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 313:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 314:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 315:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** To calculate |Vref|sin(γ-θ), wL|I|, and ε=|Vref|sin(γ-θ)+wL|I|, for MET (Maximum Efficienc
 316:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** ** Execution time: 5.9us - 6.3us (O3 - Optimize most).
 317:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** * -------------------------------------------------------------------------------------------------
 318:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** void Init_Smooth_Transition_To_FOC (uint32_t Omega_Speed)
 319:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
  26              	 .loc 1 319 0
  27              	 .cfi_startproc
  28              	.LVL0:
  29 0000 70B5     	 push {r4,r5,r6,lr}
  30              	 .cfi_def_cfa_offset 16
  31              	 .cfi_offset 4,-16
  32              	 .cfi_offset 5,-12
  33              	 .cfi_offset 6,-8
  34              	 .cfi_offset 14,-4
 320:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 321:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 322:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     // Get_ADC_SingleShuntCurrent(&ADC);
 323:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Curr
 324:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 325:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 326:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
  35              	 .loc 1 326 0
  36 0002 3B4C     	 ldr r4,.L20
  37 0004 3B4D     	 ldr r5,.L20+4
  38 0006 221C     	 mov r2,r4
 319:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
  39              	 .loc 1 319 0
  40 0008 82B0     	 sub sp,sp,#8
  41              	 .cfi_def_cfa_offset 24
  42              	 .loc 1 326 0
  43 000a 6888     	 ldrh r0,[r5,#2]
  44              	.LVL1:
  45 000c 2988     	 ldrh r1,[r5]
  46 000e FFF7FEFF 	 bl Get_ADCPhaseCurrent
  47              	.LVL2:
 327:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 328:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
  48              	 .loc 1 328 0
  49 0012 2088     	 ldrh r0,[r4]
  50 0014 6188     	 ldrh r1,[r4,#2]
  51 0016 A288     	 ldrh r2,[r4,#4]
  52 0018 374C     	 ldr r4,.L20+8
  53 001a 231C     	 mov r3,r4
  54 001c FFF7FEFF 	 bl Current_Reconstruction
  55              	.LVL3:
 329:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 330:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 331:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
  56              	 .loc 1 331 0
  57 0020 0DCC     	 ldmia r4!,{r0,r2,r3}
  58              	.LVL4:
  59              	.LBB25:
  60              	.LBB26:
  61              	 .file 2 "../PMSM_FOC/ControlModules/pmsm_foc_functions.h"
   1:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** /**
   2:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @file pmsm_foc_functions.h
   3:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @date 2015-06-29
   4:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
   5:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @cond
   6:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *******************************************************************************
   7:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * PMSM FOC Motor Control Library
   8:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
   9:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * All rights reserved.
  11:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  12:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * following conditions are met:
  14:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  15:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  16:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   disclaimer.
  17:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  18:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  19:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  20:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  21:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  22:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *   products derived from this software without specific prior written permission.
  23:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  24:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  32:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * with Infineon Technologies AG (dave@infineon.com).
  34:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  **************************************************************************************************
  35:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  36:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @file pmsm_foc_functions.h
  37:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @date 29 Jun, 2015
  38:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @version 1.0.0
  39:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  40:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @brief ACMP low level driver API prototype definition for XMC1 <br>
  41:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  42:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * <b>Detailed description of file</b> <br>
  43:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * APIs provided in this file mainly cover the following functionality:
  44:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * ---- Filter, Hysterisis, Output inversion
  45:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  46:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * History
  47:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  48:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * 29 Jun 2015 Version 1.0.0 <br>:
  49:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *      Initial version
  50:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @endcond
  51:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
  52:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  */
  53:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  54:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #ifndef PMSM_FOC_CONTROLMODULES_PMSM_FOC_FUNCTIONS_H
  55:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define PMSM_FOC_CONTROLMODULES_PMSM_FOC_FUNCTIONS_H
  56:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  57:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** /**************************************************************************************************
  58:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * HEADER FILES
  59:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  **************************************************************************************************
  60:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  61:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#include "..\MCUInit\wdt.h"
  62:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#include "..\MCUInit\uart.h"
  63:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#include "..\MIDSys\pmsm_foc_current_threeshunt.h"
  64:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   #include "..\MIDSys\pmsm_foc_current_singleshunt.h"
  65:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#include "pmsm_foc_pi.h"
  66:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#include "..\MIDSys\pmsm_foc_pwmsvm.h"
  67:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  68:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** /**
  69:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @addtogroup
  70:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @{
  71:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  */
  72:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  73:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** /**
  74:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @addtogroup
  75:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @{
  76:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  */
  77:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  78:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define FOC_LIB_NO_SVM		1			/* To remove SVM to outside of FOC LIB. Do NOT comment out. */
  79:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define CALIB00   0x480340E0
  80:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define CALIB01   0x480340E4
  81:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
  82:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct FOCInputType
  83:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
  84:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Phase_L;
  85:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Phase_R;
  86:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Phase_L_Scale;
  87:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t CCU8_Period;
  88:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Res_Inc;
  89:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int16_t SVM_Scale;
  90:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t LPF_N_BEMF;
  91:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Threshold;
  92:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Threshold_LOW;
  93:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Threshold_HIGH;
  94:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Flag_State;
  95:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t overcurrent_factor;
  96:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t BEMF1;
  97:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t BEMF2;
  98:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_5_Segment_Flag;
  99:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Vref32;
 100:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vref_AngleQ31;
 101:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_U;
 102:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_V;
 103:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_W;
 104:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Speed;
 105:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vq_Flag;
 106:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vq;
 107:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Id;
 108:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Iq;
 109:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Iq_PI_Flag;
 110:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t RotorAngleQ31;
 111:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t RotorSpeed_In;
 112:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t ACIM_Flag;
 113:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Slip_Ratio;
 114:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Slip_Scale;
 115:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Slip_Speed_Max;
 116:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Id_Min;
 117:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Id_Max;
 118:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Ref_Id_Shift;
 119:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 120:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Single_Shunt_Flag;
 121:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } FOCInputType;
 122:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 123:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct FOCOutputType
 124:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 125:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_Alpha_1Q31;
 126:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_Beta_1Q31;
 127:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_d;
 128:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_q;
 129:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Speed_by_Estimator;
 130:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Rotor_PositionQ31;
 131:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Previous_SVM_SectorNo;
 132:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t New_SVM_SectorNo;
 133:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 134:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Vref32;
 135:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vref_AngleQ31;
 136:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 137:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_U_CR1S;
 138:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_V_CR1S;
 139:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_W_CR1S;
 140:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 141:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Debug_1;
 142:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } FOCOutputType;
 143:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 144:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 145:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct CurrentType
 146:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 147:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_U; /* Current of motor phase U, Iu */
 148:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_V; /* Current of motor phase V, Iv */
 149:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_W; /* Current of motor phase W, Iw */
 150:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 151:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t I_Mag; /* |I|, magnitude of current space vector */
 152:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 153:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_Speed; /* ωi, current space vector speed */
 154:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } CurrentType;
 155:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 156:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 157:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct ClarkeTransformType
 158:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 159:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_Alpha_1Q31; /* Iα (1Q31), Alpha value of current space vector */
 160:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t I_Beta_1Q31; /* Iβ (1Q31) */
 161:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 162:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } ClarkeTransformType;
 163:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 164:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct ParkTransformType
 165:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 166:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Id; /* Id */
 167:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Iq; /* Iq */
 168:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } ParkTransformType;
 169:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 170:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct Car2PolType
 171:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 172:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Flux_Vd; /* Vd */
 173:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Torque_Vq; /* Vq */
 174:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 175:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Vref32;
 176:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vref_AngleQ31;
 177:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 178:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Vref32_Previous; /* |Vref| of last PWM cycle */
 179:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Vref_AngleQ31_Previous; /* Angle θ of last PWM cycle */
 180:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 181:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_Vref16; /* |Vref|, Magnitude (1Q15) of reference vector (for SVM) */
 182:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t SVM_Angle16; /* Angle θ (16-bit) of reference vector. 0 ~ 2^16 represent electrical ang
 183:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } Car2PolType;
 184:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 185:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 186:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 187:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 188:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define SHIFT_BIAS_LPF  (3U)      /* Shift times for unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>
 189:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 190:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define MOTOR_TRANSITION  0     /* Motor is in transition mode */
 191:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define	MOTOR_STABLE    0xAB    /* Motor is in stable mode */
 192:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 193:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define DIRECTION_INC   0      /* Motor rotation direction - rotor angle increasing */
 194:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 195:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define ADJUST_DONE     0     /* Parameter adjustment has been done */
 196:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 197:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 198:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct MotorControlType
 199:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 200:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t L_METPLL; /* Motor inductance per phase, used in ωL|I| of MET and FOC PLL observer */
 201:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 202:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Speed; /* Rotor reference speed ωref, e.g.: determined by POT ADC or PWM duty cycle 
 203:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Speed; /* Motor shaft speed of V/f, MET (and FOC) */
 204:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 205:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Speed_by_POT_PWM; /* Target motor speed set by POT ADC, or PWM duty cycle */
 206:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t speed_in_rpm;
 207:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 208:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t PWM_DutyCycle; /* Duty cycle of the PWM for speed adjustment */
 209:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t PWM_Period; /* Period of the PWM (10kHz ~ 50kHz) for speed adjustment, almost a constant
 210:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t PWM_Speed_Raw; /* PWM-set speed, raw data */
 211:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t PWM_Freq; /* Frequency of PWM. */
 212:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 213:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ramp_Up_Rate; /* Motor speed ramp up rate */
 214:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ramp_Dn_Rate; /* Motor speed ramp down rate */
 215:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 216:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t State; /* Motor state (e.g.: V/f, MET, FOC) */
 217:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Rotation_Dir; /* Rotation direction of motor (rotor angle increasing, or decreasing) */
 218:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Mode_Flag; /* Flag to indicate if motor is in transition (MOTOR_TRANSITION) or stable (M
 219:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 220:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Control_Mode;
 221:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 222:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Adjust_Para_Flag; /*
 223:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                               * Flag to indicate parameter scheduling status,
 224:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                               * e.g.: for parameter adjust of PI controllers in FOC steady state.
 225:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                               */
 226:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 227:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Counter; /* General purpose counter */
 228:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Ramp_Counter; /* General purpose counter, or counter for motor speed ramp up/down. */
 229:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Alignment_Counter; /* Counter for rotor initial positioning / alignment in V/f */
 230:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Non_RealTime_Counter; /* Counter for tasks that don't need real-time computing */
 231:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t FW_Counter; /* Counter for Flux Weakening (FW) */
 232:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t UART_Counter; /* Counter for UART communication */
 233:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t UART_Debug_Counter;
 234:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 235:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t FG_Speed; /* Motor speed for Frequency Generation (FG) only */
 236:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 237:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t UART_Data; /* Data received via UART */
 238:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 239:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Ref_Id; /* Id reference, for ACIM */
 240:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } MotorControlType;
 241:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 242:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 243:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct StallType /* For motor startup lock / fail / stall detection and protection. */
 244:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 245:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Counter; /* Counter for detection of motor startup lock / fail / stall */
 246:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 247:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } StallType;
 248:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 249:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 250:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct TripType /* For trip / over-current detection and protection */
 251:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 252:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Counter; /* Counter for trip / over-current protection */
 253:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 254:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t ADC_Ave_DC_Link; /* Average of ADC value (with LPF) for dc link current, to detect trip /
 255:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } TripType;
 256:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 257:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct OverUnderVoltType /* For over/under-voltage detection and protection */
 258:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 259:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Counter; /* Counter for over/under-voltage detection */
 260:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } OverUnderVoltType;
 261:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 262:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** typedef struct HallType /* For Hall signal processing */
 263:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 264:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Speed; /* Rotor speed obtained from Hall */
 265:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Speed_rpm; /* Rotor speed obtained from Hall, in rpm */
 266:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   int32_t Rotor_AngleQ31; /* Estimated rotor angle (1Q23 << 8) from Hall */
 267:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint16_t Flag; /* Flag to indicate if one Hall event has occurred */
 268:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Event_Counter; /* Counter for Hall events. */
 269:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 270:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Stall_Counter; /* Counter for Hall stall detection */
 271:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Restart_Counter; /* Counter for retry times to start motor if stall has been detected by
 272:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   uint32_t Rst_Restart_Counter; /* To reset Hall_Restart_Counter if no motor stall for certain time
 273:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** } HallType;
 274:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 275:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	typedef enum StateMachine
 276:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	{
 277:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		FOC_CLOSED_LOOP = 0,
 278:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		MET_CLOSED_LOOP,
 279:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		BRAKE_BOOTSTRAP,
 280:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		STOP_MOTOR,
 281:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		VFOPENLOOP_RAMP_UP,
 282:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		MET_FOC,
 283:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		PRE_POSITIONING,
 284:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		DCLINK_OVER_UNDER_VOLTAGE,
 285:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		MCU_SLEEP,
 286:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		TRAP_PROTECTION,
 287:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	}StateMachine;
 288:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 289:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define DEGREE_90   (4194304U << 8U)        /* 90° angle (0 ~ 2^23 represent electrical angle 0° 
 290:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define DEGREE_X    (DEGREE_90 * 1U)        /* X = 0°, 90°, 180°, or 270° */
 291:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define DEGREE_SHIFT  (652448U << 8U)         /* 14° angle shift */
 292:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 293:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define TH_POT_ADC    50              /* 50. Threshold POT ADC that motor can enter or exit motor i
 294:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define SYSTEM_BE_IDLE  (ADC.ADC_POT < TH_POT_ADC)  /* POT ADC is too low */
 295:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 296:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	/* %%%%%%%%%% PI Controller Configuration %%%%%%%%%% */
 297:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 298:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 299:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		#define SPEED_IK_LIMIT_MAX		PI_Speed.Ik_limit_max
 300:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		#define SPEED_IK_LIMIT_MIN		PI_Speed.Ik_limit_min
 301:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 302:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		#define TORQUE_KP				PI_Torque.Kp
 303:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		#define TORQUE_IK_LIMIT_MAX		PI_Torque.Ik_limit_max
 304:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 		#define TORQUE_IK_LIMIT_MIN		PI_Torque.Ik_limit_min
 305:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 306:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 307:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 308:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define	SCALE_SQRT3		  (10U)							// For √3 scaling, used in Clarke Transform.
 309:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define SQRT3			      (1.732050807569F)				// √3
 310:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define	DIV_SQRT3		    (591U)							// ((int16_t)((1/SQRT3) * (1<<SCALE_SQRT3)))
 311:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   #define DIV_SQRT3_Q14   (9459U)
 312:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 313:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define	SCALE_DIV_3		(14U)							// For 1/3 scaling.
 314:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define	DIV_3			(5461U)							// ((int16_t)((1/3) * (1<<SCALE_DIV_3)))
 315:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 316:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define	RATIO_S			(1U)							// Minimum ramp up and down ratio for S-curve profile
 317:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 318:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define PERIOD_ADD_0_OR_1	(1U)						// 0 or 1. Addition to period of a CCU8 PWM
 319:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 320:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define POR_OR_BOR			(0x01)						// RSTSTAT = 0000000001B, Power on reset or Brownout reset. Reaso
 321:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 322:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define MILLISECOND_500		((32768U * 1U) >> 1U)		// 500ms. MCU Sleep time before WDT reset system. 
 323:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define MILLISECOND_5		((327U * 1U) >> 1U)			// 5ms
 324:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	#define MILLISECOND_1500	((32768U * 3U) >> 1U)		// 1500ms
 325:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 326:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 327:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 328:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define CORDIC_VECTORING_MODE   (0x62)      // CORDIC: Circular Vectoring Mode (default). MPS: Divi
 329:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #define CORDIC_ROTATION_MODE    (0x6A)      // CORDIC: Circular Rotation Mode. MPS: Divide by 2 (de
 330:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 331:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 332:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   typedef struct PLL_EstimatorType
 333:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   {
 334:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     uint32_t Current_I_Mag;
 335:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     int32_t Delta_IV;
 336:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     int32_t VrefxSinDelta;
 337:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 338:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     int32_t RotorAngleQ31;
 339:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     int32_t RotorSpeed_In;
 340:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 341:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }PLL_EstimatorType;
 342:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 343:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   extern FOCOutputType FOCOutput;                 // Output for FOC LIB.
 344:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   extern SVMType SVM;                          // SVM information, such as sector 0 ~ 5 (A ~ F) in 
 345:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 346:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 347:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** __attribute__((section(".ram_code"))) void PLL_Imag(int32_t Vref_AngleQ31, int32_t I_Alpha_1Q31, in
 348:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** __attribute__((section(".ram_code"))) void PLL_Imag_GetResult(PLL_EstimatorType* const HandlePtr);
 349:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** __attribute__((section(".ram_code"))) void PLL_Vref(int32_t Delta_IV, uint32_t Vref32, int32_t PLL_
 350:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                                     PLL_EstimatorType* const HandlePtr);
 351:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** __attribute__((section(".ram_code"))) void PLL_Vref_GetResult(PLL_EstimatorType* const HandlePtr);
 352:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** __attribute__((section(".ram_code"))) void PLL_GetPosSpd(PLL_EstimatorType* const HandlePtr);
 353:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 354:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 355:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void VF_FOC_Brake_Motor_Bootstrap_Charge (void);
 356:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	extern void PWMSVM01_Update(uint16_t Amplitude, uint16_t Angle);
 357:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	extern void PI_controller_Init(void);
 358:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void FOC_SystemParameters_Init_OnceOnly (void);
 359:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 360:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 361:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 362:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Current_Reconstruction (uint16_t Previous_SVM_SectorNo,int32_t ADC_result1, int32_t ADC_result
 363:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #else
 364:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Current_Reconstruction (int32_t ADC_Iu, int32_t ADC_Iv, int32_t ADC_Iw, CurrentType * const Ha
 365:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #endif
 366:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline RAM_ATTRIBUTE void ClarkeTransform(int32_t CurrentPhaseU, int32_t CurrentPhaseV, int32_t Cur
 367:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                           ClarkeTransformType* const HandlePtr);
 368:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline RAM_ATTRIBUTE void ParkTransform_GetResult(ParkTransformType* const HandlePtr);
 369:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline RAM_ATTRIBUTE void ParkTransform (int32_t I_Alpha1Q31, int32_t I_Beta_1Q31, int32_t RotorAng
 370:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline void Cart2Polar(int32_t Torque_Vq, int32_t Flux_Vd, int32_t RotorAngleQ31);
 371:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline RAM_ATTRIBUTE void Car2Pol_GetResult(Car2PolType * const HandlePtr);
 372:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 373:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void FOC_Speed_Controller (void);
 374:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** RAM_ATTRIBUTE void SCurve_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rat
 375:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                          int32_t speedrampstep, int32_t *reference_val);
 376:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** RAM_ATTRIBUTE void Linear_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rat
 377:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                          int32_t speedrampstep, int32_t *reference_val);
 378:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** extern __attribute__((section(".ram_code"))) void FOC_Torque_Controller(void);
 379:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** extern __attribute__((section(".ram_code"))) void Linear_Torque_Ramp_Generator(int32_t current_set,
 380:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                                                                int32_t dec_step,
 381:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                                                                FOCInputType* const 
 382:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** extern __attribute__((section(".ram_code"))) void FOC_VQ_Controller(void);
 383:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** extern __attribute__((section(".ram_code"))) void Linear_VQ_Ramp_Generator(int32_t current_set, int
 384:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                                                            int32_t dec_step,
 385:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                                                            FOCInputType* const Hand
 386:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Misc_Works_of_IRQ (void);
 387:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 388:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Rotor_Pre_Positioning (void);
 389:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 390:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_Smooth_Transition_To_FOC (uint32_t Omega_Speed);
 391:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** uint16_t VF_Smooth_Transition_To_FOC (void);
 392:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Misc_Works_of_MET (void);
 393:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Transition_to_FOC (void);
 394:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_FOC_RotorAngle (void);
 395:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_FOC_PI_Iks (void);
 396:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 397:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** RAM_ATTRIBUTE void Misc_Works_of_FOC (void);
 398:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 399:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Adjust_FOCSpeed_With_POT_PWM (void);
 400:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** RAM_ATTRIBUTE void Adjust_FOC_Parameters (void);
 401:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Stop_Motor (void);
 402:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Variables_Init (void);
 403:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 404:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** extern void CCU4_Debug3Output(int32_t In04, uint16_t In04_Flag, uint16_t In04_N, int32_t In10, uint
 405:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                               uint16_t In10_N);
 406:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Set_CCU4_Debug_Infor (void);
 407:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void CCU4_P1_3_Output (int32_t In_x, uint16_t In_x_Flag, uint16_t In_x_N);
 408:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 409:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Update_Vref_Angle (int32_t Speed);
 410:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 411:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_Single_Hall (void);
 412:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Hall_Speed_Detection (void);
 413:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Hall_Level_Detection (uint32_t Item_To_Detect);
 414:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 415:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_Detect_Motor_Stall (void);
 416:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Detect_Motor_Stall (void);
 417:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Detect_Trip_OverCurrent (void);
 418:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Detect_Over_Under_Voltage (void);
 419:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 420:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Init_Catch_FreeRunning_Motor (void);
 421:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 422:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void System_Low_Power_Mode (uint32_t Max_Sleep_Time);
 423:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Check_n_Go_Sleep (void);
 424:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 425:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 426:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	void CCU4_Init (void);
 427:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 	void Init_CCU8x_for_TRAP_LED_Indicator (void);
 428:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** void Error_Handling (void);
 429:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 430:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 431:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 432:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** /**
 433:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @brief To get current I_Alpha / I_Beta of last PWM cycle
 434:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * I_Alpha = I_U
 435:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * I_Beta = (I_U + 2 * I_V)/√3 = (I_V - I_W)/√3
 436:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * Above transform scales down I_Mag (i.e.: |I|) by 2/3. Need scale up by 3/2.
 437:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * Alternatively, can scale up inductance L in ωL|I| by 3/2 (legacy scaling).
 438:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
 439:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  * @param Current.I_U
 440:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *      Current.I_V
 441:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *      Current.I_W
 442:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *
 443:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *@retval Current.I_Alpha_1Q31
 444:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  *      Current.I_Beta_1Q31
 445:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****  */
 446:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 447:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** inline RAM_ATTRIBUTE void ClarkeTransform(int32_t CurrentPhaseU, int32_t CurrentPhaseV, int32_t Cur
 448:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****                                           ClarkeTransformType* const HandlePtr)
 449:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** {
 450:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 451:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
 452:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDIC_SHIFT-
 453:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 454:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** #else
 455:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   if(SVM.Flag_3or2_ADC == 0){
  62              	 .loc 2 456 0
  63 0022 A988     	 ldrh r1,[r5,#4]
  64 0024 0029     	 cmp r1,#0
  65 0026 44D1     	 bne .L2
 457:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 458:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     HandlePtr->I_Alpha_1Q31 = ((CurrentPhaseU << 1) - (CurrentPhaseV + CurrentPhaseW)) * (DIV_3 << 
  66              	 .loc 2 458 0
  67 0028 D118     	 add r1,r2,r3
  68 002a 4000     	 lsl r0,r0,#1
  69              	.LVL5:
  70 002c 401A     	 sub r0,r0,r1
  71 002e 3349     	 ldr r1,.L20+12
  72 0030 4143     	 mul r1,r0
  73              	.L16:
 459:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 460:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /*  I_Beta = (I_V - I_W)/√3 in 1Q31 */
 461:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIFT-14))
 462:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }
 463:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   else
 464:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   {
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     switch(FOCOutput.Previous_SVM_SectorNo)
 466:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 467:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       case 0:
 468:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       case 5:
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Alpha_1Q31 = (-(CurrentPhaseV + CurrentPhaseW)) << CORDIC_SHIFT;
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
  74              	 .loc 2 470 0
  75 0032 D21A     	 sub r2,r2,r3
  76              	.LVL6:
  77 0034 324B     	 ldr r3,.L20+16
  78              	.LVL7:
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
  79              	 .loc 2 469 0
  80 0036 334C     	 ldr r4,.L20+20
  81              	 .loc 2 470 0
  82 0038 5A43     	 mul r2,r3
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
  83              	 .loc 2 469 0
  84 003a 2160     	 str r1,[r4]
  85              	 .loc 2 470 0
  86 003c 6260     	 str r2,[r4,#4]
  87              	.L3:
  88              	.LBE26:
  89              	.LBE25:
 332:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 333:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Imag(Car2Polar.Vref_AngleQ31,Clarke_Transform.I_Alpha_1Q31,Clarke_Transform.I_Beta_1Q31);
  90              	 .loc 1 333 0
  91 003e 324E     	 ldr r6,.L20+24
  92 0040 F068     	 ldr r0,[r6,#12]
  93 0042 FFF7FEFF 	 bl PLL_Imag
  94              	.LVL8:
 334:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 335:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Wait if CORDIC is still running calculation. Omit if CCU4 outputs debug information.*/
 336:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     while (CORDIC_IS_BSY)
  95              	 .loc 1 336 0
  96 0046 0122     	 mov r2,#1
  97 0048 3049     	 ldr r1,.L20+28
  98              	.L8:
  99 004a 0B6C     	 ldr r3,[r1,#64]
 100 004c 1A42     	 tst r2,r3
 101 004e FCD1     	 bne .L8
 337:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 338:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       continue;
 339:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 340:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Imag_GetResult(&PLL_Estimator);
 102              	 .loc 1 340 0
 103 0050 2F4C     	 ldr r4,.L20+32
 104 0052 201C     	 mov r0,r4
 105 0054 FFF7FEFF 	 bl PLL_Imag_GetResult
 106              	.LVL9:
 341:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 342:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Vref(PLL_Estimator.Delta_IV, Car2Polar.Vref32,PI_PLL.Uk, FOCInput.Phase_L,&PLL_Estimator);
 107              	 .loc 1 342 0
 108 0058 2E4B     	 ldr r3,.L20+36
 109 005a 2F4D     	 ldr r5,.L20+40
 110 005c 5A68     	 ldr r2,[r3,#4]
 111 005e 0094     	 str r4,[sp]
 112 0060 B168     	 ldr r1,[r6,#8]
 113 0062 2B68     	 ldr r3,[r5]
 114 0064 6068     	 ldr r0,[r4,#4]
 115 0066 FFF7FEFF 	 bl PLL_Vref
 116              	.LVL10:
 343:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 344:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* CPU computes the following simultaneously when CORDIC #7 */
 345:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* γ, used for smooth MET->FOC transition and motor startup lock / fail / stall detection.*/
 346:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     I_AngleQ31 = PLL_Estimator.Delta_IV + Car2Polar.Vref_AngleQ31;
 117              	 .loc 1 346 0
 118 006a 6268     	 ldr r2,[r4,#4]
 119 006c F368     	 ldr r3,[r6,#12]
 120 006e 9446     	 mov ip,r2
 121 0070 2A4A     	 ldr r2,.L20+44
 122 0072 6344     	 add r3,r3,ip
 123 0074 1360     	 str r3,[r2]
 347:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 348:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Results of CORDIC #7 - Vrefxsin(Î³-Î¸) and Vrefxcos(γ-θ) */
 349:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Wait if CORDIC is still running calculation.*/
 350:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     while (CORDIC_IS_BSY)
 124              	 .loc 1 350 0
 125 0076 0122     	 mov r2,#1
 126 0078 2449     	 ldr r1,.L20+28
 127              	.L9:
 128 007a 0B6C     	 ldr r3,[r1,#64]
 129 007c 1A42     	 tst r2,r3
 130 007e FCD1     	 bne .L9
 351:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 352:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       continue;
 353:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 354:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Vref_GetResult(&PLL_Estimator);
 131              	 .loc 1 354 0
 132 0080 201C     	 mov r0,r4
 133 0082 FFF7FEFF 	 bl PLL_Vref_GetResult
 134              	.LVL11:
 355:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 356:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Shift to get real result (16-bit).*/
 357:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Estimator.VrefxSinDelta >>= CORDIC_SHIFT;
 135              	 .loc 1 357 0
 136 0086 A368     	 ldr r3,[r4,#8]
 358:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 359:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PLL_Estimator.VrefxSinDelta = (PLL_Estimator.VrefxSinDelta * 311) >> 8;
 360:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 361:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>>FOCInput.LPF_N_BEMF */
 362:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* |Vref|sin(γ-θ) with LPF.*/
 363:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     FOCInput.BEMF1 = (FOCInput.BEMF1 * ((1 << FOCInput.LPF_N_BEMF) - 1) + PLL_Estimator.VrefxSinDel
 137              	 .loc 1 363 0
 138 0088 0122     	 mov r2,#1
 357:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 139              	 .loc 1 357 0
 140 008a 9913     	 asr r1,r3,#14
 359:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 141              	 .loc 1 359 0
 142 008c 3823     	 mov r3,#56
 143 008e FF33     	 add r3,r3,#255
 144 0090 4B43     	 mul r3,r1
 145 0092 1912     	 asr r1,r3,#8
 146 0094 A160     	 str r1,[r4,#8]
 147              	 .loc 1 363 0
 148 0096 288A     	 ldrh r0,[r5,#16]
 149 0098 8240     	 lsl r2,r2,r0
 150 009a 531E     	 sub r3,r2,#1
 151 009c 2A6A     	 ldr r2,[r5,#32]
 152 009e 5A43     	 mul r2,r3
 153 00a0 8B18     	 add r3,r1,r2
 364:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     >> FOCInput.LPF_N_BEMF;
 154              	 .loc 1 364 0
 155 00a2 0341     	 asr r3,r3,r0
 365:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 366:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Îµ = |Vref|sin(γ-θ) + wL|I|. Motor rotates in one direction only. Rotor angle always inc
 367:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Epsilon = FOCInput.BEMF1 +  FOCInput.BEMF2;
 156              	 .loc 1 367 0
 157 00a4 6A6A     	 ldr r2,[r5,#36]
 363:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     >> FOCInput.LPF_N_BEMF;
 158              	 .loc 1 363 0
 159 00a6 2B62     	 str r3,[r5,#32]
 160              	 .loc 1 367 0
 161 00a8 9B18     	 add r3,r3,r2
 162 00aa 1D4A     	 ldr r2,.L20+48
 163 00ac 1360     	 str r3,[r2]
 368:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 369:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 164              	 .loc 1 369 0
 165 00ae 02B0     	 add sp,sp,#8
 166              	 
 167 00b0 70BD     	 pop {r4,r5,r6,pc}
 168              	.LVL12:
 169              	.L2:
 170              	.LBB28:
 171              	.LBB27:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 172              	 .loc 2 465 0
 173 00b2 1C49     	 ldr r1,.L20+52
 174 00b4 098B     	 ldrh r1,[r1,#24]
 175 00b6 0229     	 cmp r1,#2
 176 00b8 05D8     	 bhi .L5
 177 00ba 0029     	 cmp r1,#0
 178 00bc 0ED1     	 bne .L19
 179              	.L7:
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 180              	 .loc 2 469 0
 181 00be D118     	 add r1,r2,r3
 182 00c0 4942     	 neg r1,r1
 183 00c2 8903     	 lsl r1,r1,#14
 184 00c4 B5E7     	 b .L16
 185              	.L5:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 186              	 .loc 2 465 0
 187 00c6 0529     	 cmp r1,#5
 188 00c8 F9D0     	 beq .L7
 471:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 472:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       case 1:
 473:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       case 2:
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Alpha_1Q31 =  CurrentPhaseU << CORDIC_SHIFT;
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 476:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 477:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       default:
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Alpha_1Q31 = CurrentPhaseU << CORDIC_SHIFT;
 479:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 189              	 .loc 2 479 0
 190 00ca 5200     	 lsl r2,r2,#1
 191              	.LVL13:
 192 00cc 0C4B     	 ldr r3,.L20+16
 193              	.LVL14:
 194 00ce 8218     	 add r2,r0,r2
 195 00d0 5A43     	 mul r2,r3
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 196              	 .loc 2 478 0
 197 00d2 0C4C     	 ldr r4,.L20+20
 198 00d4 8103     	 lsl r1,r0,#14
 199 00d6 2160     	 str r1,[r4]
 200              	 .loc 2 479 0
 201 00d8 6260     	 str r2,[r4,#4]
 202 00da B0E7     	 b .L3
 203              	.LVL15:
 204              	.L19:
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 205              	 .loc 2 475 0
 206 00dc 5A00     	 lsl r2,r3,#1
 207              	.LVL16:
 208 00de 124B     	 ldr r3,.L20+56
 209              	.LVL17:
 210 00e0 8218     	 add r2,r0,r2
 211 00e2 5A43     	 mul r2,r3
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 212              	 .loc 2 474 0
 213 00e4 074C     	 ldr r4,.L20+20
 214 00e6 8103     	 lsl r1,r0,#14
 215 00e8 2160     	 str r1,[r4]
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 216              	 .loc 2 475 0
 217 00ea 6260     	 str r2,[r4,#4]
 218 00ec A7E7     	 b .L3
 219              	.L21:
 220 00ee C046     	 .align 2
 221              	.L20:
 222 00f0 00000000 	 .word ADC
 223 00f4 00000000 	 .word SVM
 224 00f8 00000000 	 .word Current
 225 00fc 55150000 	 .word 5461
 226 0100 F3240000 	 .word 9459
 227 0104 00000000 	 .word Clarke_Transform
 228 0108 00000000 	 .word Car2Polar
 229 010c 00000340 	 .word 1073938432
 230 0110 00000000 	 .word PLL_Estimator
 231 0114 00000000 	 .word PI_PLL
 232 0118 00000000 	 .word FOCInput
 233 011c 00000000 	 .word I_AngleQ31
 234 0120 00000000 	 .word Epsilon
 235 0124 00000000 	 .word FOCOutput
 236 0128 0DDBFFFF 	 .word -9459
 237              	.LBE27:
 238              	.LBE28:
 239              	 .cfi_endproc
 240              	.LFE203:
 242              	 .section .text.VF_ONLY_OpenLoop_RampUp,"ax",%progbits
 243              	 .align 2
 244              	 .global VF_ONLY_OpenLoop_RampUp
 245              	 .code 16
 246              	 .thumb_func
 248              	VF_ONLY_OpenLoop_RampUp:
 249              	.LFB201:
 129:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 250              	 .loc 1 129 0
 251              	 .cfi_startproc
 252 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 253              	 .cfi_def_cfa_offset 24
 254              	 .cfi_offset 3,-24
 255              	 .cfi_offset 4,-20
 256              	 .cfi_offset 5,-16
 257              	 .cfi_offset 6,-12
 258              	 .cfi_offset 7,-8
 259              	 .cfi_offset 14,-4
 134:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 260              	 .loc 1 134 0
 261 0002 454E     	 ldr r6,.L42
 262 0004 454D     	 ldr r5,.L42+4
 263 0006 321C     	 mov r2,r6
 264 0008 6888     	 ldrh r0,[r5,#2]
 265 000a 2988     	 ldrh r1,[r5]
 266 000c FFF7FEFF 	 bl Get_ADCPhaseCurrent
 267              	.LVL18:
 136:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 268              	 .loc 1 136 0
 269 0010 434C     	 ldr r4,.L42+8
 270 0012 7188     	 ldrh r1,[r6,#2]
 271 0014 B288     	 ldrh r2,[r6,#4]
 272 0016 231C     	 mov r3,r4
 273 0018 3088     	 ldrh r0,[r6]
 274 001a FFF7FEFF 	 bl Current_Reconstruction
 275              	.LVL19:
 276              	.LBB29:
 277              	.LBB30:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 278              	 .loc 2 456 0
 279 001e A988     	 ldrh r1,[r5,#4]
 280              	.LBE30:
 281              	.LBE29:
 139:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 282              	 .loc 1 139 0
 283 0020 2268     	 ldr r2,[r4]
 284 0022 6768     	 ldr r7,[r4,#4]
 285 0024 A368     	 ldr r3,[r4,#8]
 286              	.LVL20:
 287              	.LBB34:
 288              	.LBB31:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 289              	 .loc 2 456 0
 290 0026 0029     	 cmp r1,#0
 291 0028 3FD1     	 bne .L23
 458:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 292              	 .loc 2 458 0
 293 002a F918     	 add r1,r7,r3
 294 002c 5200     	 lsl r2,r2,#1
 295              	.LVL21:
 296 002e 501A     	 sub r0,r2,r1
 297 0030 3C49     	 ldr r1,.L42+12
 298 0032 3D4C     	 ldr r4,.L42+16
 299              	.LVL22:
 300 0034 4143     	 mul r1,r0
 301 0036 2160     	 str r1,[r4]
 461:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }
 302              	 .loc 2 461 0
 303 0038 3C49     	 ldr r1,.L42+20
 304 003a FB1A     	 sub r3,r7,r3
 305              	.LVL23:
 306 003c 4B43     	 mul r3,r1
 307 003e 6360     	 str r3,[r4,#4]
 308              	.L24:
 309              	.LBE31:
 310              	.LBE34:
 142:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 311              	 .loc 1 142 0
 312 0040 3B4D     	 ldr r5,.L42+24
 313 0042 3C4C     	 ldr r4,.L42+28
 314 0044 AB68     	 ldr r3,[r5,#8]
 145:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 315              	 .loc 1 145 0
 316 0046 A868     	 ldr r0,[r5,#8]
 142:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 317              	 .loc 1 142 0
 318 0048 DA08     	 lsr r2,r3,#3
 319 004a 5300     	 lsl r3,r2,#1
 320 004c D318     	 add r3,r2,r3
 321 004e 7C33     	 add r3,r3,#124
 322 0050 2383     	 strh r3,[r4,#24]
 145:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 323              	 .loc 1 145 0
 324 0052 FFF7FEFF 	 bl Update_Vref_Angle
 325              	.LVL24:
 147:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {       /* Motor is in transition mode */
 326              	 .loc 1 147 0
 327 0056 6B8E     	 ldrh r3,[r5,#50]
 328 0058 002B     	 cmp r3,#0
 329 005a 36D1     	 bne .L29
 149:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 330              	 .loc 1 149 0
 331 005c AA68     	 ldr r2,[r5,#8]
 332 005e 3649     	 ldr r1,.L42+32
 333 0060 8A42     	 cmp r2,r1
 334 0062 3BD8     	 bhi .L30
 153:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 335              	 .loc 1 153 0
 336 0064 2B6C     	 ldr r3,[r5,#64]
 154:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 337              	 .loc 1 154 0
 338 0066 696A     	 ldr r1,[r5,#36]
 153:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 339              	 .loc 1 153 0
 340 0068 0133     	 add r3,r3,#1
 341 006a 2B64     	 str r3,[r5,#64]
 154:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 342              	 .loc 1 154 0
 343 006c 8B42     	 cmp r3,r1
 344 006e 07D9     	 bls .L32
 157:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             {
 345              	 .loc 1 157 0
 346 0070 1029     	 cmp r1,#16
 347 0072 01D9     	 bls .L33
 160:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             }
 348              	 .loc 1 160 0
 349 0074 0139     	 sub r1,r1,#1
 350 0076 6962     	 str r1,[r5,#36]
 351              	.L33:
 165:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 352              	 .loc 1 165 0
 353 0078 0023     	 mov r3,#0
 163:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****             /* Clear ramp counter.*/
 354              	 .loc 1 163 0
 355 007a 0132     	 add r2,r2,#1
 356 007c AA60     	 str r2,[r5,#8]
 165:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 357              	 .loc 1 165 0
 358 007e 2B64     	 str r3,[r5,#64]
 359              	.L32:
 192:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 360              	 .loc 1 192 0
 361 0080 208B     	 ldrh r0,[r4,#24]
 362 0082 03B2     	 sxth r3,r0
 363 0084 002B     	 cmp r3,#0
 364 0086 01DA     	 bge .L35
 195:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 365              	 .loc 1 195 0
 366 0088 2C48     	 ldr r0,.L42+36
 367 008a 2083     	 strh r0,[r4,#24]
 368              	.L35:
 199:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 369              	 .loc 1 199 0
 370 008c 618B     	 ldrh r1,[r4,#26]
 371 008e FFF7FEFF 	 bl PWMSVM01_Update
 372              	.LVL25:
 202:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 373              	 .loc 1 202 0
 374 0092 A368     	 ldr r3,[r4,#8]
 206:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 375              	 .loc 1 206 0
 376 0094 A868     	 ldr r0,[r5,#8]
 202:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 377              	 .loc 1 202 0
 378 0096 2361     	 str r3,[r4,#16]
 203:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 379              	 .loc 1 203 0
 380 0098 238B     	 ldrh r3,[r4,#24]
 208:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 381              	 .loc 1 208 0
 382              	 
 203:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 383              	 .loc 1 203 0
 384 009a 9B03     	 lsl r3,r3,#14
 385 009c A360     	 str r3,[r4,#8]
 206:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 386              	 .loc 1 206 0
 387 009e FFF7FEFF 	 bl Init_Smooth_Transition_To_FOC
 388              	.LVL26:
 207:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 389              	 .loc 1 207 0
 390 00a2 638B     	 ldrh r3,[r4,#26]
 391 00a4 1B04     	 lsl r3,r3,#16
 392 00a6 E360     	 str r3,[r4,#12]
 393              	.LVL27:
 208:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 394              	 .loc 1 208 0
 395 00a8 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 396              	.LVL28:
 397              	.L23:
 398              	.LBB35:
 399              	.LBB32:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 400              	 .loc 2 465 0
 401 00aa 2549     	 ldr r1,.L42+40
 402 00ac 098B     	 ldrh r1,[r1,#24]
 403 00ae 0229     	 cmp r1,#2
 404 00b0 1ED8     	 bhi .L26
 405 00b2 0029     	 cmp r1,#0
 406 00b4 27D1     	 bne .L41
 407              	.L28:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 408              	 .loc 2 470 0
 409 00b6 1D49     	 ldr r1,.L42+20
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 410              	 .loc 2 469 0
 411 00b8 FA18     	 add r2,r7,r3
 412              	.LVL29:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 413              	 .loc 2 470 0
 414 00ba FB1A     	 sub r3,r7,r3
 415              	.LVL30:
 416 00bc 4B43     	 mul r3,r1
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 417              	 .loc 2 469 0
 418 00be 1A48     	 ldr r0,.L42+16
 419 00c0 5242     	 neg r2,r2
 420 00c2 9203     	 lsl r2,r2,#14
 421 00c4 0260     	 str r2,[r0]
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 422              	 .loc 2 470 0
 423 00c6 4360     	 str r3,[r0,#4]
 424 00c8 BAE7     	 b .L24
 425              	.LVL31:
 426              	.L29:
 427              	.LBE32:
 428              	.LBE35:
 182:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       { /* If PWM duty cycle or POT ADC too low, */
 429              	 .loc 1 182 0
 430 00ca 336A     	 ldr r3,[r6,#32]
 431 00cc 312B     	 cmp r3,#49
 432 00ce D7DC     	 bgt .L32
 184:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 433              	 .loc 1 184 0
 434 00d0 0023     	 mov r3,#0
 435 00d2 EB63     	 str r3,[r5,#60]
 185:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.State = STOP_MOTOR;         /* Next, go to Motor Stop. */
 436              	 .loc 1 185 0
 437 00d4 2B64     	 str r3,[r5,#64]
 186:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 438              	 .loc 1 186 0
 439 00d6 0333     	 add r3,r3,#3
 440 00d8 EB62     	 str r3,[r5,#44]
 441 00da D1E7     	 b .L32
 442              	.L30:
 171:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 443              	 .loc 1 171 0
 444 00dc EA6B     	 ldr r2,[r5,#60]
 172:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 445              	 .loc 1 172 0
 446 00de 1949     	 ldr r1,.L42+44
 171:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 447              	 .loc 1 171 0
 448 00e0 0132     	 add r2,r2,#1
 449 00e2 EA63     	 str r2,[r5,#60]
 172:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 450              	 .loc 1 172 0
 451 00e4 8A42     	 cmp r2,r1
 452 00e6 CBD9     	 bls .L32
 175:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 453              	 .loc 1 175 0
 454 00e8 AB22     	 mov r2,#171
 176:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 455              	 .loc 1 176 0
 456 00ea EB63     	 str r3,[r5,#60]
 175:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 457              	 .loc 1 175 0
 458 00ec 6A86     	 strh r2,[r5,#50]
 459 00ee C7E7     	 b .L32
 460              	.LVL32:
 461              	.L26:
 462              	.LBB36:
 463              	.LBB33:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 464              	 .loc 2 465 0
 465 00f0 0529     	 cmp r1,#5
 466 00f2 E0D0     	 beq .L28
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 467              	 .loc 2 478 0
 468 00f4 0C49     	 ldr r1,.L42+16
 469 00f6 9303     	 lsl r3,r2,#14
 470              	.LVL33:
 471 00f8 0B60     	 str r3,[r1]
 472              	 .loc 2 479 0
 473 00fa 7B00     	 lsl r3,r7,#1
 474 00fc D218     	 add r2,r2,r3
 475              	.LVL34:
 476 00fe 0B4B     	 ldr r3,.L42+20
 477 0100 5A43     	 mul r2,r3
 478 0102 4A60     	 str r2,[r1,#4]
 479 0104 9CE7     	 b .L24
 480              	.LVL35:
 481              	.L41:
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 482              	 .loc 2 475 0
 483 0106 5B00     	 lsl r3,r3,#1
 484              	.LVL36:
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 485              	 .loc 2 474 0
 486 0108 9003     	 lsl r0,r2,#14
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 487              	 .loc 2 475 0
 488 010a D218     	 add r2,r2,r3
 489              	.LVL37:
 490 010c 0E4B     	 ldr r3,.L42+48
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 491              	 .loc 2 474 0
 492 010e 0649     	 ldr r1,.L42+16
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 493              	 .loc 2 475 0
 494 0110 5A43     	 mul r2,r3
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 495              	 .loc 2 474 0
 496 0112 0860     	 str r0,[r1]
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 497              	 .loc 2 475 0
 498 0114 4A60     	 str r2,[r1,#4]
 499 0116 93E7     	 b .L24
 500              	.L43:
 501              	 .align 2
 502              	.L42:
 503 0118 00000000 	 .word ADC
 504 011c 00000000 	 .word SVM
 505 0120 00000000 	 .word Current
 506 0124 55150000 	 .word 5461
 507 0128 00000000 	 .word Clarke_Transform
 508 012c F3240000 	 .word 9459
 509 0130 00000000 	 .word Motor
 510 0134 00000000 	 .word Car2Polar
 511 0138 BA020000 	 .word 698
 512 013c FF7F0000 	 .word 32767
 513 0140 00000000 	 .word FOCOutput
 514 0144 EE020000 	 .word 750
 515 0148 0DDBFFFF 	 .word -9459
 516              	.LBE33:
 517              	.LBE36:
 518              	 .cfi_endproc
 519              	.LFE201:
 521              	 .section .text.VF_FOC_OpenLoop_RampUp,"ax",%progbits
 522              	 .align 2
 523              	 .global VF_FOC_OpenLoop_RampUp
 524              	 .code 16
 525              	 .thumb_func
 527              	VF_FOC_OpenLoop_RampUp:
 528              	.LFB202:
 215:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 529              	 .loc 1 215 0
 530              	 .cfi_startproc
 531 0000 70B5     	 push {r4,r5,r6,lr}
 532              	 .cfi_def_cfa_offset 16
 533              	 .cfi_offset 4,-16
 534              	 .cfi_offset 5,-12
 535              	 .cfi_offset 6,-8
 536              	 .cfi_offset 14,-4
 221:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
 537              	 .loc 1 221 0
 538 0002 514C     	 ldr r4,.L65
 539 0004 514D     	 ldr r5,.L65+4
 540 0006 221C     	 mov r2,r4
 541 0008 6888     	 ldrh r0,[r5,#2]
 542 000a 2988     	 ldrh r1,[r5]
 543 000c FFF7FEFF 	 bl Get_ADCPhaseCurrent
 544              	.LVL38:
 222:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 545              	 .loc 1 222 0
 546 0010 6188     	 ldrh r1,[r4,#2]
 547 0012 A288     	 ldrh r2,[r4,#4]
 548 0014 2088     	 ldrh r0,[r4]
 549 0016 4E4C     	 ldr r4,.L65+8
 550 0018 231C     	 mov r3,r4
 551 001a FFF7FEFF 	 bl Current_Reconstruction
 552              	.LVL39:
 553              	.LBB37:
 554              	.LBB38:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 555              	 .loc 2 456 0
 556 001e A988     	 ldrh r1,[r5,#4]
 557              	.LBE38:
 558              	.LBE37:
 226:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 559              	 .loc 1 226 0
 560 0020 2268     	 ldr r2,[r4]
 561 0022 6668     	 ldr r6,[r4,#4]
 562 0024 A368     	 ldr r3,[r4,#8]
 563              	.LVL40:
 564              	.LBB42:
 565              	.LBB39:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 566              	 .loc 2 456 0
 567 0026 0029     	 cmp r1,#0
 568 0028 3DD1     	 bne .L45
 458:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 569              	 .loc 2 458 0
 570 002a F118     	 add r1,r6,r3
 571 002c 5200     	 lsl r2,r2,#1
 572              	.LVL41:
 573 002e 501A     	 sub r0,r2,r1
 574 0030 4849     	 ldr r1,.L65+12
 575 0032 494C     	 ldr r4,.L65+16
 576              	.LVL42:
 577 0034 4143     	 mul r1,r0
 578 0036 2160     	 str r1,[r4]
 461:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }
 579              	 .loc 2 461 0
 580 0038 4849     	 ldr r1,.L65+20
 581 003a F31A     	 sub r3,r6,r3
 582              	.LVL43:
 583 003c 4B43     	 mul r3,r1
 584 003e 6360     	 str r3,[r4,#4]
 585              	.L46:
 586              	.LBE39:
 587              	.LBE42:
 229:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 588              	 .loc 1 229 0
 589 0040 474D     	 ldr r5,.L65+24
 590 0042 484C     	 ldr r4,.L65+28
 591 0044 AB68     	 ldr r3,[r5,#8]
 232:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 592              	 .loc 1 232 0
 593 0046 A868     	 ldr r0,[r5,#8]
 229:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 594              	 .loc 1 229 0
 595 0048 DA08     	 lsr r2,r3,#3
 596 004a 5300     	 lsl r3,r2,#1
 597 004c D318     	 add r3,r2,r3
 598 004e 7C33     	 add r3,r3,#124
 599 0050 2383     	 strh r3,[r4,#24]
 232:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 600              	 .loc 1 232 0
 601 0052 FFF7FEFF 	 bl Update_Vref_Angle
 602              	.LVL44:
 235:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 603              	 .loc 1 235 0
 604 0056 6B8E     	 ldrh r3,[r5,#50]
 605 0058 002B     	 cmp r3,#0
 606 005a 34D1     	 bne .L51
 237:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {			/* Motor speed not reach V/f open-loop to MET/FOC transition speed.*/
 607              	 .loc 1 237 0
 608 005c AA68     	 ldr r2,[r5,#8]
 609 005e 4249     	 ldr r1,.L65+32
 610 0060 8A42     	 cmp r2,r1
 611 0062 52D8     	 bhi .L52
 239:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 612              	 .loc 1 239 0
 613 0064 2B6C     	 ldr r3,[r5,#64]
 240:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {	  /* Ramp up slowly in V/f.*/
 614              	 .loc 1 240 0
 615 0066 696A     	 ldr r1,[r5,#36]
 239:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 616              	 .loc 1 239 0
 617 0068 0133     	 add r3,r3,#1
 618 006a 2B64     	 str r3,[r5,#64]
 240:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {	  /* Ramp up slowly in V/f.*/
 619              	 .loc 1 240 0
 620 006c 8B42     	 cmp r3,r1
 621 006e 45D9     	 bls .L54
 242:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           {
 622              	 .loc 1 242 0
 623 0070 1029     	 cmp r1,#16
 624 0072 01D9     	 bls .L55
 244:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           }
 625              	 .loc 1 244 0
 626 0074 0139     	 sub r1,r1,#1
 627 0076 6962     	 str r1,[r5,#36]
 628              	.L55:
 249:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 629              	 .loc 1 249 0
 630 0078 0023     	 mov r3,#0
 247:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Clear ramp counter.*/
 631              	 .loc 1 247 0
 632 007a 0132     	 add r2,r2,#1
 249:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 633              	 .loc 1 249 0
 634 007c 2B64     	 str r3,[r5,#64]
 247:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Clear ramp counter.*/
 635              	 .loc 1 247 0
 636 007e AA60     	 str r2,[r5,#8]
 295:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 637              	 .loc 1 295 0
 638 0080 208B     	 ldrh r0,[r4,#24]
 639 0082 03B2     	 sxth r3,r0
 640 0084 002B     	 cmp r3,#0
 641 0086 3DDB     	 blt .L63
 642              	.L57:
 302:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 643              	 .loc 1 302 0
 644 0088 618B     	 ldrh r1,[r4,#26]
 645 008a FFF7FEFF 	 bl PWMSVM01_Update
 646              	.LVL45:
 305:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 647              	 .loc 1 305 0
 648 008e A368     	 ldr r3,[r4,#8]
 309:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 649              	 .loc 1 309 0
 650 0090 A868     	 ldr r0,[r5,#8]
 305:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref32 = Car2Polar.SVM_Vref16 << CORDIC_SHIFT;
 651              	 .loc 1 305 0
 652 0092 2361     	 str r3,[r4,#16]
 306:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 653              	 .loc 1 306 0
 654 0094 238B     	 ldrh r3,[r4,#24]
 312:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 655              	 .loc 1 312 0
 656              	 
 306:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 657              	 .loc 1 306 0
 658 0096 9B03     	 lsl r3,r3,#14
 659 0098 A360     	 str r3,[r4,#8]
 309:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 = Car2Polar.SVM_Angle16 << 16;
 660              	 .loc 1 309 0
 661 009a FFF7FEFF 	 bl Init_Smooth_Transition_To_FOC
 662              	.LVL46:
 310:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 663              	 .loc 1 310 0
 664 009e 638B     	 ldrh r3,[r4,#26]
 665 00a0 1B04     	 lsl r3,r3,#16
 666 00a2 E360     	 str r3,[r4,#12]
 667              	.LVL47:
 312:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 668              	 .loc 1 312 0
 669 00a4 70BD     	 pop {r4,r5,r6,pc}
 670              	.LVL48:
 671              	.L45:
 672              	.LBB43:
 673              	.LBB40:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 674              	 .loc 2 465 0
 675 00a6 3149     	 ldr r1,.L65+36
 676 00a8 098B     	 ldrh r1,[r1,#24]
 677 00aa 0229     	 cmp r1,#2
 678 00ac 37D8     	 bhi .L48
 679 00ae 0029     	 cmp r1,#0
 680 00b0 40D1     	 bne .L64
 681              	.L50:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 682              	 .loc 2 470 0
 683 00b2 2A49     	 ldr r1,.L65+20
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 684              	 .loc 2 469 0
 685 00b4 F218     	 add r2,r6,r3
 686              	.LVL49:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 687              	 .loc 2 470 0
 688 00b6 F31A     	 sub r3,r6,r3
 689              	.LVL50:
 690 00b8 4B43     	 mul r3,r1
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 691              	 .loc 2 469 0
 692 00ba 2748     	 ldr r0,.L65+16
 693 00bc 5242     	 neg r2,r2
 694 00be 9203     	 lsl r2,r2,#14
 695 00c0 0260     	 str r2,[r0]
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 696              	 .loc 2 470 0
 697 00c2 4360     	 str r3,[r0,#4]
 698 00c4 BCE7     	 b .L46
 699              	.LVL51:
 700              	.L51:
 701              	.LBE40:
 702              	.LBE43:
 267:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 703              	 .loc 1 267 0
 704 00c6 0523     	 mov r3,#5
 274:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold = (Motor.Speed * THRESHOLD_LOW) >> RES_INC;
 705              	 .loc 1 274 0
 706 00c8 4021     	 mov r1,#64
 267:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 707              	 .loc 1 267 0
 708 00ca EB62     	 str r3,[r5,#44]
 269:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.BEMF2 = 0;
 709              	 .loc 1 269 0
 710 00cc 284B     	 ldr r3,.L65+40
 711 00ce 0022     	 mov r2,#0
 274:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold = (Motor.Speed * THRESHOLD_LOW) >> RES_INC;
 712              	 .loc 1 274 0
 713 00d0 5983     	 strh r1,[r3,#26]
 275:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 714              	 .loc 1 275 0
 715 00d2 A968     	 ldr r1,[r5,#8]
 273:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold_HIGH = THRESHOLD_HIGH;
 716              	 .loc 1 273 0
 717 00d4 1020     	 mov r0,#16
 275:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 718              	 .loc 1 275 0
 719 00d6 0901     	 lsl r1,r1,#4
 720 00d8 C908     	 lsr r1,r1,#3
 721 00da 5961     	 str r1,[r3,#20]
 277:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Phase_L_Scale = SCALE_L;
 722              	 .loc 1 277 0
 723 00dc 1A21     	 mov r1,#26
 724 00de 1960     	 str r1,[r3]
 278:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 725              	 .loc 1 278 0
 726 00e0 0839     	 sub r1,r1,#8
 727 00e2 1981     	 strh r1,[r3,#8]
 281:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.LPF_N_BEMF = SHIFT_MET_PLL;
 728              	 .loc 1 281 0
 729 00e4 0F39     	 sub r1,r1,#15
 730 00e6 9981     	 strh r1,[r3,#12]
 282:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 731              	 .loc 1 282 0
 732 00e8 0139     	 sub r1,r1,#1
 269:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.BEMF2 = 0;
 733              	 .loc 1 269 0
 734 00ea 1A62     	 str r2,[r3,#32]
 270:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 735              	 .loc 1 270 0
 736 00ec 5A62     	 str r2,[r3,#36]
 273:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold_HIGH = THRESHOLD_HIGH;
 737              	 .loc 1 273 0
 738 00ee 1883     	 strh r0,[r3,#24]
 282:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 739              	 .loc 1 282 0
 740 00f0 1982     	 strh r1,[r3,#16]
 285:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Counter = 0;
 741              	 .loc 1 285 0
 742 00f2 6A86     	 strh r2,[r5,#50]
 286:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter = 0;
 743              	 .loc 1 286 0
 744 00f4 EA63     	 str r2,[r5,#60]
 287:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Alignment_Counter = 0;
 745              	 .loc 1 287 0
 746 00f6 2A64     	 str r2,[r5,#64]
 288:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Slower ramp up and ramp down for S-curve profile.*/
 747              	 .loc 1 288 0
 748 00f8 6A64     	 str r2,[r5,#68]
 290:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 749              	 .loc 1 290 0
 750 00fa 6862     	 str r0,[r5,#36]
 751              	.L54:
 295:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 752              	 .loc 1 295 0
 753 00fc 208B     	 ldrh r0,[r4,#24]
 754 00fe 03B2     	 sxth r3,r0
 755 0100 002B     	 cmp r3,#0
 756 0102 C1DA     	 bge .L57
 757              	.L63:
 298:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 758              	 .loc 1 298 0
 759 0104 1B48     	 ldr r0,.L65+44
 760 0106 2083     	 strh r0,[r4,#24]
 761 0108 BEE7     	 b .L57
 762              	.L52:
 255:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 763              	 .loc 1 255 0
 764 010a EA6B     	 ldr r2,[r5,#60]
 256:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 765              	 .loc 1 256 0
 766 010c 1A49     	 ldr r1,.L65+48
 255:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Counter > TIME_OF_VFRAMP)
 767              	 .loc 1 255 0
 768 010e 0132     	 add r2,r2,#1
 769 0110 EA63     	 str r2,[r5,#60]
 256:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 770              	 .loc 1 256 0
 771 0112 8A42     	 cmp r2,r1
 772 0114 F2D9     	 bls .L54
 259:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 773              	 .loc 1 259 0
 774 0116 AB22     	 mov r2,#171
 260:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 775              	 .loc 1 260 0
 776 0118 EB63     	 str r3,[r5,#60]
 259:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Counter = 0;
 777              	 .loc 1 259 0
 778 011a 6A86     	 strh r2,[r5,#50]
 779 011c EEE7     	 b .L54
 780              	.LVL52:
 781              	.L48:
 782              	.LBB44:
 783              	.LBB41:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 784              	 .loc 2 465 0
 785 011e 0529     	 cmp r1,#5
 786 0120 C7D0     	 beq .L50
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 787              	 .loc 2 478 0
 788 0122 0D49     	 ldr r1,.L65+16
 789 0124 9303     	 lsl r3,r2,#14
 790              	.LVL53:
 791 0126 0B60     	 str r3,[r1]
 792              	 .loc 2 479 0
 793 0128 7300     	 lsl r3,r6,#1
 794 012a D218     	 add r2,r2,r3
 795              	.LVL54:
 796 012c 0B4B     	 ldr r3,.L65+20
 797 012e 5A43     	 mul r2,r3
 798 0130 4A60     	 str r2,[r1,#4]
 799 0132 85E7     	 b .L46
 800              	.LVL55:
 801              	.L64:
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 802              	 .loc 2 475 0
 803 0134 5B00     	 lsl r3,r3,#1
 804              	.LVL56:
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 805              	 .loc 2 474 0
 806 0136 9003     	 lsl r0,r2,#14
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 807              	 .loc 2 475 0
 808 0138 D218     	 add r2,r2,r3
 809              	.LVL57:
 810 013a 104B     	 ldr r3,.L65+52
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 811              	 .loc 2 474 0
 812 013c 0649     	 ldr r1,.L65+16
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 813              	 .loc 2 475 0
 814 013e 5A43     	 mul r2,r3
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 815              	 .loc 2 474 0
 816 0140 0860     	 str r0,[r1]
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 817              	 .loc 2 475 0
 818 0142 4A60     	 str r2,[r1,#4]
 819 0144 7CE7     	 b .L46
 820              	.L66:
 821 0146 C046     	 .align 2
 822              	.L65:
 823 0148 00000000 	 .word ADC
 824 014c 00000000 	 .word SVM
 825 0150 00000000 	 .word Current
 826 0154 55150000 	 .word 5461
 827 0158 00000000 	 .word Clarke_Transform
 828 015c F3240000 	 .word 9459
 829 0160 00000000 	 .word Motor
 830 0164 00000000 	 .word Car2Polar
 831 0168 BA020000 	 .word 698
 832 016c 00000000 	 .word FOCOutput
 833 0170 00000000 	 .word FOCInput
 834 0174 FF7F0000 	 .word 32767
 835 0178 EE020000 	 .word 750
 836 017c 0DDBFFFF 	 .word -9459
 837              	.LBE41:
 838              	.LBE44:
 839              	 .cfi_endproc
 840              	.LFE202:
 842              	 .section .text.VF_Smooth_Transition_To_FOC,"ax",%progbits
 843              	 .align 2
 844              	 .global VF_Smooth_Transition_To_FOC
 845              	 .code 16
 846              	 .thumb_func
 848              	VF_Smooth_Transition_To_FOC:
 849              	.LFB204:
 370:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 371:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 372:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 373:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define MET_VREF_STEP			(1U)
 374:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** For control strategy MET (Maximum Efficiency Tracking)
 375:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** ** Execution time: ?us (O3 - Optimize most).
 376:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** * -----------------------------------------------------------*/
 377:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** uint16_t VF_Smooth_Transition_To_FOC (void)
 378:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 850              	 .loc 1 378 0
 851              	 .cfi_startproc
 852              	.LVL58:
 853 0000 F8B5     	 push {r3,r4,r5,r6,r7,lr}
 854              	 .cfi_def_cfa_offset 24
 855              	 .cfi_offset 3,-24
 856              	 .cfi_offset 4,-20
 857              	 .cfi_offset 5,-16
 858              	 .cfi_offset 6,-12
 859              	 .cfi_offset 7,-8
 860              	 .cfi_offset 14,-4
 379:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     int32_t Vref_Change_Step;
 380:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Î”V, change (increase / decrease, if necessary) step for |Vref| of SVM */
 381:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     uint16_t Mode_Flag = MOTOR_TRANSITION;
 382:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* A temporary variable to indicate leading or lagging of I to V.*/
 383:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     int32_t Flag_Leading_Lagging;
 384:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* 2or3-shunt phase current sensing.*/
 385:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     FOCInput.Ref_Speed = Motor.Speed;
 861              	 .loc 1 385 0
 862 0002 474B     	 ldr r3,.L88
 863 0004 474C     	 ldr r4,.L88+4
 864 0006 9B68     	 ldr r3,[r3,#8]
 386:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 387:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 388:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     //  Get_ADC_SingleShuntCurrent(&ADC);
 389:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Curr
 390:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 391:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 392:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
 865              	 .loc 1 392 0
 866 0008 474D     	 ldr r5,.L88+8
 867 000a 484E     	 ldr r6,.L88+12
 385:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 868              	 .loc 1 385 0
 869 000c 2364     	 str r3,[r4,#64]
 870              	 .loc 1 392 0
 871 000e 2A1C     	 mov r2,r5
 872 0010 7088     	 ldrh r0,[r6,#2]
 873 0012 3188     	 ldrh r1,[r6]
 874 0014 FFF7FEFF 	 bl Get_ADCPhaseCurrent
 875              	.LVL59:
 393:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 394:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
 876              	 .loc 1 394 0
 877 0018 6988     	 ldrh r1,[r5,#2]
 878 001a AA88     	 ldrh r2,[r5,#4]
 879 001c 2888     	 ldrh r0,[r5]
 880 001e 444D     	 ldr r5,.L88+16
 881 0020 2B1C     	 mov r3,r5
 882 0022 FFF7FEFF 	 bl Current_Reconstruction
 883              	.LVL60:
 884              	.LBB45:
 885              	.LBB46:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 886              	 .loc 2 456 0
 887 0026 B188     	 ldrh r1,[r6,#4]
 888              	.LBE46:
 889              	.LBE45:
 395:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 396:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ClarkeTransform(Current.I_U, Current.I_V, Current.I_W, &Clarke_Transform);
 890              	 .loc 1 396 0
 891 0028 2A68     	 ldr r2,[r5]
 892 002a 6F68     	 ldr r7,[r5,#4]
 893 002c AB68     	 ldr r3,[r5,#8]
 894              	.LVL61:
 895              	.LBB50:
 896              	.LBB47:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 897              	 .loc 2 456 0
 898 002e 0029     	 cmp r1,#0
 899 0030 30D1     	 bne .L68
 458:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 900              	 .loc 2 458 0
 901 0032 F918     	 add r1,r7,r3
 902 0034 5200     	 lsl r2,r2,#1
 903              	.LVL62:
 904 0036 501A     	 sub r0,r2,r1
 905 0038 3E49     	 ldr r1,.L88+20
 906 003a 3F4D     	 ldr r5,.L88+24
 907              	.LVL63:
 908 003c 4143     	 mul r1,r0
 909 003e 2960     	 str r1,[r5]
 461:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }
 910              	 .loc 2 461 0
 911 0040 3E49     	 ldr r1,.L88+28
 912 0042 FB1A     	 sub r3,r7,r3
 913              	.LVL64:
 914 0044 4B43     	 mul r3,r1
 915 0046 6B60     	 str r3,[r5,#4]
 916              	.L69:
 917              	.LBE47:
 918              	.LBE50:
 397:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 398:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Î¸[k] = Î¸[k-1] + Ï‰[k]. Motor rotates in one direction only. Rotor angle always incr
 399:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Car2Polar.Vref_AngleQ31 += (FOCInput.Ref_Speed << (16U-FOCInput.Res_Inc));
 919              	 .loc 1 399 0
 920 0048 1023     	 mov r3,#16
 921 004a A289     	 ldrh r2,[r4,#12]
 922 004c 3C4D     	 ldr r5,.L88+32
 923 004e 9B1A     	 sub r3,r3,r2
 924 0050 226C     	 ldr r2,[r4,#64]
 400:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 401:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* To calculate |Vref|sin(Î³-Î¸), Ï‰L|I|, and Îµ = |Vref|sin(Î³-Î¸)+ Ï‰L|I|. */
 402:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Init_Smooth_Transition_To_FOC (FOCInput.Ref_Speed);
 925              	 .loc 1 402 0
 926 0052 206C     	 ldr r0,[r4,#64]
 399:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 927              	 .loc 1 399 0
 928 0054 9A40     	 lsl r2,r2,r3
 929 0056 131C     	 mov r3,r2
 930 0058 EA68     	 ldr r2,[r5,#12]
 931 005a 9446     	 mov ip,r2
 932 005c 6344     	 add r3,r3,ip
 933 005e EB60     	 str r3,[r5,#12]
 934              	 .loc 1 402 0
 935 0060 FFF7FEFF 	 bl Init_Smooth_Transition_To_FOC
 936              	.LVL65:
 403:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 404:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Bang-bang controller (aka: hysteresis controller, on-off controller) of MET Controller
 405:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     * Execution time: 1.5us~2.1us (O3 - Optimize most).
 406:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     * ------------------------------------------------------------------------------------------ */
 407:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* (Î³-Î¸) >= zero (i.e.: I is leading V) is an urgent condition, to increase |Vref| immedi
 408:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Flag_Leading_Lagging = FOCInput.BEMF1;
 409:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 410:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Flag_Leading_Lagging >= 0)
 937              	 .loc 1 410 0
 938 0064 236A     	 ldr r3,[r4,#32]
 939 0066 002B     	 cmp r3,#0
 940 0068 24DB     	 blt .L74
 411:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 412:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* An urgent condition,*/
 413:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Increase |Vref| immediately.*/
 414:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Car2Polar.Vref32 += (MET_VREF_STEP << CORDIC_SHIFT);
 941              	 .loc 1 414 0
 942 006a 8022     	 mov r2,#128
 943 006c D201     	 lsl r2,r2,#7
 944 006e 9446     	 mov ip,r2
 945 0070 AB68     	 ldr r3,[r5,#8]
 946 0072 6344     	 add r3,r3,ip
 947 0074 181C     	 mov r0,r3
 948              	.L84:
 415:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 416:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* MET loop unlocked, Îµ_Th = Îµ_Th_L Threshold_LOW.*/
 417:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       FOCInput.Threshold = (FOCInput.Ref_Speed * FOCInput.Threshold_LOW) >> FOCInput.Res_Inc;
 418:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 419:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     else
 420:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {	/* (Î³-Î¸) < zero.*/
 421:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Epsilon < 0)
 422:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 423:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Epsilon = -Epsilon;
 424:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Reverse Îµ value, i.e.: find |Îµ|. */
 425:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Vref_Change_Step = -MET_VREF_STEP;
 426:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 427:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* |Vref| should be decreased (or no change) if Îµ < 0. */
 428:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #define	MIN_AMPLITUDE	(20U)
 429:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Minimum value of |Vref| */
 430:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Car2Polar.Vref32 <= (MIN_AMPLITUDE << CORDIC_SHIFT))
 431:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 432:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* |Vref| cannot decrease further if it is too small.*/
 433:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Vref_Change_Step = 0;
 434:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 435:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 436:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 437:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 438:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* |Vref| should be increased (or no change) if Îµ >= 0.*/
 439:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Vref_Change_Step = MET_VREF_STEP;
 440:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 441:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 442:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Epsilon > FOCInput.Threshold)
 443:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 444:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* If |Îµ| > Îµ_Th,*/
 445:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* |Vref| changes (increase or decrease) by a step.*/
 446:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Car2Polar.Vref32 += (Vref_Change_Step << CORDIC_SHIFT);
 949              	 .loc 1 446 0
 950 0076 A860     	 str r0,[r5,#8]
 447:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 448:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* MET loop unlocked, Îµ_Th = Îµ_Th_L Threshold_LOW.*/
 449:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         FOCInput.Threshold = (FOCInput.Ref_Speed * FOCInput.Threshold_LOW) >> FOCInput.Res_Inc;
 951              	 .loc 1 449 0
 952 0078 226C     	 ldr r2,[r4,#64]
 953 007a 238B     	 ldrh r3,[r4,#24]
 954 007c 5343     	 mul r3,r2
 955 007e A289     	 ldrh r2,[r4,#12]
 956 0080 1341     	 asr r3,r3,r2
 957 0082 6361     	 str r3,[r4,#20]
 381:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* A temporary variable to indicate leading or lagging of I to V.*/
 958              	 .loc 1 381 0
 959 0084 0024     	 mov r4,#0
 960              	.L75:
 961              	.LVL66:
 450:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 451:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 452:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {	/* If |Îµ| <= Îµ_Th, |Vref| no need change.*/
 453:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /*  MET loop locked,  Îµ_Th = Îµ_Th_H Threshold_HIGH.*/
 454:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         FOCInput.Threshold = (FOCInput.Ref_Speed * FOCInput.Threshold_HIGH) >> FOCInput.Res_Inc;
 455:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 456:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (FOCInput.Flag_State == 0)
 457:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 458:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* If use 3-step motor start-up V/f-> MET-> FOC,*/
 459:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /*  Change flag: motor in MET stable mode once it finds |Îµ| <= Îµ_Th, try to jump to
 460:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Mode_Flag = MOTOR_STABLE;
 461:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 462:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 463:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 464:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Update SVM PWM.*/
 465:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     PWMSVM01_Update((Car2Polar.Vref32 >> CORDIC_SHIFT), Car2Polar.Vref_AngleQ31>>16U);
 962              	 .loc 1 465 0
 963 0086 800B     	 lsr r0,r0,#14
 964 0088 E989     	 ldrh r1,[r5,#14]
 965 008a 80B2     	 uxth r0,r0
 966 008c FFF7FEFF 	 bl PWMSVM01_Update
 967              	.LVL67:
 466:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 467:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     return (Mode_Flag);
 468:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 968              	 .loc 1 468 0
 969              	 
 970 0090 201C     	 mov r0,r4
 971              	.LVL68:
 972              	.LVL69:
 973 0092 F8BD     	 pop {r3,r4,r5,r6,r7,pc}
 974              	.LVL70:
 975              	.L68:
 976              	.LBB51:
 977              	.LBB48:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 978              	 .loc 2 465 0
 979 0094 2B49     	 ldr r1,.L88+36
 980 0096 098B     	 ldrh r1,[r1,#24]
 981 0098 0229     	 cmp r1,#2
 982 009a 21D8     	 bhi .L71
 983 009c 0029     	 cmp r1,#0
 984 009e 2AD1     	 bne .L86
 985              	.L73:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 986              	 .loc 2 470 0
 987 00a0 2649     	 ldr r1,.L88+28
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 988              	 .loc 2 469 0
 989 00a2 FA18     	 add r2,r7,r3
 990              	.LVL71:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 991              	 .loc 2 470 0
 992 00a4 FB1A     	 sub r3,r7,r3
 993              	.LVL72:
 994 00a6 4B43     	 mul r3,r1
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 995              	 .loc 2 469 0
 996 00a8 2348     	 ldr r0,.L88+24
 997 00aa 5242     	 neg r2,r2
 998 00ac 9203     	 lsl r2,r2,#14
 999 00ae 0260     	 str r2,[r0]
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 1000              	 .loc 2 470 0
 1001 00b0 4360     	 str r3,[r0,#4]
 1002 00b2 C9E7     	 b .L69
 1003              	.LVL73:
 1004              	.L74:
 1005              	.LBE48:
 1006              	.LBE51:
 421:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 1007              	 .loc 1 421 0
 1008 00b4 244A     	 ldr r2,.L88+40
 1009 00b6 1368     	 ldr r3,[r2]
 1010 00b8 002B     	 cmp r3,#0
 1011 00ba 28DB     	 blt .L76
 439:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 1012              	 .loc 1 439 0
 1013 00bc 0122     	 mov r2,#1
 1014 00be A868     	 ldr r0,[r5,#8]
 1015              	.L77:
 1016              	.LVL74:
 442:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 1017              	 .loc 1 442 0
 1018 00c0 6169     	 ldr r1,[r4,#20]
 1019 00c2 8B42     	 cmp r3,r1
 1020 00c4 20D8     	 bhi .L87
 454:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1021              	 .loc 1 454 0
 1022 00c6 226C     	 ldr r2,[r4,#64]
 1023              	.LVL75:
 1024 00c8 638B     	 ldrh r3,[r4,#26]
 1025 00ca 5343     	 mul r3,r2
 1026 00cc A289     	 ldrh r2,[r4,#12]
 1027 00ce 1341     	 asr r3,r3,r2
 456:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1028              	 .loc 1 456 0
 1029 00d0 A28B     	 ldrh r2,[r4,#28]
 454:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1030              	 .loc 1 454 0
 1031 00d2 6361     	 str r3,[r4,#20]
 381:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* A temporary variable to indicate leading or lagging of I to V.*/
 1032              	 .loc 1 381 0
 1033 00d4 5342     	 neg r3,r2
 1034 00d6 5341     	 adc r3,r3,r2
 460:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 1035              	 .loc 1 460 0
 1036 00d8 AB24     	 mov r4,#171
 381:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* A temporary variable to indicate leading or lagging of I to V.*/
 1037              	 .loc 1 381 0
 1038 00da 5B42     	 neg r3,r3
 1039 00dc 1C40     	 and r4,r3
 1040 00de D2E7     	 b .L75
 1041              	.LVL76:
 1042              	.L71:
 1043              	.LBB52:
 1044              	.LBB49:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 1045              	 .loc 2 465 0
 1046 00e0 0529     	 cmp r1,#5
 1047 00e2 DDD0     	 beq .L73
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 1048              	 .loc 2 478 0
 1049 00e4 1449     	 ldr r1,.L88+24
 1050 00e6 9303     	 lsl r3,r2,#14
 1051              	.LVL77:
 1052 00e8 0B60     	 str r3,[r1]
 1053              	 .loc 2 479 0
 1054 00ea 7B00     	 lsl r3,r7,#1
 1055 00ec D218     	 add r2,r2,r3
 1056              	.LVL78:
 1057 00ee 134B     	 ldr r3,.L88+28
 1058 00f0 5A43     	 mul r2,r3
 1059 00f2 4A60     	 str r2,[r1,#4]
 1060 00f4 A8E7     	 b .L69
 1061              	.LVL79:
 1062              	.L86:
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1063              	 .loc 2 475 0
 1064 00f6 5B00     	 lsl r3,r3,#1
 1065              	.LVL80:
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1066              	 .loc 2 474 0
 1067 00f8 9003     	 lsl r0,r2,#14
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1068              	 .loc 2 475 0
 1069 00fa D218     	 add r2,r2,r3
 1070              	.LVL81:
 1071 00fc 134B     	 ldr r3,.L88+44
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1072              	 .loc 2 474 0
 1073 00fe 0E49     	 ldr r1,.L88+24
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1074              	 .loc 2 475 0
 1075 0100 5A43     	 mul r2,r3
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1076              	 .loc 2 474 0
 1077 0102 0860     	 str r0,[r1]
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1078              	 .loc 2 475 0
 1079 0104 4A60     	 str r2,[r1,#4]
 1080 0106 9FE7     	 b .L69
 1081              	.LVL82:
 1082              	.L87:
 1083              	.LBE49:
 1084              	.LBE52:
 446:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1085              	 .loc 1 446 0
 1086 0108 9203     	 lsl r2,r2,#14
 1087              	.LVL83:
 1088 010a 8018     	 add r0,r0,r2
 1089 010c B3E7     	 b .L84
 1090              	.L76:
 423:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Reverse Îµ value, i.e.: find |Îµ|. */
 1091              	 .loc 1 423 0
 1092 010e 5B42     	 neg r3,r3
 1093 0110 1360     	 str r3,[r2]
 1094              	.LVL84:
 430:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1095              	 .loc 1 430 0
 1096 0112 A022     	 mov r2,#160
 1097 0114 A868     	 ldr r0,[r5,#8]
 1098 0116 D202     	 lsl r2,r2,#11
 1099 0118 8242     	 cmp r2,r0
 1100 011a 9241     	 sbc r2,r2,r2
 1101 011c D0E7     	 b .L77
 1102              	.L89:
 1103 011e C046     	 .align 2
 1104              	.L88:
 1105 0120 00000000 	 .word Motor
 1106 0124 00000000 	 .word FOCInput
 1107 0128 00000000 	 .word ADC
 1108 012c 00000000 	 .word SVM
 1109 0130 00000000 	 .word Current
 1110 0134 55150000 	 .word 5461
 1111 0138 00000000 	 .word Clarke_Transform
 1112 013c F3240000 	 .word 9459
 1113 0140 00000000 	 .word Car2Polar
 1114 0144 00000000 	 .word FOCOutput
 1115 0148 00000000 	 .word Epsilon
 1116 014c 0DDBFFFF 	 .word -9459
 1117              	 .cfi_endproc
 1118              	.LFE204:
 1120              	 .section .text.Stop_Motor,"ax",%progbits
 1121              	 .align 2
 1122              	 .global Stop_Motor
 1123              	 .code 16
 1124              	 .thumb_func
 1126              	Stop_Motor:
 1127              	.LFB205:
 469:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 470:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 471:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** Stop the motor, check PWM or POT ADC (for adjusting motor speed)
 472:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  ** Execution time: ?us (O3 - Optimize most).
 473:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	* ---------------------------------------------------------------------*/
 474:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** void Stop_Motor (void)
 475:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 1128              	 .loc 1 475 0
 1129              	 .cfi_startproc
 1130 0000 70B5     	 push {r4,r5,r6,lr}
 1131              	 .cfi_def_cfa_offset 16
 1132              	 .cfi_offset 4,-16
 1133              	 .cfi_offset 5,-12
 1134              	 .cfi_offset 6,-8
 1135              	 .cfi_offset 14,-4
 476:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     static uint32_t  local_counter = 0;      // General purpose counter
 477:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 478:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 479:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Current_Reconstruction(FOCOutput.Previous_SVM_SectorNo, ADC.ADC_Result1, ADC.ADC_Result2, &Cu
 480:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 481:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* 2or3-shunt 3-phase current reconstruction, to get Iu and Iv */
 482:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Current_Reconstruction(ADC.ADC_Iu, ADC.ADC_Iv, ADC.ADC_Iw, &Current);
 1136              	 .loc 1 482 0
 1137 0002 4D4C     	 ldr r4,.L112
 1138 0004 4D4D     	 ldr r5,.L112+4
 1139 0006 231C     	 mov r3,r4
 1140 0008 6988     	 ldrh r1,[r5,#2]
 1141 000a AA88     	 ldrh r2,[r5,#4]
 1142 000c 2888     	 ldrh r0,[r5]
 1143 000e FFF7FEFF 	 bl Current_Reconstruction
 1144              	.LVL85:
 1145              	.LBB66:
 1146              	.LBB67:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 1147              	 .loc 2 456 0
 1148 0012 4B49     	 ldr r1,.L112+8
 1149              	.LBE67:
 1150              	.LBE66:
 483:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 484:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       ClarkeTransform(Current.I_U, Current.I_V,Current.I_W, &Clarke_Transform);
 1151              	 .loc 1 484 0
 1152 0014 2268     	 ldr r2,[r4]
 1153              	.LBB71:
 1154              	.LBB68:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 1155              	 .loc 2 456 0
 1156 0016 8988     	 ldrh r1,[r1,#4]
 1157              	.LBE68:
 1158              	.LBE71:
 1159              	 .loc 1 484 0
 1160 0018 6668     	 ldr r6,[r4,#4]
 1161 001a A368     	 ldr r3,[r4,#8]
 1162              	.LVL86:
 1163              	.LBB72:
 1164              	.LBB69:
 456:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     /* I_Alpha = (2 * I_U - (I_V + I_W))/3 */
 1165              	 .loc 2 456 0
 1166 001c 0029     	 cmp r1,#0
 1167 001e 31D1     	 bne .L91
 458:../PMSM_FOC/ControlModules/pmsm_foc_functions.h **** 
 1168              	 .loc 2 458 0
 1169 0020 F118     	 add r1,r6,r3
 1170 0022 5200     	 lsl r2,r2,#1
 1171              	.LVL87:
 1172 0024 501A     	 sub r0,r2,r1
 1173 0026 4749     	 ldr r1,.L112+12
 1174 0028 474C     	 ldr r4,.L112+16
 1175              	.LVL88:
 1176 002a 4143     	 mul r1,r0
 1177 002c 2160     	 str r1,[r4]
 461:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****   }
 1178              	 .loc 2 461 0
 1179 002e 4749     	 ldr r1,.L112+20
 1180 0030 F31A     	 sub r3,r6,r3
 1181              	.LVL89:
 1182 0032 4B43     	 mul r3,r1
 1183 0034 6360     	 str r3,[r4,#4]
 1184              	.L92:
 1185              	.LBE69:
 1186              	.LBE72:
 485:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       local_counter ++;
 1187              	 .loc 1 485 0
 1188 0036 464A     	 ldr r2,.L112+24
 486:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #if(uCPROBE_GUI == ENABLED)
 487:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if(Update_KpKi == UCPROBE_BUTTON_PRESSED)
 1189              	 .loc 1 487 0
 1190 0038 4649     	 ldr r1,.L112+28
 485:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       local_counter ++;
 1191              	 .loc 1 485 0
 1192 003a 1368     	 ldr r3,[r2]
 1193              	 .loc 1 487 0
 1194 003c 0868     	 ldr r0,[r1]
 1195 003e 4649     	 ldr r1,.L112+32
 485:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       local_counter ++;
 1196              	 .loc 1 485 0
 1197 0040 0133     	 add r3,r3,#1
 1198 0042 1360     	 str r3,[r2]
 1199              	 .loc 1 487 0
 1200 0044 8842     	 cmp r0,r1
 1201 0046 44D0     	 beq .L109
 488:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 489:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Disable CCU8 interrupt to enable update of user parameter */
 490:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       NVIC_DisableIRQ(CCU80_0_IRQn);
 491:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 492:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[1] = PI_Speed.Kp;
 493:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[2] = PI_Speed.Ki;
 494:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[3] = PI_Speed.Scale_KpKi;
 495:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 496:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[4] = PI_Torque.Kp;
 497:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[5] = PI_Torque.Ki;
 498:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[6] = PI_Torque.Scale_KpKi;
 499:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 500:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[7] = PI_Flux.Kp;
 501:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[8] = PI_Flux.Ki;
 502:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[9] = PI_Flux.Scale_KpKi;
 503:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 504:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[10] = PI_PLL.Kp;
 505:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[11] = PI_PLL.Ki;
 506:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[12] = PI_PLL.Scale_KpKi;
 507:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 508:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       uint32_t *MotorCONF_Address = MotorConfig_Addr;
 509:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       uint32_t *UserConfig_Address = &User_Para[0];
 510:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       XMC_FLASH_ProgramVerifyPage(MotorCONF_Address,UserConfig_Address);
 511:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 512:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       NVIC_SystemReset();
 513:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 514:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #endif
 515:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 516:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (SYSTEM_BE_IDLE)
 1202              	 .loc 1 516 0
 1203 0048 296A     	 ldr r1,[r5,#32]
 1204 004a 3129     	 cmp r1,#49
 1205 004c 0CDC     	 bgt .L99
 517:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 518:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* If system is idle, i.e.: PWM duty cycle or POT ADC too low.*/
 519:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Reset counter, local_counter < TIME_OF_STOP to prevent it from re-start of motor.*/
 520:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       local_counter = 0;
 1206              	 .loc 1 520 0
 1207 004e 0021     	 mov r1,#0
 1208 0050 081C     	 mov r0,r1
 521:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Speed = 0;
 1209              	 .loc 1 521 0
 1210 0052 424B     	 ldr r3,.L112+36
 520:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Speed = 0;
 1211              	 .loc 1 520 0
 1212 0054 1160     	 str r1,[r2]
 1213              	 .loc 1 521 0
 1214 0056 9960     	 str r1,[r3,#8]
 1215              	.L100:
 522:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 523:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 524:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 525:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (local_counter > TIME_OF_STOP)
 526:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 527:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       local_counter = 0;
 528:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #if (CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 529:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Init ADC, for current sensing, ADC of DC link Vdc (and POT). Do at later stage of the init
 530:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       ADC_Init();
 531:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       ADC_DCLink_Init();
 532:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       ADC_Pot_Init();
 533:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #endif
 534:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       CCU8_Init();
 535:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Variables_Init ();
 536:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       CCUx_SynStart();
 537:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 538:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Direct FOC startup. Motor startup to FOC closed-loop directly, no V/f or MET*/
 539:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #if(MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_DIRECT_FOC || MY_FOC_CONTROL_SCHEME == CONSTANT_T
 540:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Next, go to rotor initial preposition/alignment.*/
 541:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.State = PRE_POSITIONING;
 542:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_VF_MET_FOC)
 543:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.State = VFOPENLOOP_RAMP_UP;             // Next, go to V/f ramp-up and re-start the mot
 544:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_VF_ONLY)
 545:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.State = BRAKE_BOOTSTRAP;
 546:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #endif
 547:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 548:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.State == VFOPENLOOP_RAMP_UP)
 549:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 550:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Up_Rate = (RAMPUP_RATE * 40); /* In V/f, much slower initial ramp up for S-curve
 551:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 552:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 553:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     else
 554:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 555:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* To update angle θ (16-bit) of SVM reference vector Vref */
 556:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Update_Vref_Angle (Motor.Speed);
 1216              	 .loc 1 556 0
 1217 0058 FFF7FEFF 	 bl Update_Vref_Angle
 1218              	.LVL90:
 557:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Update SVM PWM, brake motor.*/
 558:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       PWMSVM01_Update(0, Car2Polar.SVM_Angle16);
 1219              	 .loc 1 558 0
 1220 005c 404B     	 ldr r3,.L112+40
 1221 005e 0020     	 mov r0,#0
 1222 0060 598B     	 ldrh r1,[r3,#26]
 1223 0062 FFF7FEFF 	 bl PWMSVM01_Update
 1224              	.LVL91:
 1225              	.L90:
 559:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 560:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 561:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 1226              	 .loc 1 561 0
 1227              	 
 1228              	.LVL92:
 1229 0066 70BD     	 pop {r4,r5,r6,pc}
 1230              	.LVL93:
 1231              	.L99:
 525:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 1232              	 .loc 1 525 0
 1233 0068 C82B     	 cmp r3,#200
 1234 006a 26D9     	 bls .L110
 527:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #if (CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 1235              	 .loc 1 527 0
 1236 006c 0023     	 mov r3,#0
 1237 006e 1360     	 str r3,[r2]
 534:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Variables_Init ();
 1238              	 .loc 1 534 0
 1239 0070 FFF7FEFF 	 bl CCU8_Init
 1240              	.LVL94:
 535:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       CCUx_SynStart();
 1241              	 .loc 1 535 0
 1242 0074 FFF7FEFF 	 bl Variables_Init
 1243              	.LVL95:
 536:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1244              	 .loc 1 536 0
 1245 0078 FFF7FEFF 	 bl CCUx_SynStart
 1246              	.LVL96:
 541:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_VF_MET_FOC)
 1247              	 .loc 1 541 0
 1248 007c 0622     	 mov r2,#6
 1249 007e 374B     	 ldr r3,.L112+36
 1250 0080 DA62     	 str r2,[r3,#44]
 1251 0082 F0E7     	 b .L90
 1252              	.LVL97:
 1253              	.L91:
 1254              	.LBB73:
 1255              	.LBB70:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 1256              	 .loc 2 465 0
 1257 0084 3749     	 ldr r1,.L112+44
 1258 0086 098B     	 ldrh r1,[r1,#24]
 1259 0088 0229     	 cmp r1,#2
 1260 008a 0BD8     	 bhi .L94
 1261 008c 0029     	 cmp r1,#0
 1262 008e 17D1     	 bne .L111
 1263              	.L96:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 1264              	 .loc 2 470 0
 1265 0090 2E49     	 ldr r1,.L112+20
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 1266              	 .loc 2 469 0
 1267 0092 F218     	 add r2,r6,r3
 1268              	.LVL98:
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 1269              	 .loc 2 470 0
 1270 0094 F31A     	 sub r3,r6,r3
 1271              	.LVL99:
 1272 0096 4B43     	 mul r3,r1
 469:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseV - CurrentPhaseW) * (DIV_SQRT3_Q14 << (CORDIC_SHIF
 1273              	 .loc 2 469 0
 1274 0098 2B48     	 ldr r0,.L112+16
 1275 009a 5242     	 neg r2,r2
 1276 009c 9203     	 lsl r2,r2,#14
 1277 009e 0260     	 str r2,[r0]
 470:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****       break;
 1278              	 .loc 2 470 0
 1279 00a0 4360     	 str r3,[r0,#4]
 1280 00a2 C8E7     	 b .L92
 1281              	.LVL100:
 1282              	.L94:
 465:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****     {
 1283              	 .loc 2 465 0
 1284 00a4 0529     	 cmp r1,#5
 1285 00a6 F3D0     	 beq .L96
 478:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 = (CurrentPhaseU + (CurrentPhaseV << 1)) * (DIV_SQRT3_Q14 <<(CORDI
 1286              	 .loc 2 478 0
 1287 00a8 2749     	 ldr r1,.L112+16
 1288 00aa 9303     	 lsl r3,r2,#14
 1289              	.LVL101:
 1290 00ac 0B60     	 str r3,[r1]
 1291              	 .loc 2 479 0
 1292 00ae 7300     	 lsl r3,r6,#1
 1293 00b0 D218     	 add r2,r2,r3
 1294              	.LVL102:
 1295 00b2 264B     	 ldr r3,.L112+20
 1296 00b4 5A43     	 mul r2,r3
 1297 00b6 4A60     	 str r2,[r1,#4]
 1298 00b8 BDE7     	 b .L92
 1299              	.LVL103:
 1300              	.L110:
 1301 00ba 284B     	 ldr r3,.L112+36
 1302 00bc 9868     	 ldr r0,[r3,#8]
 1303 00be CBE7     	 b .L100
 1304              	.LVL104:
 1305              	.L111:
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1306              	 .loc 2 475 0
 1307 00c0 5B00     	 lsl r3,r3,#1
 1308              	.LVL105:
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1309              	 .loc 2 474 0
 1310 00c2 9003     	 lsl r0,r2,#14
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1311              	 .loc 2 475 0
 1312 00c4 D218     	 add r2,r2,r3
 1313              	.LVL106:
 1314 00c6 284B     	 ldr r3,.L112+48
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1315              	 .loc 2 474 0
 1316 00c8 1F49     	 ldr r1,.L112+16
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1317              	 .loc 2 475 0
 1318 00ca 5A43     	 mul r2,r3
 474:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****           HandlePtr->I_Beta_1Q31 =  (CurrentPhaseU + (CurrentPhaseW << 1)) * (-(DIV_SQRT3_Q14 <<(CO
 1319              	 .loc 2 474 0
 1320 00cc 0860     	 str r0,[r1]
 475:../PMSM_FOC/ControlModules/pmsm_foc_functions.h ****         break;
 1321              	 .loc 2 475 0
 1322 00ce 4A60     	 str r2,[r1,#4]
 1323 00d0 B1E7     	 b .L92
 1324              	.LVL107:
 1325              	.L109:
 1326              	.LBE70:
 1327              	.LBE73:
 1328              	.LBB74:
 1329              	.LBB75:
 1330              	.LBB76:
 1331              	 .file 3 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include/core_cm0.h"
   1:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /**************************************************************************//**
   2:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  * @file     core_cm0.h
   3:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  * @version  V4.20
   5:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  * @date     20. August 2015
   6:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
   7:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
   9:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    All rights reserved.
  10:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    Redistribution and use in source and binary forms, with or without
  11:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    modification, are permitted provided that the following conditions are met:
  12:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    - Redistributions of source code must retain the above copyright
  13:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      notice, this list of conditions and the following disclaimer.
  14:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    - Redistributions in binary form must reproduce the above copyright
  15:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      notice, this list of conditions and the following disclaimer in the
  16:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      documentation and/or other materials provided with the distribution.
  17:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      to endorse or promote products derived from this software without
  19:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      specific prior written permission.
  20:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    *
  21:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    ---------------------------------------------------------------------------*/
  33:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  34:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  35:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #if   defined ( __ICCARM__ )
  36:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif (__ARMCC_VERSION >= 6010050)
  38:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  39:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
  40:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  41:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  42:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CORE_CM0_H_GENERIC
  43:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  44:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #include <stdint.h>
  45:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  46:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
  47:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  extern "C" {
  48:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
  49:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  50:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  51:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  52:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  53:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  54:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  55:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  56:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  57:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      Unions are used for effective representation of core registers.
  58:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  59:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  60:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****      Function-like macros are used to allow more efficient code.
  61:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
  62:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  63:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  64:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
  65:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  *                 CMSIS definitions
  66:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
  67:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup Cortex_M0
  68:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
  69:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
  70:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  71:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*  CMSIS CM0 definitions */
  72:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS H
  73:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (0x14U)                                      /*!< [15:0]  CMSIS H
  74:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  75:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL versi
  76:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  77:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  78:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  79:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  80:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #if   defined ( __CC_ARM )
  81:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  82:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  83:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static __inline
  84:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  85:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __GNUC__ )
  86:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  87:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  88:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static inline
  89:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  90:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __ICCARM__ )
  91:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  92:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
  93:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static inline
  94:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  95:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TMS470__ )
  96:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
  97:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static inline
  98:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
  99:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TASKING__ )
 100:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 101:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 102:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static inline
 103:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 104:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __CSMC__ )
 105:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __packed
 106:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 107:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
 108:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static inline
 109:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 110:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif (__ARMCC_VERSION >= 6010050)
 111:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
 112:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
 113:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define __STATIC_INLINE  static __inline
 114:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 115:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #else
 116:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #error Unknown compiler
 117:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 118:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 119:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
 120:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     This core does not support an FPU at all
 121:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 122:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __FPU_USED       0U
 123:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 124:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #if defined ( __CC_ARM )
 125:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __TARGET_FPU_VFP
 126:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 127:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 128:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 129:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __GNUC__ )
 130:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 131:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 132:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 133:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 134:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __ICCARM__ )
 135:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __ARMVFP__
 136:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 137:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 138:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 139:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TMS470__ )
 140:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 141:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 142:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 143:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 144:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __TASKING__ )
 145:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __FPU_VFP__
 146:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 147:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 148:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 149:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif defined ( __CSMC__ )
 150:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 151:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 152:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 153:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 154:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #elif (__ARMCC_VERSION >= 6010050)
 155:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #if defined __ARM_PCS_VFP
 156:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 157:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 158:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 159:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 160:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 161:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 162:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #include "core_cmFunc.h"                 /* Core Function Access */
 163:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 164:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 165:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 166:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 167:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 168:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 169:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 170:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CMSIS_GENERIC
 171:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 172:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 173:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 174:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 175:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 176:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  extern "C" {
 177:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 178:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 179:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* check device defines and use defaults */
 180:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 181:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __CM0_REV
 182:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #define __CM0_REV               0x0000U
 183:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 184:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 185:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 186:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 187:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 188:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 189:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 190:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 191:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 192:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 193:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 194:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #endif
 195:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 196:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 197:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 198:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /**
 199:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 200:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 201:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 202:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \li to specify the access to peripheral variables.
 203:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 204:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 205:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #ifdef __cplusplus
 206:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 207:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #else
 208:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 209:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #endif
 210:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 211:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 212:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 213:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* following defines should be used for structure members */
 214:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 215:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 216:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 217:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 218:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group Cortex_M0 */
 219:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 220:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 221:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 222:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
 223:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  *                 Register Abstraction
 224:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   Core Register contain:
 225:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core Register
 226:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core NVIC Register
 227:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core SCB Register
 228:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core SysTick Register
 229:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
 230:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \defgroup CMSIS_core_register Defines and Type Definitions
 231:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief Type definitions and defines for Cortex-M processor based devices.
 232:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 233:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 234:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup    CMSIS_core_register
 235:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup   CMSIS_CORE  Status and Control Registers
 236:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief  Core Register type definitions.
 237:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 238:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 239:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 240:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Union type to access the Application Program Status Register (APSR).
 241:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 242:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 243:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 244:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   struct
 245:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 246:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 247:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 248:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 249:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 250:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 251:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 252:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 253:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } APSR_Type;
 254:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 255:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* APSR Register Definitions */
 256:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 257:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 258:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 259:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 260:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 261:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 262:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 263:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 264:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 265:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 266:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 267:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 268:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 269:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Union type to access the Interrupt Program Status Register (IPSR).
 270:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 271:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 272:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 273:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   struct
 274:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 275:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 276:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 277:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 278:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 279:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } IPSR_Type;
 280:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 281:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* IPSR Register Definitions */
 282:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 283:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 284:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 285:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 286:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 287:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 288:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 289:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 290:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   struct
 291:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 292:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 293:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 294:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 295:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 296:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 297:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 298:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 299:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 300:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 301:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 302:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } xPSR_Type;
 303:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 304:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* xPSR Register Definitions */
 305:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 306:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 307:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 308:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 309:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 310:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 311:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 312:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 313:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 314:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 315:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 316:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 317:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 318:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 319:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 320:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 321:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 322:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 323:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 324:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Union type to access the Control Registers (CONTROL).
 325:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 326:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef union
 327:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 328:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   struct
 329:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 330:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 331:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 332:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 333:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 334:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 335:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } CONTROL_Type;
 336:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 337:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* CONTROL Register Definitions */
 338:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 339:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 340:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 341:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_CORE */
 342:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 343:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 344:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup    CMSIS_core_register
 345:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 346:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Type definitions for the NVIC Registers
 347:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 348:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 349:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 350:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 351:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 352:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 353:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 354:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 355:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED0[31U];
 356:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 357:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RSERVED1[31U];
 358:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 359:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED2[31U];
 360:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 361:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED3[31U];
 362:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED4[64U];
 363:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 364:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }  NVIC_Type;
 365:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 366:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_NVIC */
 367:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 368:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 369:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup  CMSIS_core_register
 370:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_SCB     System Control Block (SCB)
 371:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Type definitions for the System Control Block Registers
 372:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 373:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 374:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 375:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Structure type to access the System Control Block (SCB).
 376:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 377:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 378:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 379:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 380:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 381:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED0;
 382:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 383:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 384:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 385:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****         uint32_t RESERVED1;
 386:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 387:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 388:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } SCB_Type;
 389:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 390:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB CPUID Register Definitions */
 391:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 392:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 393:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 394:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 395:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 396:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 397:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 398:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 399:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 400:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 401:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 402:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 403:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 404:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 405:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 406:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 407:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 408:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 409:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 410:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 411:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 412:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 413:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 414:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 415:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 416:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 417:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 418:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 419:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 420:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 421:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 422:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 423:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 424:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 425:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 426:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 427:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 428:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 429:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 430:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 431:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 432:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 433:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 434:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 435:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 436:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 437:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 438:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 439:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 440:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 441:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 442:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 443:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 444:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 445:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 446:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 447:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 448:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 449:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 450:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB System Control Register Definitions */
 451:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 452:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 453:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 454:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 455:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 456:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 457:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 458:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 459:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 460:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB Configuration Control Register Definitions */
 461:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 462:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 463:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 464:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 465:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 466:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 467:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 468:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 469:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 470:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 471:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_SCB */
 472:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 473:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 474:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup  CMSIS_core_register
 475:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 476:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Type definitions for the System Timer Registers.
 477:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 478:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 479:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 480:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Structure type to access the System Timer (SysTick).
 481:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 482:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** typedef struct
 483:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 484:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 485:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 486:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 487:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 488:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** } SysTick_Type;
 489:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 490:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Control / Status Register Definitions */
 491:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 492:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 493:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 494:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 495:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 496:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 497:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 498:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 499:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 500:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 501:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 502:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 503:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Reload Register Definitions */
 504:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 505:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 506:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 507:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Current Register Definitions */
 508:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 509:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 510:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 511:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* SysTick Calibration Register Definitions */
 512:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 513:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 514:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 515:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 516:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 517:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 518:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 519:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 520:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 521:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_SysTick */
 522:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 523:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 524:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup  CMSIS_core_register
 525:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 526:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
 527:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****                 are only accessible over DAP and not via processor. Therefore
 528:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****                 they are not covered by the Cortex-M0 header file.
 529:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 530:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 531:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 532:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 533:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 534:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup    CMSIS_core_register
 535:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup   CMSIS_core_bitfield     Core register bit field macros
 536:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 537:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 538:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 539:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 540:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /**
 541:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * Mask and shift a bit field value for use in a register bit range.
 542:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** *
 543:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \param[in] field Name of the register bit field.
 544:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \param[in] value Value of the bit field.
 545:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \return Masked and shifted value.
 546:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 547:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 548:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 549:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /**
 550:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * Mask and shift a register value to extract a bit filed value.
 551:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** *
 552:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \param[in] field Name of the register bit field.
 553:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \param[in] value Value of register.
 554:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** * \return Masked and shifted bit field value.
 555:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 556:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 557:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 558:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 559:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 560:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 561:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup    CMSIS_core_register
 562:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup   CMSIS_core_base     Core Definitions
 563:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Definitions for base addresses, unions, and structures.
 564:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   @{
 565:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 566:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 567:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* Memory mapping of Cortex-M0 Hardware */
 568:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 569:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address    
 570:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address       
 571:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 572:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 573:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 574:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 575:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 576:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 577:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 578:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*@} */
 579:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 580:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 581:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 582:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /*******************************************************************************
 583:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  *                Hardware Abstraction Layer
 584:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   Core Function Interface contains:
 585:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core NVIC Functions
 586:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core SysTick Functions
 587:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   - Core Register Access Functions
 588:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  ******************************************************************************/
 589:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 590:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** */
 591:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 592:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 593:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 594:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 595:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 596:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 597:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \brief      Functions that manage interrupts and exceptions via the NVIC.
 598:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     @{
 599:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 600:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 601:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 602:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 603:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 604:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 605:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 606:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 607:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 608:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Enable External Interrupt
 609:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 610:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function enables a device-specific interrupt in the NVIC interrupt controller.
 611:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 612:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
 613:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 614:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 615:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 616:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 617:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 618:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 619:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 620:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Disable External Interrupt
 621:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 622:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function disables a device-specific interrupt in the NVIC interrupt controller.
 623:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 624:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
 625:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 626:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
 627:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 628:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 1332              	 .loc 3 628 0
 1333 00d2 8021     	 mov r1,#128
 1334 00d4 8023     	 mov r3,#128
 1335 00d6 254A     	 ldr r2,.L112+52
 1336 00d8 8904     	 lsl r1,r1,#18
 1337 00da D150     	 str r1,[r2,r3]
 1338              	.LVL108:
 1339              	.LBE76:
 1340              	.LBE75:
 492:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[2] = PI_Speed.Ki;
 1341              	 .loc 1 492 0
 1342 00dc 244B     	 ldr r3,.L112+56
 1343 00de 2549     	 ldr r1,.L112+60
 1344 00e0 9A89     	 ldrh r2,[r3,#12]
 510:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1345              	 .loc 1 510 0
 1346 00e2 2548     	 ldr r0,.L112+64
 492:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[2] = PI_Speed.Ki;
 1347              	 .loc 1 492 0
 1348 00e4 4A60     	 str r2,[r1,#4]
 493:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[3] = PI_Speed.Scale_KpKi;
 1349              	 .loc 1 493 0
 1350 00e6 DA89     	 ldrh r2,[r3,#14]
 1351 00e8 8A60     	 str r2,[r1,#8]
 494:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1352              	 .loc 1 494 0
 1353 00ea 1022     	 mov r2,#16
 1354 00ec 9B5E     	 ldrsh r3,[r3,r2]
 1355 00ee CB60     	 str r3,[r1,#12]
 496:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[5] = PI_Torque.Ki;
 1356              	 .loc 1 496 0
 1357 00f0 224B     	 ldr r3,.L112+68
 1358 00f2 9A89     	 ldrh r2,[r3,#12]
 1359 00f4 0A61     	 str r2,[r1,#16]
 497:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[6] = PI_Torque.Scale_KpKi;
 1360              	 .loc 1 497 0
 1361 00f6 DA89     	 ldrh r2,[r3,#14]
 1362 00f8 4A61     	 str r2,[r1,#20]
 498:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1363              	 .loc 1 498 0
 1364 00fa 1022     	 mov r2,#16
 1365 00fc 9B5E     	 ldrsh r3,[r3,r2]
 1366 00fe 8B61     	 str r3,[r1,#24]
 500:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[8] = PI_Flux.Ki;
 1367              	 .loc 1 500 0
 1368 0100 1F4B     	 ldr r3,.L112+72
 1369 0102 9A89     	 ldrh r2,[r3,#12]
 1370 0104 CA61     	 str r2,[r1,#28]
 501:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[9] = PI_Flux.Scale_KpKi;
 1371              	 .loc 1 501 0
 1372 0106 DA89     	 ldrh r2,[r3,#14]
 1373 0108 0A62     	 str r2,[r1,#32]
 502:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1374              	 .loc 1 502 0
 1375 010a 1022     	 mov r2,#16
 1376 010c 9B5E     	 ldrsh r3,[r3,r2]
 1377 010e 4B62     	 str r3,[r1,#36]
 504:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[11] = PI_PLL.Ki;
 1378              	 .loc 1 504 0
 1379 0110 1C4B     	 ldr r3,.L112+76
 1380 0112 9A89     	 ldrh r2,[r3,#12]
 1381 0114 8A62     	 str r2,[r1,#40]
 505:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       User_Para[12] = PI_PLL.Scale_KpKi;
 1382              	 .loc 1 505 0
 1383 0116 DA89     	 ldrh r2,[r3,#14]
 1384 0118 CA62     	 str r2,[r1,#44]
 506:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1385              	 .loc 1 506 0
 1386 011a 1022     	 mov r2,#16
 1387 011c 9B5E     	 ldrsh r3,[r3,r2]
 1388 011e 0B63     	 str r3,[r1,#48]
 1389              	.LVL109:
 510:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1390              	 .loc 1 510 0
 1391 0120 FFF7FEFF 	 bl XMC_FLASH_ProgramVerifyPage
 1392              	.LVL110:
 1393              	.LBB77:
 1394              	.LBB78:
 1395              	.LBB79:
 1396              	.LBB80:
 1397              	 .file 4 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include/cmsis_gcc.h"
   1:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /**************************************************************************//**
   2:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @version  V4.20
   5:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @date     18. August 2015
   6:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  ******************************************************************************/
   7:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
   9:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    All rights reserved.
  10:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****      specific prior written permission.
  20:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    *
  21:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  34:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  35:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  38:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  39:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  40:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  41:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  42:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
  43:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  44:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  45:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Enable IRQ Interrupts
  46:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  47:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  48:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   Can only be executed in Privileged modes.
  49:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  50:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  51:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  52:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  53:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  54:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  55:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  56:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Disable IRQ Interrupts
  57:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  58:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
  59:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   Can only be executed in Privileged modes.
  60:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  61:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  62:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  63:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  64:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  65:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  66:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  67:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Control Register
  68:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  69:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the content of the Control Register.
  70:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  71:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               Control Register value
  72:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  73:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  74:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  75:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
  76:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  77:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  78:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
  79:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  80:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  81:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  82:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Control Register
  83:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  84:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function writes the given value to the Control Register.
  85:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  86:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    control  Control Register value to set
  87:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  88:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  89:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
  90:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  91:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
  92:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  93:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  94:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get IPSR Register
  95:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  96:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the content of the IPSR Register.
  97:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  98:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               IPSR Register value
  99:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 100:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 101:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 102:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 103:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 104:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 105:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 106:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 107:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 108:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 109:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get APSR Register
 110:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 111:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the content of the APSR Register.
 112:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 113:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               APSR Register value
 114:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 115:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 116:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 117:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 118:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 119:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 120:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 121:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 122:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 123:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 124:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get xPSR Register
 125:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 126:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the content of the xPSR Register.
 127:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 128:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               xPSR Register value
 129:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 130:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 131:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 132:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 133:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 134:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 135:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 136:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 137:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 138:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 139:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Process Stack Pointer
 140:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 141:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 142:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 143:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               PSP Register value
 144:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 145:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 146:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 147:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 148:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 149:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 150:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 151:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 152:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 153:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 154:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Process Stack Pointer
 155:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 156:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 157:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 158:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 159:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 160:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 161:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 162:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 163:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 164:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 165:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 166:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Main Stack Pointer
 167:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 168:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 169:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 170:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               MSP Register value
 171:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 172:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 173:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 174:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   register uint32_t result;
 175:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 176:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 177:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 178:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 179:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 180:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 181:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Main Stack Pointer
 182:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 183:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 184:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 185:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 186:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 187:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 188:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 189:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 190:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 191:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 192:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 193:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Priority Mask
 194:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 195:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 196:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 197:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               Priority Mask value
 198:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 199:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 201:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 202:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 203:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 205:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 206:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 207:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 208:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Priority Mask
 209:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 210:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Priority Mask Register.
 211:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 212:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    priMask  Priority Mask
 213:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 214:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 215:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 216:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 217:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 218:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 219:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 220:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 221:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 222:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Enable FIQ
 223:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 224:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 225:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Can only be executed in Privileged modes.
 226:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 227:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 228:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 229:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 230:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 231:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 232:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 233:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Disable FIQ
 234:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 235:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
 236:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Can only be executed in Privileged modes.
 237:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 238:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 239:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 240:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 241:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 242:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 243:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 244:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Base Priority
 245:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 246:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current value of the Base Priority register.
 247:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 248:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               Base Priority register value
 249:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 250:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 251:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 252:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 253:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 254:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 255:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 256:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 257:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 258:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 259:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Base Priority
 260:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 261:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Base Priority register.
 262:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 263:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    basePri  Base Priority value to set
 264:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 265:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 266:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 267:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 268:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 269:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 270:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 271:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Base Priority with condition
 272:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 273:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Base Priority register only if BASEPRI masking is 
 274:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 	or the new value increases the BASEPRI priority level.
 275:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 276:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    basePri  Base Priority value to set
 277:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 278:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 279:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 280:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 281:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 282:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 283:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 284:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get Fault Mask
 285:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 286:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current value of the Fault Mask register.
 287:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 288:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               Fault Mask register value
 289:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 290:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 291:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 292:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 293:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 294:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 295:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 296:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 297:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 298:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 299:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set Fault Mask
 300:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 301:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Fault Mask register.
 302:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 303:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    faultMask  Fault Mask value to set
 304:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 305:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 306:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 307:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 308:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 309:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 310:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 311:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 312:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 313:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 314:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 315:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Get FPSCR
 316:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 317:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function returns the current value of the Floating Point Status/Control register.
 318:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 319:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \return               Floating Point Status/Control register value
 320:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 321:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 322:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 323:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 324:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 325:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 326:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 327:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 328:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 329:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 330:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 331:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 332:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****    return(0);
 333:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 334:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 335:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 336:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 337:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Set FPSCR
 338:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 339:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 340:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 341:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 342:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 343:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 344:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 345:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 346:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 347:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 348:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** //  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");          // ARMCC_V6: needs to be 
 349:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("");
 350:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 351:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 352:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 353:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 354:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 355:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 356:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 357:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 358:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 359:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 360:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 361:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 362:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   Access to dedicated instructions
 363:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 364:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** */
 365:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 366:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 367:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 368:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Otherwise, use general registers, specified by constrant "r" */
 369:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 370:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 371:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 372:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 373:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 374:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 375:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 376:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 377:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  No Operation
 378:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 379:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 380:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 381:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 382:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 383:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("nop");
 384:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 385:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 386:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 387:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Wait For Interrupt
 388:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 389:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Wait For Interrupt is a hint instruction that suspends execution
 390:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     until one of a number of events occurs.
 391:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 392:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 393:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 394:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("wfi");
 395:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 396:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 397:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 398:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Wait For Event
 399:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 400:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Wait For Event is a hint instruction that permits the processor to enter
 401:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 402:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 403:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 404:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 405:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("wfe");
 406:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 407:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 408:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 409:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Send Event
 410:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 411:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 412:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 413:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 414:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 415:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("sev");
 416:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 417:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 418:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 419:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Instruction Synchronization Barrier
 420:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 421:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
 422:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     so that all instructions following the ISB are fetched from cache or
 423:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     memory, after the instruction has been completed.
 424:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 425:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 426:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 427:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 428:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 429:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 430:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 431:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \brief  Data Synchronization Barrier
 432:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 433:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     This function acts as a special kind of Data Memory Barrier.
 434:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****     It completes when all explicit memory accesses before this instruction complete.
 435:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 436:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 437:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 438:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 1398              	 .loc 4 438 0
 1399              	
 1400 0124 BFF34F8F 	 dsb 0xF
 1401              	
 1402              	 .code 16
 1403              	.LBE80:
 1404              	.LBE79:
 629:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 630:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 631:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 632:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Get Pending Interrupt
 633:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 634:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function reads the pending register in the NVIC and returns the pending bit
 635:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     for the specified interrupt.
 636:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 637:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  Interrupt number.
 638:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 639:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \return             0  Interrupt status is not pending.
 640:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \return             1  Interrupt status is pending.
 641:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 642:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
 643:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 644:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL
 645:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 646:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 647:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 648:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Set Pending Interrupt
 649:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 650:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function sets the pending bit of an external interrupt.
 651:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 652:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  Interrupt number. Value cannot be negative.
 653:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 654:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
 655:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 656:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 657:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 658:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 659:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 660:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Clear Pending Interrupt
 661:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 662:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function clears the pending bit of an external interrupt.
 663:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 664:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  External interrupt number. Value cannot be negative.
 665:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 666:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 667:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 668:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 669:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 670:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 671:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 672:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Set Interrupt Priority
 673:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 674:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function sets the priority of an interrupt.
 675:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 676:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \note The priority cannot be set for every core interrupt.
 677:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 678:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]      IRQn  Interrupt number.
 679:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]  priority  Priority to set.
 680:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 681:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 682:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 683:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 684:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 685:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 686:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 687:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   }
 688:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   else
 689:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 690:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 691:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 692:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   }
 693:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 694:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 695:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 696:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  Get Interrupt Priority
 697:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 698:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function reads the priority of an interrupt. The interrupt
 699:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     number can be positive to specify an external (device specific)
 700:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     interrupt, or negative to specify an internal (core) interrupt.
 701:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 702:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 703:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \param [in]   IRQn  Interrupt number.
 704:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     \return             Interrupt Priority. Value is aligned automatically to the implemented
 705:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****                         priority bits of the microcontroller.
 706:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 707:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
 708:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 709:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 710:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 711:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 712:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 713:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   }
 714:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   else
 715:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   {
 716:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 717:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   }
 718:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** }
 719:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 720:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 721:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** /** \brief  System Reset
 722:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** 
 723:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****     The function initiates a system reset request to reset the MCU.
 724:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****  */
 725:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** __STATIC_INLINE void NVIC_SystemReset(void)
 726:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h **** {
 727:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   __DSB();                                                          /* Ensure all outstanding memor
 728:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****                                                                        buffered write are completed
 729:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\core_cm0.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 1405              	 .loc 3 729 0
 1406 0128 174A     	 ldr r2,.L112+80
 1407 012a 184B     	 ldr r3,.L112+84
 1408 012c DA60     	 str r2,[r3,#12]
 1409              	.LBB81:
 1410              	.LBB82:
 1411              	 .loc 4 438 0
 1412              	
 1413 012e BFF34F8F 	 dsb 0xF
 1414              	
 1415              	 .code 16
 1416              	.L98:
 1417              	.LBE82:
 1418              	.LBE81:
 1419              	.LBB83:
 1420              	.LBB84:
 383:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 1421              	 .loc 4 383 0
 1422              	
 1423 0132 C046     	 nop
 1424              	
 1425              	 .code 16
 1426 0134 FDE7     	 b .L98
 1427              	.L113:
 1428 0136 C046     	 .align 2
 1429              	.L112:
 1430 0138 00000000 	 .word Current
 1431 013c 00000000 	 .word ADC
 1432 0140 00000000 	 .word SVM
 1433 0144 55150000 	 .word 5461
 1434 0148 00000000 	 .word Clarke_Transform
 1435 014c F3240000 	 .word 9459
 1436 0150 00000000 	 .word .LANCHOR0
 1437 0154 00000000 	 .word Update_KpKi
 1438 0158 D2040000 	 .word 1234
 1439 015c 00000000 	 .word Motor
 1440 0160 00000000 	 .word Car2Polar
 1441 0164 00000000 	 .word FOCOutput
 1442 0168 0DDBFFFF 	 .word -9459
 1443 016c 00E100E0 	 .word -536813312
 1444 0170 00000000 	 .word PI_Speed
 1445 0174 00000000 	 .word User_Para
 1446 0178 00680010 	 .word 268462080
 1447 017c 00000000 	 .word PI_Torque
 1448 0180 00000000 	 .word PI_Flux
 1449 0184 00000000 	 .word PI_PLL
 1450 0188 0400FA05 	 .word 100270084
 1451 018c 00ED00E0 	 .word -536810240
 1452              	.LBE84:
 1453              	.LBE83:
 1454              	.LBE78:
 1455              	.LBE77:
 1456              	.LBE74:
 1457              	 .cfi_endproc
 1458              	.LFE205:
 1460              	 .global __aeabi_ui2f
 1461              	 .global __aeabi_fcmpgt
 1462              	 .section .text.VF_FOC_Brake_Motor_Bootstrap_Charge,"ax",%progbits
 1463              	 .align 2
 1464              	 .global VF_FOC_Brake_Motor_Bootstrap_Charge
 1465              	 .code 16
 1466              	 .thumb_func
 1468              	VF_FOC_Brake_Motor_Bootstrap_Charge:
 1469              	.LFB206:
 562:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 563:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 564:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /*  Shift times for unity gain LPF: Y[n] = Y[n-1] + (X[n]-Y[n-1])>>SHIFT_BIAS_LPF. */
 565:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** To brake the motor, charge gate driver bootstrap capacitors (if any)
 566:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  ** Execution time: ?us (O3 - Optimize most).
 567:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	* -------------------------------------------------------------------------*/
 568:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** void VF_FOC_Brake_Motor_Bootstrap_Charge (void)
 569:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 1470              	 .loc 1 569 0
 1471              	 .cfi_startproc
 1472 0000 38B5     	 push {r3,r4,r5,lr}
 1473              	 .cfi_def_cfa_offset 16
 1474              	 .cfi_offset 3,-16
 1475              	 .cfi_offset 4,-12
 1476              	 .cfi_offset 5,-8
 1477              	 .cfi_offset 14,-4
 570:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 571:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****    // Get_ADC_SingleShuntCurrent(&ADC);
 572:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.ADC_Bias = (uint32_t) ((ADC.ADC_Bias * (((uint32_t) 1 << SHIFT_BIAS_LPF) - 1U)) + ADC.ADC_R
 573:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****                                    >> SHIFT_BIAS_LPF;
 574:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #else
 575:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Get_ADCPhaseCurrent(SVM.PreviousSectorNo, SVM.CurrentSectorNo, &ADC);
 1478              	 .loc 1 575 0
 1479 0002 1D4C     	 ldr r4,.L119
 1480 0004 1D4B     	 ldr r3,.L119+4
 1481 0006 221C     	 mov r2,r4
 1482 0008 5888     	 ldrh r0,[r3,#2]
 1483 000a 1988     	 ldrh r1,[r3]
 1484 000c FFF7FEFF 	 bl Get_ADCPhaseCurrent
 1485              	.LVL111:
 576:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 577:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iu = (ADC.ADC_Bias_Iu * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iu)>>SHIFT_BIAS_LPF;		// R
 1486              	 .loc 1 577 0
 1487 0010 A168     	 ldr r1,[r4,#8]
 1488 0012 2088     	 ldrh r0,[r4]
 1489 0014 CA00     	 lsl r2,r1,#3
 1490 0016 531A     	 sub r3,r2,r1
 578:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iv = (ADC.ADC_Bias_Iv * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iv)>>SHIFT_BIAS_LPF;		// R
 1491              	 .loc 1 578 0
 1492 0018 E168     	 ldr r1,[r4,#12]
 577:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iv = (ADC.ADC_Bias_Iv * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iv)>>SHIFT_BIAS_LPF;		// R
 1493              	 .loc 1 577 0
 1494 001a C318     	 add r3,r0,r3
 1495              	 .loc 1 578 0
 1496 001c CA00     	 lsl r2,r1,#3
 1497 001e 6088     	 ldrh r0,[r4,#2]
 577:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iv = (ADC.ADC_Bias_Iv * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iv)>>SHIFT_BIAS_LPF;		// R
 1498              	 .loc 1 577 0
 1499 0020 DB08     	 lsr r3,r3,#3
 1500 0022 A360     	 str r3,[r4,#8]
 1501              	 .loc 1 578 0
 1502 0024 531A     	 sub r3,r2,r1
 579:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iw = (ADC.ADC_Bias_Iw * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iw)>>SHIFT_BIAS_LPF;		// R
 1503              	 .loc 1 579 0
 1504 0026 2169     	 ldr r1,[r4,#16]
 578:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iv = (ADC.ADC_Bias_Iv * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iv)>>SHIFT_BIAS_LPF;		// R
 1505              	 .loc 1 578 0
 1506 0028 C318     	 add r3,r0,r3
 1507 002a DB08     	 lsr r3,r3,#3
 1508              	 .loc 1 579 0
 1509 002c A088     	 ldrh r0,[r4,#4]
 1510 002e CA00     	 lsl r2,r1,#3
 578:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iv = (ADC.ADC_Bias_Iv * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iv)>>SHIFT_BIAS_LPF;		// R
 1511              	 .loc 1 578 0
 1512 0030 E360     	 str r3,[r4,#12]
 1513              	 .loc 1 579 0
 1514 0032 531A     	 sub r3,r2,r1
 1515 0034 C318     	 add r3,r0,r3
 580:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #endif
 581:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 582:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #define IV_ADC_BIAS   (2045)
 583:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     #define IW_ADC_BIAS   (2048)
 584:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 585:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* If system is idle, i.e.: PWM duty cycle or POT ADC too low.*/
 586:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	  Motor.Counter ++;
 1516              	 .loc 1 586 0
 1517 0036 124D     	 ldr r5,.L119+8
 579:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		ADC.ADC_Bias_Iw = (ADC.ADC_Bias_Iw * ((1<<SHIFT_BIAS_LPF)-1) + ADC.ADC_Iw)>>SHIFT_BIAS_LPF;		// R
 1518              	 .loc 1 579 0
 1519 0038 DB08     	 lsr r3,r3,#3
 1520 003a 2361     	 str r3,[r4,#16]
 1521              	 .loc 1 586 0
 1522 003c EB6B     	 ldr r3,[r5,#60]
 1523 003e 581C     	 add r0,r3,#1
 587:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	if (SYSTEM_BE_IDLE)
 1524              	 .loc 1 587 0
 1525 0040 236A     	 ldr r3,[r4,#32]
 586:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	if (SYSTEM_BE_IDLE)
 1526              	 .loc 1 586 0
 1527 0042 E863     	 str r0,[r5,#60]
 1528              	 .loc 1 587 0
 1529 0044 312B     	 cmp r3,#49
 1530 0046 02DC     	 bgt .L115
 588:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	{
 589:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	  /* cannot go to ramp up, keep motor braking.*/
 590:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Motor.Counter = 0;
 1531              	 .loc 1 590 0
 1532 0048 0023     	 mov r3,#0
 1533 004a EB63     	 str r3,[r5,#60]
 1534              	.L114:
 591:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	}
 592:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 593:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 594:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 595:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	if (Motor.Counter > BRAKE_TIME)
 596:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	{
 597:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	  /* Timer decides when to stop motor braking.*/
 598:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Motor.State = VFOPENLOOP_RAMP_UP;
 599:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Next, go to V/f ramp-up.*/
 600:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Motor.Mode_Flag = MOTOR_TRANSITION;
 601:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Motor in transition mode.*/
 602:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Motor.Counter = 0;
 603:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Clear counters.*/
 604:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Motor.Ramp_Counter = 0;
 605:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		if (Motor.State == VFOPENLOOP_RAMP_UP)
 606:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		{
 607:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		  /* In V/f, much slower initial ramp up for S-curve profile.*/
 608:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			Motor.Ramp_Up_Rate = (RAMPUP_RATE * 40);
 609:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		}
 610:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_U = 0;
 611:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_V = 0;
 612:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_W = 0;
 613:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 614:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.ADC3Trig_Point = 0;
 615:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.ADC4Trig_Point = 0;
 616:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.ADC_Result1 = 0;
 617:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.ADC_Result2 = 0;
 618:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADC.Result_Flag = RESULTS_ADCTZ12;
 619:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     ADCTZ12_TriggerSetting ();              /* Set ADC trigger for ADCTz1/Tz2, for single-shunt cur
 620:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #endif
 621:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	}
 622:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 623:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 624:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 1535              	 .loc 1 624 0
 1536              	 
 1537 004c 38BD     	 pop {r3,r4,r5,pc}
 1538              	.L115:
 595:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	{
 1539              	 .loc 1 595 0
 1540 004e FFF7FEFF 	 bl __aeabi_ui2f
 1541              	.LVL112:
 1542 0052 0C49     	 ldr r1,.L119+12
 1543 0054 FFF7FEFF 	 bl __aeabi_fcmpgt
 1544              	.LVL113:
 1545 0058 0028     	 cmp r0,#0
 1546 005a F7D0     	 beq .L114
 598:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Next, go to V/f ramp-up.*/
 1547              	 .loc 1 598 0
 1548 005c 0423     	 mov r3,#4
 608:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		}
 1549              	 .loc 1 608 0
 1550 005e A022     	 mov r2,#160
 598:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Next, go to V/f ramp-up.*/
 1551              	 .loc 1 598 0
 1552 0060 EB62     	 str r3,[r5,#44]
 600:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Motor in transition mode.*/
 1553              	 .loc 1 600 0
 1554 0062 0023     	 mov r3,#0
 608:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		}
 1555              	 .loc 1 608 0
 1556 0064 5200     	 lsl r2,r2,#1
 1557 0066 6A62     	 str r2,[r5,#36]
 610:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_V = 0;
 1558              	 .loc 1 610 0
 1559 0068 074A     	 ldr r2,.L119+16
 600:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Motor in transition mode.*/
 1560              	 .loc 1 600 0
 1561 006a 6B86     	 strh r3,[r5,#50]
 602:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		/* Clear counters.*/
 1562              	 .loc 1 602 0
 1563 006c EB63     	 str r3,[r5,#60]
 604:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		if (Motor.State == VFOPENLOOP_RAMP_UP)
 1564              	 .loc 1 604 0
 1565 006e 2B64     	 str r3,[r5,#64]
 610:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_V = 0;
 1566              	 .loc 1 610 0
 1567 0070 1360     	 str r3,[r2]
 611:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		Current.I_W = 0;
 1568              	 .loc 1 611 0
 1569 0072 5360     	 str r3,[r2,#4]
 612:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #if(CURRENT_SENSING == USER_SINGLE_SHUNT_CONV)
 1570              	 .loc 1 612 0
 1571 0074 9360     	 str r3,[r2,#8]
 1572 0076 E9E7     	 b .L114
 1573              	.L120:
 1574              	 .align 2
 1575              	.L119:
 1576 0078 00000000 	 .word ADC
 1577 007c 00000000 	 .word SVM
 1578 0080 00000000 	 .word Motor
 1579 0084 00009643 	 .word 1133903872
 1580 0088 00000000 	 .word Current
 1581              	 .cfi_endproc
 1582              	.LFE206:
 1584              	 .section .ram_code,"ax",%progbits
 1585              	 .align 2
 1586              	 .global Linear_Ramp_Generator
 1587              	 .code 16
 1588              	 .thumb_func
 1590              	Linear_Ramp_Generator:
 1591              	.LFB207:
 625:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 626:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** RAM_ATTRIBUTE void Linear_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rat
 627:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****                                          int32_t speedrampstep, int32_t *reference_val)
 628:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 1592              	 .loc 1 628 0
 1593              	 .cfi_startproc
 1594              	.LVL114:
 1595 0000 30B5     	 push {r4,r5,lr}
 1596              	 .cfi_def_cfa_offset 12
 1597              	 .cfi_offset 4,-12
 1598              	 .cfi_offset 5,-8
 1599              	 .cfi_offset 14,-4
 1600              	 .loc 1 628 0
 1601 0002 039C     	 ldr r4,[sp,#12]
 629:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   if (*reference_val != set_val)
 1602              	 .loc 1 629 0
 1603 0004 2568     	 ldr r5,[r4]
 1604 0006 8542     	 cmp r5,r0
 1605 0008 1ED0     	 beq .L122
 630:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 631:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* in FOC, ωref not reach the target speed.*/
 632:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (*reference_val < set_val)
 1606              	 .loc 1 632 0
 1607 000a 11DA     	 bge .L123
 633:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 634:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Speed ramp counter ++.*/
 635:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter ++;
 1608              	 .loc 1 635 0
 1609 000c 1448     	 ldr r0,.L128
 1610              	.LVL115:
 1611 000e 026C     	 ldr r2,[r0,#64]
 1612              	.LVL116:
 636:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 1613              	 .loc 1 636 0
 1614 0010 456A     	 ldr r5,[r0,#36]
 635:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 1615              	 .loc 1 635 0
 1616 0012 0132     	 add r2,r2,#1
 1617 0014 0264     	 str r2,[r0,#64]
 1618              	 .loc 1 636 0
 1619 0016 AA42     	 cmp r2,r5
 1620 0018 09D9     	 bls .L121
 637:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 638:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Ramp up slowly (if needed) at start of FOC.*/
 639:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Up_Rate > rampup_rate)
 1621              	 .loc 1 639 0
 1622 001a 8D42     	 cmp r5,r1
 1623 001c 01DD     	 ble .L126
 640:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 641:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Increase acceleration step by step.*/
 642:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Up_Rate --;
 1624              	 .loc 1 642 0
 1625 001e 013D     	 sub r5,r5,#1
 1626 0020 4562     	 str r5,[r0,#36]
 1627              	.L126:
 643:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 644:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 645:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /*  ωref ++.*/
 646:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         *reference_val += speedrampstep;
 1628              	 .loc 1 646 0
 1629 0022 2268     	 ldr r2,[r4]
 1630 0024 9446     	 mov ip,r2
 1631 0026 6344     	 add r3,r3,ip
 1632              	.LVL117:
 1633 0028 2360     	 str r3,[r4]
 647:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Clear ramp counter. */
 648:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 1634              	 .loc 1 648 0
 1635 002a 0023     	 mov r3,#0
 1636 002c 0364     	 str r3,[r0,#64]
 1637              	.LVL118:
 1638              	.L121:
 649:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 650:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 651:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     else
 652:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 653:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Speed ramp counter ++.*/
 654:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter ++;
 655:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Ramp_Counter > rampdown_rate)
 656:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 657:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* ωref --.*/
 658:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         *reference_val -= speedrampstep;
 659:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 660:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 661:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 662:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   }
 663:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   else
 664:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 665:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* ωref reach the target speed */
 666:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Update counter */
 667:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Counter ++;
 668:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /*15, 150 or 1500. Time that FOC becomes stable, x PWM period.*/
 669:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Counter > 2U)
 670:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 671:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Change flag: in FOC stable mode. */
 672:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Mode_Flag = MOTOR_STABLE;
 673:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Counter = 0;
 674:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Clear counter */
 675:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter = 0;
 676:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 677:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   }
 678:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 1639              	 .loc 1 678 0
 1640              	 
 1641 002e 30BD     	 pop {r4,r5,pc}
 1642              	.LVL119:
 1643              	.L123:
 654:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if (Motor.Ramp_Counter > rampdown_rate)
 1644              	 .loc 1 654 0
 1645 0030 0B48     	 ldr r0,.L128
 1646              	.LVL120:
 1647 0032 016C     	 ldr r1,[r0,#64]
 1648              	.LVL121:
 1649 0034 0131     	 add r1,r1,#1
 1650 0036 0164     	 str r1,[r0,#64]
 655:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 1651              	 .loc 1 655 0
 1652 0038 9142     	 cmp r1,r2
 1653 003a F8D9     	 bls .L121
 658:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 1654              	 .loc 1 658 0
 1655 003c 2268     	 ldr r2,[r4]
 1656              	.LVL122:
 1657 003e D31A     	 sub r3,r2,r3
 1658              	.LVL123:
 1659 0040 2360     	 str r3,[r4]
 659:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 1660              	 .loc 1 659 0
 1661 0042 0023     	 mov r3,#0
 1662 0044 0364     	 str r3,[r0,#64]
 1663 0046 F2E7     	 b .L121
 1664              	.LVL124:
 1665              	.L122:
 667:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /*15, 150 or 1500. Time that FOC becomes stable, x PWM period.*/
 1666              	 .loc 1 667 0
 1667 0048 054A     	 ldr r2,.L128
 1668              	.LVL125:
 1669 004a D36B     	 ldr r3,[r2,#60]
 1670              	.LVL126:
 1671 004c 0133     	 add r3,r3,#1
 1672 004e D363     	 str r3,[r2,#60]
 669:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 1673              	 .loc 1 669 0
 1674 0050 022B     	 cmp r3,#2
 1675 0052 ECD9     	 bls .L121
 672:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Counter = 0;
 1676              	 .loc 1 672 0
 1677 0054 AB23     	 mov r3,#171
 1678 0056 5386     	 strh r3,[r2,#50]
 673:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Clear counter */
 1679              	 .loc 1 673 0
 1680 0058 0023     	 mov r3,#0
 1681 005a D363     	 str r3,[r2,#60]
 675:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 1682              	 .loc 1 675 0
 1683 005c 1364     	 str r3,[r2,#64]
 1684 005e E6E7     	 b .L121
 1685              	.L129:
 1686              	 .align 2
 1687              	.L128:
 1688 0060 00000000 	 .word Motor
 1689              	 .cfi_endproc
 1690              	.LFE207:
 1692              	 .align 2
 1693              	 .global SCurve_Ramp_Generator
 1694              	 .code 16
 1695              	 .thumb_func
 1697              	SCurve_Ramp_Generator:
 1698              	.LFB208:
 679:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 680:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /*  To use S-curve profile in motor ramp up / down. Comment out to use trapezoidal profile. */
 681:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define S_CURVE_PROFILE   1
 682:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Speed threshold for entering second S-curve of ramp up / down. */
 683:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define SPEED_TH_2ND_S    (SPEED_LOW_LIMIT >> 0U)
 684:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 685:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** RAM_ATTRIBUTE void SCurve_Ramp_Generator(int32_t set_val, int32_t rampup_rate, int32_t rampdown_rat
 686:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****                                          int32_t speedrampstep, int32_t *reference_val)
 687:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 1699              	 .loc 1 687 0
 1700              	 .cfi_startproc
 1701              	.LVL127:
 1702 0064 F0B5     	 push {r4,r5,r6,r7,lr}
 1703              	 .cfi_def_cfa_offset 20
 1704              	 .cfi_offset 4,-20
 1705              	 .cfi_offset 5,-16
 1706              	 .cfi_offset 6,-12
 1707              	 .cfi_offset 7,-8
 1708              	 .cfi_offset 14,-4
 1709              	 .loc 1 687 0
 1710 0066 059D     	 ldr r5,[sp,#20]
 688:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   if (*reference_val == set_val)
 1711              	 .loc 1 688 0
 1712 0068 2C68     	 ldr r4,[r5]
 1713 006a 8442     	 cmp r4,r0
 1714 006c 3FD0     	 beq .L141
 689:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 690:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* For most of the time, motor ref speed = speed set by POT ADC or PWM. */
 691:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Counter = 0;
 692:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;
 693:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 694:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Reset to slower ramp up and ramp down for S-curve profile. */
 695:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Dn_Rate = rampdown_rate << (RATIO_S - 1);
 696:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   }
 697:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   else if (*reference_val < set_val)
 1715              	 .loc 1 697 0
 1716 006e 17DA     	 bge .L133
 698:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 699:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Motor ref speed lower than speed set by POT or PWM. */
 700:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Speed ramp counter ++. */
 701:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Counter++;
 1717              	 .loc 1 701 0
 1718 0070 224C     	 ldr r4,.L144
 1719 0072 226C     	 ldr r2,[r4,#64]
 1720              	.LVL128:
 702:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 1721              	 .loc 1 702 0
 1722 0074 666A     	 ldr r6,[r4,#36]
 701:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Ramp_Counter > Motor.Ramp_Up_Rate)
 1723              	 .loc 1 701 0
 1724 0076 0132     	 add r2,r2,#1
 1725 0078 2264     	 str r2,[r4,#64]
 1726              	 .loc 1 702 0
 1727 007a B242     	 cmp r2,r6
 1728 007c 0FD9     	 bls .L130
 703:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 704:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if ((set_val - *reference_val) > SPEED_TH_2ND_S)
 1729              	 .loc 1 704 0
 1730 007e 9127     	 mov r7,#145
 1731 0080 2A68     	 ldr r2,[r5]
 1732 0082 BF00     	 lsl r7,r7,#2
 1733 0084 801A     	 sub r0,r0,r2
 1734              	.LVL129:
 1735 0086 B842     	 cmp r0,r7
 1736 0088 26D8     	 bhi .L142
 705:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 706:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* First S-curve of ramp up, and constant acceleration. */
 707:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Up_Rate > rampup_rate)
 708:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 709:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Increase acceleration step by step. */
 710:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Up_Rate--;
 711:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 712:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 713:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 714:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 715:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Second S-curve of ramp up. */
 716:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Up_Rate < (rampup_rate << RATIO_S))
 1737              	 .loc 1 716 0
 1738 008a 4900     	 lsl r1,r1,#1
 1739              	.LVL130:
 1740 008c 8E42     	 cmp r6,r1
 1741 008e 02DA     	 bge .L136
 717:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 718:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Up_Rate++;
 1742              	 .loc 1 718 0
 1743 0090 0136     	 add r6,r6,#1
 1744 0092 6662     	 str r6,[r4,#36]
 1745 0094 2A68     	 ldr r2,[r5]
 1746              	.L136:
 719:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 720:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 721:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       /* Motor ref speed ++. */
 722:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       *reference_val += speedrampstep;
 1747              	 .loc 1 722 0
 1748 0096 9B18     	 add r3,r3,r2
 1749              	.LVL131:
 1750 0098 2B60     	 str r3,[r5]
 723:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       Motor.Ramp_Counter = 0;
 1751              	 .loc 1 723 0
 1752 009a 0023     	 mov r3,#0
 1753 009c 2364     	 str r3,[r4,#64]
 1754              	.L130:
 724:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 725:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   }
 726:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   else
 727:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   {
 728:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Motor ref speed higher than speed set by POT or PWM. */
 729:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     /* Speed ramp counter ++. */
 730:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Counter++;
 731:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
 732:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 733:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       if ((*reference_val - set_val) > SPEED_TH_2ND_S)
 734:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 735:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* First S-curve of ramp down, and constant deceleration. */
 736:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Dn_Rate > rampdown_rate)
 737:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 738:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Increase deceleration step by step. */
 739:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Dn_Rate--;
 740:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 741:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 742:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       else
 743:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 744:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Second S-curve of ramp down. */
 745:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (Motor.Ramp_Dn_Rate < (rampdown_rate << (RATIO_S - 1)))
 746:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 747:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           Motor.Ramp_Dn_Rate++;
 748:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 749:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 750:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 751:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         if (ADC.ADC_DCLink < VDC_MAX_LIMIT)
 752:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 753:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* If DC link voltage Vdc is too high, stop ramp-down motor.*/
 754:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           /* Motor ref speed --.*/
 755:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****           *reference_val -= speedrampstep;
 756:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 757:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Ramp_Counter = 0;
 758:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 759:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 760:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     }
 761:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 762:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****  }
 1755              	 .loc 1 762 0
 1756              	 
 1757 009e F0BD     	 pop {r4,r5,r6,r7,pc}
 1758              	.LVL132:
 1759              	.L133:
 730:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
 1760              	 .loc 1 730 0
 1761 00a0 164C     	 ldr r4,.L144
 1762 00a2 216C     	 ldr r1,[r4,#64]
 1763              	.LVL133:
 731:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 1764              	 .loc 1 731 0
 1765 00a4 A66A     	 ldr r6,[r4,#40]
 730:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     if (Motor.Ramp_Counter > Motor.Ramp_Dn_Rate)
 1766              	 .loc 1 730 0
 1767 00a6 0131     	 add r1,r1,#1
 1768 00a8 2164     	 str r1,[r4,#64]
 731:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     {
 1769              	 .loc 1 731 0
 1770 00aa B142     	 cmp r1,r6
 1771 00ac F7D9     	 bls .L130
 733:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       {
 1772              	 .loc 1 733 0
 1773 00ae 2968     	 ldr r1,[r5]
 1774 00b0 081A     	 sub r0,r1,r0
 1775              	.LVL134:
 1776 00b2 9121     	 mov r1,#145
 1777 00b4 8900     	 lsl r1,r1,#2
 1778 00b6 8842     	 cmp r0,r1
 1779 00b8 14D8     	 bhi .L143
 745:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1780              	 .loc 1 745 0
 1781 00ba B242     	 cmp r2,r6
 1782 00bc 01DD     	 ble .L139
 747:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 1783              	 .loc 1 747 0
 1784 00be 0136     	 add r6,r6,#1
 1785 00c0 A662     	 str r6,[r4,#40]
 1786              	.L139:
 751:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1787              	 .loc 1 751 0
 1788 00c2 0F4A     	 ldr r2,.L144+4
 1789              	.LVL135:
 1790 00c4 516A     	 ldr r1,[r2,#36]
 1791 00c6 0F4A     	 ldr r2,.L144+8
 1792 00c8 9142     	 cmp r1,r2
 1793 00ca 02DC     	 bgt .L140
 755:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 1794              	 .loc 1 755 0
 1795 00cc 2A68     	 ldr r2,[r5]
 1796 00ce D31A     	 sub r3,r2,r3
 1797              	.LVL136:
 1798 00d0 2B60     	 str r3,[r5]
 1799              	.L140:
 757:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       }
 1800              	 .loc 1 757 0
 1801 00d2 0023     	 mov r3,#0
 1802 00d4 2364     	 str r3,[r4,#64]
 1803 00d6 E2E7     	 b .L130
 1804              	.LVL137:
 1805              	.L142:
 707:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1806              	 .loc 1 707 0
 1807 00d8 B142     	 cmp r1,r6
 1808 00da DCDA     	 bge .L136
 710:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 1809              	 .loc 1 710 0
 1810 00dc 013E     	 sub r6,r6,#1
 1811 00de 6662     	 str r6,[r4,#36]
 1812 00e0 2A68     	 ldr r2,[r5]
 1813 00e2 D8E7     	 b .L136
 1814              	.LVL138:
 1815              	.L143:
 736:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         {
 1816              	 .loc 1 736 0
 1817 00e4 B242     	 cmp r2,r6
 1818 00e6 ECDA     	 bge .L139
 739:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         }
 1819              	 .loc 1 739 0
 1820 00e8 013E     	 sub r6,r6,#1
 1821 00ea A662     	 str r6,[r4,#40]
 1822 00ec E9E7     	 b .L139
 1823              	.LVL139:
 1824              	.L141:
 691:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;
 1825              	 .loc 1 691 0
 1826 00ee 0020     	 mov r0,#0
 1827              	.LVL140:
 1828 00f0 024B     	 ldr r3,.L144
 1829              	.LVL141:
 692:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1830              	 .loc 1 692 0
 1831 00f2 4900     	 lsl r1,r1,#1
 1832              	.LVL142:
 691:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****     Motor.Ramp_Up_Rate = rampup_rate << RATIO_S;
 1833              	 .loc 1 691 0
 1834 00f4 1864     	 str r0,[r3,#64]
 692:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1835              	 .loc 1 692 0
 1836 00f6 5962     	 str r1,[r3,#36]
 695:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   }
 1837              	 .loc 1 695 0
 1838 00f8 9A62     	 str r2,[r3,#40]
 1839 00fa D0E7     	 b .L130
 1840              	.L145:
 1841              	 .align 2
 1842              	.L144:
 1843 00fc 00000000 	 .word Motor
 1844 0100 00000000 	 .word ADC
 1845 0104 5B0D0000 	 .word 3419
 1846              	 .cfi_endproc
 1847              	.LFE208:
 1849              	 .align 2
 1850              	 .global Misc_Works_of_IRQ
 1851              	 .code 16
 1852              	 .thumb_func
 1854              	Misc_Works_of_IRQ:
 1855              	.LFB209:
 763:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 764:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 765:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 766:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* Non-Real-Time Tasks Configuration */
 767:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /* 2 ~ 100, x CCU8 PWM period. For tasks that don't need real-time computing.*/
 768:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define NON_REALTIME_RATE 64
 769:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** #define POTADC_LPF    (5U)          // (5U). ADC uses LPF.
 770:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** /** Miscellaneous works in CCU80_0_IRQHandler, such as tasks that don't need real-time computing
 771:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	* ------------------------------------------------------------------------------------------------
 772:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** RAM_ATTRIBUTE void Misc_Works_of_IRQ (void)
 773:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** {
 1856              	 .loc 1 773 0
 1857              	 .cfi_startproc
 1858 0108 08B5     	 push {r3,lr}
 1859              	 .cfi_def_cfa_offset 8
 1860              	 .cfi_offset 3,-8
 1861              	 .cfi_offset 14,-4
 774:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   /* Handle tasks that don't need real-time computing:*/
 775:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   #if(UART_ENABLE == USIC_DISABLED_ALL)
 776:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       uint16_t pot_adc_result;
 777:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   #endif
 778:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****   /* Counter ++. */
 779:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	Motor.Non_RealTime_Counter ++;
 1862              	 .loc 1 779 0
 1863 010a 144B     	 ldr r3,.L156
 1864 010c 9A6C     	 ldr r2,[r3,#72]
 1865 010e 0132     	 add r2,r2,#1
 780:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	if (Motor.Non_RealTime_Counter > NON_REALTIME_RATE)
 1866              	 .loc 1 780 0
 1867 0110 402A     	 cmp r2,#64
 1868 0112 21D9     	 bls .L153
 781:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	{
 782:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	    /* Reset counter.*/
 783:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 		  Motor.Non_RealTime_Counter = 0;
 1869              	 .loc 1 783 0
 1870 0114 0022     	 mov r2,#0
 1871 0116 9A64     	 str r2,[r3,#72]
 784:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 785:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #if((MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_VF_MET_FOC) || (MY_FOC_CONTROL_SCHEME == CONSTAN
 786:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* POT ADC values 0 ~ 2^12 represent motor target speed of SPEED_LOW_LIMIT ~ SPEED_HIGH_LIM
 787:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = SPEED_LOW_LIMIT + (((SPEED_HIGH_LIMIT - SPEED_LOW_LIMIT) * ADC.ADC
 788:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Limit speed, in case ADC values not 0 ~ 2^12.*/
 789:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, SPEED_HIGH_LIMIT, SPEED_LOW_
 790:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
 791:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* POT ADC values 0 ~ 2^12 represent motor target speed of SPEED_LOW_LIMIT ~ SPEED_HIGH_LIM
 792:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 793:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 794:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = USER_IQ_REF_LOW_LIMIT + (((USER_IQ_REF_HIGH_LIMIT - USER_IQ_REF_LO
 1872              	 .loc 1 794 0
 1873 0118 114A     	 ldr r2,.L156+4
 1874 011a 1249     	 ldr r1,.L156+8
 1875 011c 126A     	 ldr r2,[r2,#32]
 1876              	.LBB85:
 1877              	.LBB86:
 1878              	 .file 5 "../PMSM_FOC/ControlModules/pmsm_foc_pi.h"
   1:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**
   2:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @file pmsm_foc_pi.h
   3:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @date 2015-12-23
   4:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
   5:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @cond
   6:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
   7:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * PMSM FOC Motor Control Library
   8:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
   9:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * All rights reserved.
  11:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  12:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * following conditions are met:
  14:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  15:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  16:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   disclaimer.
  17:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  18:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  19:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  20:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  21:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  22:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *   products derived from this software without specific prior written permission.
  23:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  24:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  32:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * with Infineon Technologies AG (dave@infineon.com).
  34:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
  35:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
  36:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  37:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @file pmsm_foc_pi.h
  38:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @date 23 Dec, 2015
  39:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @version 1.0.0
  40:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  41:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @brief ACMP low level driver API prototype definition for XMC1 <br>
  42:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  43:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * <b>Detailed description of file</b> <br>
  44:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * APIs provided in this file mainly cover the following functionality:
  45:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * ---- Filter, Hysterisis, Output inversion
  46:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  47:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * History
  48:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  49:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * 23 Dec 2015 Version 1.0.0 <br>:
  50:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *      Initial version
  51:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @endcond
  52:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
  53:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  */
  54:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  55:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #ifndef PMSM_FOC_CONTROLMODULES_PMSM_FOC_PI_H_
  56:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PMSM_FOC_CONTROLMODULES_PMSM_FOC_PI_H_
  57:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  58:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**************************************************************************************************
  59:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * HEADER FILES
  60:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
  61:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #include <XMC1300.h>          /* SFR declarations of the selected device */
  62:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #include "../Configuration/pmsm_foc_uCProbe_parameters.h"
  63:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #include "../Configuration/pmsm_foc_user_parameter.h"
  64:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  65:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**************************************************************************************************
  66:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * MACROS
  67:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
  68:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  69:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*%%%%%%%% Update / Modify PI Parameters Here %%%%%%%%*/
  70:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  71:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****               /* For DJI Drone (black). */
  72:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Speed PI controller ######################*/
  73:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #if(MOTOR_TYPE == DJI_DRONE_MOTOR)
  74:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KP            ((uint16_t)1U<<15U)          /* (1<<15). Proportional g
  75:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KI            ((uint16_t)2)                /* (1<<3). Integral gain K
  76:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_SCALE_KPKI    (10 + RES_INC)               /* RES_INC: Angle/speed re
  77:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  78:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t.
  79:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<14) * 3) >> 2))      /* (-(1<<15)). I[k] output limi
  80:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MAX  (((1<<14) * 3) >> 2)         /* (1<<15). I[k] output limit H
  81:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  82:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MIN  (16)            /* (-32767), 16. U[k] output limit LOW. */
  83:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normal
  84:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  85:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Torque / Iq PI controller ######################*/
  86:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
  87:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)              /* (1<<13). Proportion
  88:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 0)       /* (1<<6). Integral gain
  89:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
  90:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  91:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Norma
  92:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normall
  93:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  94:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need 
  95:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need
  96:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
  97:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Flux / Id PI controller ######################*/
  98:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
  99:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)              /* (1<<13). Proportion
 100:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 0)       /* (1<<6). Integral gain
 101:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 102:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 103:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normall
 104:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally 
 105:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 106:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need ch
 107:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need c
 108:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 109:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For PLL rotor speed PI controller ######################*/
 110:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KP         ((uint16_t)1<<5)              /* Proportional gain Kp, uint1
 111:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KI         ((uint16_t)1<<4)              /* (1<<4). Integral gain Ki, u
 112:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_SCALE_KPKI     (18 - RES_INC)
 113:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 114:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* I[k] output limit LOW. */
 115:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_
 116:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I
 117:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 118:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] out
 119:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] out
 120:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 121:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 122:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif(MOTOR_TYPE == MCI_DRONE_MOTOR)
 123:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*      --------------------------------------------------- User Fine Tune Motor Speed PI and Estim
 124:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 125:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KP            ((uint16_t)1U<<1U)          /* (1<<15). Proportional ga
 126:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KI            ((uint16_t)1U<<1U)                /* (1<<3). Integral g
 127:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_SCALE_KPKI    (16 + RES_INC)               /* RES_INC: Angle/speed re
 128:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 129:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t.
 130:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<14) * 3) >> 2))      /* (-(1<<15)). I[k] output limi
 131:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MAX  (((1<<14) * 3) >> 2)         /* (1<<15). I[k] output limit H
 132:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 133:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MIN  (16>>1)            /* (-32767), 16. U[k] output limit LOW. *
 134:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normal
 135:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 136:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Torque / Iq PI controller ######################*/
 137:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
 138:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP >> 0)             /* (1<<13). Propor
 139:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 4)        /* (1<<6). Integral gai
 140:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 2)
 141:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 142:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Norma
 143:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normall
 144:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 145:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need 
 146:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need
 147:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 148:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Flux / Id PI controller ######################*/
 149:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
 150:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP >> 0)             /* (1<<13). Propor
 151:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 4)        /* (1<<6). Integral gai
 152:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 2)
 153:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 154:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normall
 155:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally 
 156:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 157:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need ch
 158:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need c
 159:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 160:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For PLL rotor speed PI controller ######################*/
 161:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KP             ((uint16_t)1 << 5)              /* Proportional gain Kp,
 162:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KI             ((uint16_t)1 << 4)              /* (1<<4). Integral gain
 163:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_SCALE_KPKI     (18 - RES_INC)
 164:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 165:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* I[k] output limit LOW. */
 166:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_
 167:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I
 168:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 169:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #if(MY_FOC_CONTROL_SCHEME == CONSTANT_TORQUE_DIRECT_FOC)
 170:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 171:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)200 )                /* U[k] output limit LOW. *
 172:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT )            /* U[k] ou
 173:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif((MY_FOC_CONTROL_SCHEME == CONSTANT_SPEED_VF_MET_FOC) || (MY_FOC_CONTROL_SCHEME == CONSTANT_SP
 174:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] out
 175:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] out
 176:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_VQ_DIRECT_FOC)
 177:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)200)                /* U[k] output limit LOW. */
 178:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT )            /* U[k] ou
 179:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #endif
 180:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 181:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 182:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == VORNADO_FAN_MOTOR)
 183:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KP            ((uint16_t)1U << 15U)          /* (1<<15). Proportional
 184:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_KI            ((uint16_t)3U)                /* (1<<3). Integral gain 
 185:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_SPEED_SCALE_KPKI    (10 + RES_INC)               /* RES_INC: Angle/speed re
 186:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 187:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t.
 188:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         //        #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<14) * 3) >> 2))      /* (-(1<<15)). I[k] o
 189:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         //        #define PI_SPEED_IK_LIMIT_MAX  (((1<<14) * 3) >> 2)         /* (1<<15). I[k] outp
 190:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MIN  (-32768)      /* (-(1<<15)). I[k] output limit LOW. */
 191:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_IK_LIMIT_MAX  (32768)         /* (1<<15). I[k] output limit HIGH. */
 192:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 193:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MIN  (16)            /* (-32767), 16. U[k] output limit LOW. */
 194:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normal
 195:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 196:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Torque / Iq PI controller ######################*/
 197:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
 198:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportiona
 199:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integral gai
 200:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
 201:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 202:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Norma
 203:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normall
 204:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 205:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need 
 206:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need
 207:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 208:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Flux / Id PI controller ######################*/
 209:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need ch
 210:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportiona
 211:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integral gai
 212:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 213:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 214:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normall
 215:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally 
 216:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 217:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need ch
 218:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need c
 219:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 220:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For PLL rotor speed PI controller ######################*/
 221:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KP             ((uint16_t)1<<8)              /* Proportional gain Kp, u
 222:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_KI             ((uint16_t)1<<6)              /* (1<<4). Integral gain K
 223:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define USER_PI_PLL_SCALE_KPKI     (20 - RES_INC)
 224:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 225:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* I[k] output limit LOW. */
 226:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_
 227:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I
 228:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 229:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] out
 230:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         #define PI_PLL_UK_LIMIT_MAX     ((SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT) << 1)            /* U
 231:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 232:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 233:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == NANOTEC_MOTOR)
 234:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* For Low Voltage 15W Board with Nanotec Motor */
 235:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /*################### For Speed PI controller ######################*/
 236:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_SPEED_KP            ((uint16_t)1U<<15U)          /* (1<<15). Proportional gain Kp
 237:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_SPEED_KI            ((uint16_t)2)                /* (1<<3). Integral gain Ki, uin
 238:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_SPEED_SCALE_KPKI    (10 + RES_INC)               /* RES_INC: Angle/speed resoluti
 239:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 240:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t. Same 
 241:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<11) * 3) >> 2))      /* (-(1<<15)). I[k] output limit LOW.
 242:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_SPEED_IK_LIMIT_MAX  (((1<<11) * 3) >> 2)         /* (1<<15). I[k] output limit HIGH. *
 243:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 244:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_SPEED_UK_LIMIT_MIN  (16)            /* (-32767), 16. U[k] output limit LOW. */
 245:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_SPEED_UK_LIMIT_MAX  (4000)         /* MAX_I_REF. U[k] output limit HIGH. Normally no n
 246:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 247:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /*################### For Torque / Iq PI controller ######################*/
 248:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. 
 249:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain
 250:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integral gain Ki, 
 251:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
 252:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 253:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no
 254:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no n
 255:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 256:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change
 257:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need chang
 258:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 259:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /*################### For Flux / Id PI controller ######################*/
 260:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. 
 261:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain
 262:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integral gain Ki, 
 263:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 264:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 265:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no n
 266:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no nee
 267:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 268:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. 
 269:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change.
 270:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 271:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /*################### For PLL rotor speed PI controller ######################*/
 272:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_PLL_KP         ((uint16_t)(1<<6))              /* Proportional gain Kp, uint16_t.
 273:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_PLL_KI         ((uint16_t)(1<<4))              /* (1<<4). Integral gain Ki, uint1
 274:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define USER_PI_PLL_SCALE_KPKI     (17 - RES_INC)
 275:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 276:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   /* I[k] output limit LOW. */
 277:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCALE_
 278:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] ou
 279:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 280:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] output limi
 281:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] output limi
 282:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 283:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 284:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == MAXON_MOTOR)
 285:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****               /* For Low Voltage 15W Board with MAXON Motor */
 286:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Speed PI controller ######################*/
 287:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KP            ((uint16_t)1U<<15U)          /* (1<<15). Proportional gain Kp, 
 288:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KI            ((uint16_t)3)                /* (1<<3). Integral gain Ki, uint1
 289:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_SCALE_KPKI    (10 + RES_INC)               /* RES_INC: Angle/speed resolution
 290:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 291:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t. Same as
 292:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<15) * 3) >> 2))      /* (-(1<<15)). I[k] output limit LOW. *
 293:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MAX  (((1<<15) * 3) >> 2)         /* (1<<15). I[k] output limit HIGH. */
 294:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 295:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MIN  (16)            /* (-32767), 16. U[k] output limit LOW. */
 296:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MAX  (32767)          /* MAX_I_REF. U[k] output limit HIGH. Normally no n
 297:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 298:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Torque / Iq PI controller ######################*/
 299:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 300:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 301:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 302:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
 303:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 304:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no n
 305:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no nee
 306:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 307:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. 
 308:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change.
 309:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 310:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Flux / Id PI controller ######################*/
 311:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 312:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 313:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 314:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 315:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 316:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no nee
 317:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no need 
 318:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 319:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. */
 320:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change. *
 321:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 322:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For PLL rotor speed PI controller ######################*/
 323:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KP         ((uint16_t)(1<<8))              /* Proportional gain Kp, uint16_t. *
 324:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KI         ((uint16_t)(1<<6))              /* (1<<4). Integral gain Ki, uint16_
 325:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_SCALE_KPKI     (19 - RES_INC)
 326:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 327:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* I[k] output limit LOW. */
 328:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCALE_KP
 329:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] outp
 330:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 331:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] output limi
 332:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] output limi
 333:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 334:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 335:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == BEKO_WM_MOTOR)
 336:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Speed PI controller ######################*/
 337:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KP            ((uint16_t)1U<<16U - 1)          /* (1<<15). Proportional gain 
 338:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KI            ((uint16_t)1U << 8U)                /* (1<<3). Integral gain Ki
 339:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_SCALE_KPKI    (8 + RES_INC)               /* RES_INC: Angle/speed resolution 
 340:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 341:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t. Same as
 342:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MIN  (-(1<<13))      /* (-(1<<15)). I[k] output limit LOW. */
 343:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MAX  (1<<13)         /* (1<<15). I[k] output limit HIGH. */
 344:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 345:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MIN  (4)            /* (-32767), 16. U[k] output limit LOW. */
 346:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normally no ne
 347:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 348:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Torque / Iq PI controller ######################*/
 349:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 350:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 351:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 352:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
 353:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 354:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no n
 355:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no nee
 356:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 357:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. 
 358:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change.
 359:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 360:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Flux / Id PI controller ######################*/
 361:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 362:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 363:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 364:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 365:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 366:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no nee
 367:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no need 
 368:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 369:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. */
 370:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change. *
 371:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 372:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For PLL rotor speed PI controller ######################*/
 373:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KP         ((uint16_t)(2000))              /* Proportional gain Kp, uint16_t. *
 374:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KI         ((uint16_t)(1<<5))              /* (1<<4). Integral gain Ki, uint16_
 375:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_SCALE_KPKI     (17 - RES_INC)
 376:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 377:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* I[k] output limit LOW. */
 378:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCALE_KP
 379:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] outp
 380:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 381:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 0)                /* U[k] output limi
 382:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] output limi
 383:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 384:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 385:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == EBM_PAPST_VENTI_FAN_MOTOR)
 386:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Speed PI controller ######################*/
 387:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KP            ((uint16_t)(1U<<15U) - 1)          /* (1<<15). Proportional gai
 388:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KI            ((uint16_t)1U<<3)                /* (1<<3). Integral gain Ki, u
 389:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_SCALE_KPKI    (12 + RES_INC)               /* RES_INC: Angle/speed resolution
 390:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 391:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t. Same as
 392:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MIN  (-(1<<14))      /* (-(1<<15)). I[k] output limit LOW. */
 393:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MAX  (1<<14)         /* (1<<15). I[k] output limit HIGH. */
 394:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 395:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MIN  (4)            /* (-32767), 16. U[k] output limit LOW. */
 396:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normally no ne
 397:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 398:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Torque / Iq PI controller ######################*/
 399:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 400:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KP        (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 401:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KI        (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 402:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_SCALE_KPKI    (SCALING_CURRENT_KPKI + 0)
 403:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 404:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no n
 405:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no nee
 406:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 407:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. 
 408:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change.
 409:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 410:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Flux / Id PI controller ######################*/
 411:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 412:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KP          (USER_DEFAULT_IQID_KP)             /* (1<<13). Proportional gain K
 413:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KI          (USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral gain Ki, Ki
 414:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_SCALE_KPKI  (SCALING_CURRENT_KPKI + 0)
 415:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 416:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no nee
 417:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no need 
 418:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 419:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. */
 420:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change. *
 421:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 422:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For PLL rotor speed PI controller ######################*/
 423:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KP         ((uint16_t)(1<<8))              /* Proportional gain Kp, uint16_t. *
 424:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KI         ((uint16_t)(1<<4))              /* (1<<4). Integral gain Ki, uint16_
 425:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_SCALE_KPKI     (20 - RES_INC)
 426:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 427:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* I[k] output limit LOW. */
 428:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCALE_KP
 429:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] outp
 430:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 431:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 1)                /* U[k] output limi
 432:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] output limi
 433:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 434:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 435:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == LG_CordZero)
 436:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_SPEED_KP            ((uint16_t)1U << 15U)          /* (1<<15). Proportional gai
 437:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_SPEED_KI            ((uint16_t)3U)                /* (1<<3). Integral gain Ki, 
 438:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_SPEED_SCALE_KPKI    (10U + RES_INC)               /* RES_INC: Angle/speed resol
 439:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 440:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****         /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t.
 441:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** //  #define PI_SPEED_IK_LIMIT_MIN  (-(((1<<14) * 3) >> 2))      /* (-(1<<15)). I[k] output limit LO
 442:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** //  #define PI_SPEED_IK_LIMIT_MAX  (((1<<14) * 3) >> 2)         /* (1<<15). I[k] output limit HIGH.
 443:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_SPEED_IK_LIMIT_MIN  (-32768)      /* (-(1<<15)). I[k] output limit LOW. */
 444:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_SPEED_IK_LIMIT_MAX  (32768)         /* (1<<15). I[k] output limit HIGH. */
 445:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 446:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 447:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_SPEED_UK_LIMIT_MIN  (16)            /* (-32767), 16. U[k] output limit LOW. */
 448:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normally n
 449:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 450:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /*################### For Torque / Iq PI controller ######################*/
 451:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change
 452:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 453:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_TORQUE_KP        (62397U)//(USER_DEFAULT_IQID_KP)             /* (1<<13). Propo
 454:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_TORQUE_KI        (1078U)//(USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integra
 455:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_TORQUE_SCALE_KPKI    (15U)//(SCALING_CURRENT_KPKI + 2)
 456:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 457:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally 
 458:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no
 459:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 460:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need chan
 461:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need cha
 462:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 463:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /*################### For Flux / Id PI controller ######################*/
 464:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change
 465:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 466:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_FLUX_KP          (62397U)//(USER_DEFAULT_IQID_KP)             /* (1<<13). Propo
 467:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_FLUX_KI          (1078U)//(USER_DEFAULT_IQID_KI >> 1)        /* (1<<6). Integra
 468:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_FLUX_SCALE_KPKI  (15U)//(SCALING_CURRENT_KPKI + 2)
 469:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 470:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no
 471:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no n
 472:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 473:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change
 474:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need chang
 475:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 476:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /*################### For PLL rotor speed PI controller ######################*/
 477:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 478:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_PLL_KP             (1260U)//((uint16_t)1<<10)              /* Proportional gain
 479:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_PLL_KI             (25U)//((uint16_t)1<<5)              /* (1<<4). Integral gai
 480:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define USER_PI_PLL_SCALE_KPKI     (15U)//(20 - (RES_INC+3))
 481:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 482:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     /* I[k] output limit LOW. */
 483:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCAL
 484:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] 
 485:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 486:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 4)                /* U[k] output 
 487:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     #define PI_PLL_UK_LIMIT_MAX     ((SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT) << 1)            /* U[k] 
 488:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 489:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 490:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #elif (MOTOR_TYPE == HV_Drive)
 491:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Speed PI controller ######################*/
 492:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KP            ((uint16_t)(1U<<15U) - 1)          /* (1<<15). Proportional gai
 493:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_KI            ((uint16_t)1U<<3)                /* (1<<3). Integral gain Ki, u
 494:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_SPEED_SCALE_KPKI    (12 + RES_INC)               /* RES_INC: Angle/speed resolution
 495:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 496:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Note: (IK_LIMIT_MIN << SCALE_KPKI) and (IK_LIMIT_MAX << SCALE_KPKI) are maximum int32_t. Same as
 497:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MIN  (-(1<<14))      /* (-(1<<15)). I[k] output limit LOW. */
 498:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_IK_LIMIT_MAX  (1<<14)         /* (1<<15). I[k] output limit HIGH. */
 499:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 500:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MIN  (4)            /* (-32767), 16. U[k] output limit LOW. */
 501:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_SPEED_UK_LIMIT_MAX  (32767)         /* MAX_I_REF. U[k] output limit HIGH. Normally no ne
 502:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 503:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Torque / Iq PI controller ######################*/
 504:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 505:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KP        (32113U)//(USER_DEFAULT_IQID_KP)             /* (1<<13). Proportio
 506:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_KI        (23929U)//(USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral g
 507:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_TORQUE_SCALE_KPKI    (17U)//(SCALING_CURRENT_KPKI + 0)
 508:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 509:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no n
 510:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no nee
 511:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 512:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. 
 513:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_TORQUE_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change.
 514:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 515:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For Flux / Id PI controller ######################*/
 516:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* Kp and Ki (from excel file) calculated from motor parameter L and R. Normally no need change. */
 517:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KP          (32113U)//(USER_DEFAULT_IQID_KP)             /* (1<<13). Proportio
 518:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_KI          (23929U)//(USER_DEFAULT_IQID_KI >> 0)        /* (1<<6). Integral g
 519:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_FLUX_SCALE_KPKI  (17U)//(SCALING_CURRENT_KPKI + 0)
 520:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 521:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MIN    (-32768)      /* (-(1<<15)). I[k] output limit LOW. Normally no nee
 522:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_IK_LIMIT_MAX    (32767)       /* (1<<15). I[k] output limit HIGH. Normally no need 
 523:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 524:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MIN    (-32768)      /* U[k] output limit LOW. Normally no need change. */
 525:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_FLUX_UK_LIMIT_MAX    32767         /* U[k] output limit HIGH. Normally no need change. *
 526:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 527:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /*################### For PLL rotor speed PI controller ######################*/
 528:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KP         (456U)//((uint16_t)(1<<8))              /* Proportional gain Kp, uin
 529:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_KI         (26U)//((uint16_t)(1<<4))              /* (1<<4). Integral gain Ki, 
 530:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define USER_PI_PLL_SCALE_KPKI     (16U)//(20 - RES_INC)
 531:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 532:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /* I[k] output limit LOW. */
 533:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MIN     (-(int32_t)((uint32_t)1 << (uint32_t)(30U-(uint32_t)PI_PLL_SCALE_KP
 534:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_IK_LIMIT_MAX     ((uint32_t)1 << (30U-(uint32_t)PI_PLL_SCALE_KPKI))     /* I[k] outp
 535:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 536:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MIN     ((uint32_t)SPEED_LOW_LIMIT >> 1)                /* U[k] output limi
 537:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #define PI_PLL_UK_LIMIT_MAX     (SPEED_HIGH_LIMIT + SPEED_LOW_LIMIT)            /* U[k] output limi
 538:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 539:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 540:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** #endif
 541:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 542:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**************************************************************************************************
 543:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * DATA STRUCTURES
 544:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
 545:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** typedef struct PI_Coefs_Type
 546:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** {
 547:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t error;										/* PI error signal (reference value � feedback value), error[k] */
 548:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 549:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Uk;											  /* PI output U[k] */
 550:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Ik;											  /* Integral result I[k] */
 551:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 552:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   uint16_t Kp;										  /* Proportional gain Kp */
 553:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   uint16_t Ki;										  /* Integral gain Ki */
 554:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int16_t Scale_KpKi;								/* Scale-up Kp and Ki by 2^Scale_KpKi */
 555:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 556:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Ik_limit_min;
 557:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Ik_limit_max;
 558:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 559:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Uk_limit_min;
 560:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t Uk_limit_max;
 561:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   uint8_t Uk_limit_status;
 562:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** } PI_Coefs_Type;
 563:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 564:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 565:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 566:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**************************************************************************************************
 567:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * API Prototypes
 568:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
 569:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**
 570:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @brief Fixed point implementation for filter saturation logic.
 571:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @param input_val    Value that need to be limited
 572:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @param higher_limit Maximum value for <i>input_val</i>
 573:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @param lower_limit  Minimum value for <i>input_val</i>
 574:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @return int32_t
 575:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * <i>input_val</i>, if <i>lower_limit</i> < <i>input_val</i> < <i>higher_limit</i>
 576:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * <i>higher_limit</i>, if <i>input_val</i> > <i>higher_limit</i>
 577:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * <i>lower_limit</i>, if <i>input_val</i> < <i>lower_limit</i>
 578:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
 579:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * \par<b>Description: </b><br>
 580:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * This function is used by PI Controller to limit the <i>input_val</i> within its minimum and maxi
 581:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
 582:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @endcode
 583:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  */
 584:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** __STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t 
 585:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 586:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**
 587:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @brief PI controller
 588:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *      U(t)=Kp x e(t) + (Ki/Ts) x ∫e(t)dt, where Ts is sampling period, e.g.: Ts = 50us.
 589:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *      I[k] = I[k-1] + Ki * error[k]
 590:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *      U[k] = Kp * error[k] + I[k]
 591:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
 592:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * @param *PI_data
 593:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *      error
 594:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *
 595:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  *@retval *PI_data
 596:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  */
 597:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** __STATIC_INLINE void PI_controller(int32_t reference, int32_t feedback, PI_Coefs_Type *PI_data);
 598:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** 
 599:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** /**************************************************************************************************
 600:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  * API IMPLEMENTATION
 601:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****  **************************************************************************************************
 602:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** __STATIC_INLINE RAM_ATTRIBUTE int32_t MIN_MAX_LIMIT(int32_t input_val,int32_t higher_limit,int32_t 
 603:../PMSM_FOC/ControlModules/pmsm_foc_pi.h **** {
 604:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   int32_t return_val;
 605:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   if ( input_val > higher_limit )
 606:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   {
 607:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****     return_val = higher_limit;
 1879              	 .loc 5 607 0
 1880 011e 081C     	 mov r0,r1
 1881              	.LBE86:
 1882              	.LBE85:
 1883              	 .loc 1 794 0
 1884 0120 4A43     	 mul r2,r1
 1885 0122 120B     	 lsr r2,r2,#12
 1886              	.LVL143:
 1887              	.LBB88:
 1888              	.LBB87:
 605:../PMSM_FOC/ControlModules/pmsm_foc_pi.h ****   {
 1889              	 .loc 5 605 0
 1890 0124 8A42     	 cmp r2,r1
 1891 0126 09D9     	 bls .L154
 1892              	.LVL144:
 1893              	.LBE87:
 1894              	.LBE88:
 1895              	.LBB89:
 1896              	.LBB90:
 1897              	 .file 6 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc/xmc_wdt.h"
   1:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
   2:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @file xmc_wdt.h
   3:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @date 2015-10-09
   4:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
   5:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @cond
   6:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  **************************************************************************************************
   7:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMClib v2.1.0 - XMC Peripheral Driver Library 
   8:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
   9:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Copyright (c) 2015, Infineon Technologies AG
  10:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * All rights reserved.                        
  11:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                                             
  12:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * following conditions are met:   
  14:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                                                                              
  15:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * disclaimer.                        
  17:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
  18:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
  21:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                                                                              
  24:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                                                                              
  32:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  **************************************************************************************************
  35:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
  36:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Change History
  37:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * --------------
  38:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
  39:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 2015-02-20:
  40:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *     - Initial <br>
  41:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *     - Documentation updates <br>
  42:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
  43:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 2015-06-20:
  44:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *     - Removed version macros and declaration of GetDriverVersion API <br>
  45:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
  46:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 2015-08-06:
  47:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *     - Bug fix in XMC_WDT_SetDebugMode() API, Wrong register is being configured.<br>
  48:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @endcond
  49:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
  50:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  51:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #ifndef XMC_WDT_H
  52:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #define XMC_WDT_H
  53:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  54:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**************************************************************************************************
  55:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * HEADER FILES
  56:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  **************************************************************************************************
  57:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  58:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #include "xmc_common.h"
  59:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #include "xmc_scu.h"
  60:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
  61:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @addtogroup XMClib XMC Peripheral Library
  62:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @{
  63:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
  64:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  65:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
  66:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @addtogroup WDT
  67:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @brief Watchdog driver for the XMC microcontroller family.
  68:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
  69:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * The watchdog unit (WDT) improves the system integrity, by triggering the system reset request to
  70:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * back from the unresponsive state to normal operation.
  71:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
  72:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * This LLD provides the Configuration structure XMC_WDT_CONFIG_t and initialization function XMC_W
  73:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * It can be used to:
  74:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Start or Stop the watchdog timer. (XMC_WDT_Start() and XMC_WDT_Stop())
  75:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Service the watchdog timer. (XMC_WDT_Service())
  76:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Configure the service window upper bound and lower bound timing values. (XMC_WDT_SetWindowBou
  77:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Enable the generation of the pre-warning event for the first overflow of the timer. (XMC_WDT_
  78:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Clear the pre-warning alarm event. It is mandatory to clear the flag during pre-warning alarm
  79:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       generating reset request for the second overflow of the timer. (XMC_WDT_ClearAlarm())
  80:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Suspend the watchdog timer during Debug HALT mode. (XMC_WDT_SetDebugMode())
  81:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * -# Configure service indication pulse width.(XMC_WDT_SetServicePulseWidth())
  82:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
  83:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @{
  84:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
  85:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  86:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**************************************************************************************************
  87:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * MACROS
  88:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   *************************************************************************************************
  89:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  90:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #define XMC_WDT_MAGIC_WORD             (0xABADCAFEU) /* Magic word to be written in Service Registe
  91:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                                           to service or feed the watchdog. */
  92:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  93:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**************************************************************************************************
  94:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * ENUMS
  95:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   *************************************************************************************************
  96:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
  97:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
  98:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *  Defines working modes for watchdog. Use type XMC_WDT_MODE_t for this enum.
  99:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 100:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** typedef enum XMC_WDT_MODE 
 101:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 102:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   XMC_WDT_MODE_TIMEOUT    = (uint32_t)0x0 << WDT_CTR_PRE_Pos, /**< Generates reset request as soon 
 103:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                                                    occurs. */
 104:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   XMC_WDT_MODE_PREWARNING = (uint32_t)0x1 << WDT_CTR_PRE_Pos  /**< Generates an alarm event for the
 105:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                                                    reset request after subsequent o
 106:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                                                    serviced after first overflow. *
 107:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** } XMC_WDT_MODE_t;
 108:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 109:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 110:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *  Defines debug behaviour of watchdog when the CPU enters HALT mode. Use type XMC_WDT_DEBUG_MODE_
 111:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 112:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** typedef enum XMC_WDT_DEBUG_MODE 
 113:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 114:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   XMC_WDT_DEBUG_MODE_STOP = (uint32_t)0x0 << WDT_CTR_DSP_Pos, /**< Watchdog counter is paused durin
 115:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   XMC_WDT_DEBUG_MODE_RUN  = (uint32_t)0x1 << WDT_CTR_DSP_Pos  /**< Watchdog counter is not paused d
 116:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** } XMC_WDT_DEBUG_MODE_t;
 117:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 118:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**************************************************************************************************
 119:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * DATA STRUCTURES
 120:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   *************************************************************************************************
 121:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  /* Anonymous structure/union guard start */
 122:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #if defined(__CC_ARM)
 123:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   #pragma push
 124:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   #pragma anon_unions
 125:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #elif defined(__TASKING__)
 126:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   #pragma warning 586
 127:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #endif
 128:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  
 129:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 130:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Structure for initializing watchdog timer. Use type XMC_WDT_CONFIG_t for this structure.
 131:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 132:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** typedef struct XMC_WDT_CONFIG
 133:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 134:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   uint32_t window_upper_bound; /**< Upper bound for service window (WUB). Reset request is generate
 135:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                     timer. ALways upper bound value has to be more than lower bound
 136:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                     lower than WLB, triggers a system reset after timer crossed upp
 137:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                     Range: [0H to FFFFFFFFH] */
 138:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   uint32_t window_lower_bound; /**< Lower bound for servicing window (WLB). Setting the lower bound
 139:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                     window mechanism.\n 
 140:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                     Range: [0H to FFFFFFFFH] */
 141:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   union
 142:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   {
 143:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****     struct
 144:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****     {
 145:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t : 1;
 146:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t prewarn_mode : 1;        /**< Pre-warning mode (PRE). This accepts boolean values as
 147:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t : 2;
 148:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t run_in_debug_mode : 1;   /**< Watchdog timer behaviour during debug (DSP). This acce
 149:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t : 3;
 150:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t service_pulse_width : 8; /**< Service Indication Pulse Width (SPW). Generated Pulse 
 151:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                              in fwdt cycles.\n
 152:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                                              Range: [0H to FFH] */
 153:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       uint32_t : 16;
 154:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****     };
 155:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****     uint32_t wdt_ctr; /* Value of operation mode control register (CTR). It’s bit fields are repr
 156:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****                            union members. */
 157:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   };
 158:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** } XMC_WDT_CONFIG_t;
 159:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /* Anonymous structure/union guard end */
 160:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #if defined(__CC_ARM)
 161:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   #pragma pop
 162:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #elif defined(__TASKING__)
 163:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   #pragma warning restore
 164:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #endif
 165:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**************************************************************************************************
 166:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * API PROTOTYPES
 167:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   *************************************************************************************************
 168:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 169:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #ifdef __cplusplus
 170:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** extern "C" {
 171:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** #endif
 172:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 173:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 174:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 175:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 176:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 177:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 178:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 179:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC4
 180:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Enables watchdog clock and releases watchdog reset.\n
 181:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 182:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC1
 183:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Enables watchdog clock.\n
 184:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 185:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 186:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * This API is invoked by XMC_WDT_Init() and therefore no need to call it explicitly during watchdo
 187:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * sequence. Invoke this API to enable watchdog once again if the watchdog is disabled by invoking 
 188:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
 189:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Note:</b><br>
 190:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC4
 191:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. It is required to configure the watchdog, again after invoking XMC_WDT_Disable(). Since all t
 192:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    reset with default values.
 193:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 194:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC1
 195:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. Not required to configure the watchdog again after invoking XMC_WDT_Disable(). Since the regi
 196:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    the configured values.
 197:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 198:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 199:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_Init(), XMC_WDT_Disable()
 200:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 201:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** void XMC_WDT_Enable(void);
 202:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 203:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 204:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 205:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 206:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 207:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 208:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 209:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC4
 210:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Disables the clock and resets watchdog timer.\n
 211:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 212:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC1
 213:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Disables the clock to the watchdog timer.\n
 214:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 215:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 216:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Note:</b><br>
 217:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC4
 218:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. Resets the registers with default values. So XMC_WDT_Init() has to be invoked again to config
 219:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 220:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \if XMC1
 221:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. After invoking XMC_WDT_Disable(), all register values are displayed with 0F in debugger. Once
 222:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       calling XMC_WDT_Enable(), previous configured register values are displayed. No need to invok
 223:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****       again.
 224:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \endif
 225:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 226:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_Enable()
 227:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 228:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** void XMC_WDT_Disable(void);
 229:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 230:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 231:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param config pointer to a constant watchdog configuration data structure. Refer data structure 
 232:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *               for detail.
 233:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 234:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 235:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 236:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 237:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Initializes and configures watchdog with configuration data pointed by \a config.\n
 238:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 239:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * It invokes XMC_WDT_Enable() to enable clock and release reset. Then configures the lower and upp
 240:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * working mode (timeout/pre-warning), debug behaviour and service request indication pulse width.
 241:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 
 242:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Note:</b><br> 
 243:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. With out invoking this XMC_WDT_Init() or XMC_WDT_Enable(), invocation of other APIs like XMC_
 244:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    XMC_WDT_SetMode(), XMC_WDT_SetServicePulseWidth(), XMC_WDT_SetDebugMode(), XMC_WDT_Start(), X
 245:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    XMC_WDT_Service(), XMC_WDT_ClearAlarm() has no affect.
 246:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 247:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** void XMC_WDT_Init(const XMC_WDT_CONFIG_t *const config);
 248:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 249:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 250:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param lower_bound specifies watchdog window lower bound in terms of watchdog clock (fWDT) cycle
 251:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                    Range: [0H to FFFFFFFFH].
 252:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param upper_bound specifies watchdog window upper bound in terms of watchdog clock (fWDT) cycle
 253:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                    Range: [0H to FFFFFFFFH]. 
 254:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 255:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 256:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 257:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 258:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Sets watchdog window lower and upper bounds by updating WLB and WUB registers.\n
 259:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 260:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Window lower and upper bounds are set during initialization in XMC_WDT_Init(). Invoke this API t
 261:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * needed later in the program. This upper bound and lower bound can be calculated by using the bel
 262:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *       upper_bound or lower_bound = desired_boundary_time(sec) * fwdt(hz)
 263:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 264:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Note:</b>
 265:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. Always ensure that upper_bound is greater than the lower_bound value. If not, whenever timer 
 266:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    upper_bound value it triggers the reset(wdt_rst_req) of the controller.
 267:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 268:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_SetWindowBounds(uint32_t lower_bound, uint32_t upper_bound)
 269:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 270:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->WLB = lower_bound;
 271:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->WUB = upper_bound;
 272:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 273:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 274:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 275:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param mode is one of the working modes of the watchdog timer, i.e timeout or pre-warning. Refer
 276:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *             for valid values.
 277:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 278:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 279:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 280:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 281:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Sets watchdog working mode (timeout or pre-warning) by updating PRE bit of CTR register.\n
 282:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 283:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * The working mode is set during initialization in XMC_WDT_Init(). Invoke this API to alter the mo
 284:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * the program.
 285:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 286:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_SetMode(XMC_WDT_MODE_t mode)
 287:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 288:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->CTR = (WDT->CTR & (uint32_t)~WDT_CTR_PRE_Msk) | (uint32_t)mode;
 289:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 290:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 291:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 292:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param service_pulse_width specifies Service indication pulse width in terms of fwdt. 
 293:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                            Range: [0H – FFH].
 294:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 295:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 296:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 297:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Sets service indication pulse width by updating SPW bit field of CTR register.\n
 298:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 299:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * The service indication pulse (with width service_pulse_width + 1 in fwdt cycles) is generated on
 300:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * or feeding of watchdog. The pulse width is initially set during initialization in XMC_WDT_Init()
 301:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * alter the width as needed later in the program.
 302:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 303:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_SetServicePulseWidth(uint8_t service_pulse_width)
 304:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 305:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->CTR = (WDT->CTR & (uint32_t)~WDT_CTR_SPW_Msk) | ((uint32_t)service_pulse_width << WDT_CTR_SP
 306:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 307:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 308:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 309:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param debug_mode running state of watchdog during debug halt mode. Refer @ref XMC_WDT_DEBUG_MOD
 310:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                   valid values.
 311:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 312:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 313:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 314:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 315:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Sets debug behaviour of watchdog by modifying DSP bit of CTR register.\n
 316:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 317:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Depending upon DSP bit, the watchdog timer stops when CPU is in HALT mode. The debug behaviour i
 318:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_DEBUG_MODE_STOP during initialization in XMC_WDT_Init(). Invoke this API to change the d
 319:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * needed later in the program.
 320:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 321:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_SetDebugMode(const XMC_WDT_DEBUG_MODE_t debug_mode)
 322:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 323:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->CTR = (WDT->CTR & (uint32_t)~WDT_CTR_DSP_Msk) | (uint32_t)debug_mode;
 324:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 325:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 326:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 327:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 328:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 329:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 330:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 331:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 332:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Start the watchdog timer by setting ENB bit of CTR register.\n
 333:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 334:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Invoke this API to start the watchdog after initialization, or to resume the watchdog when
 335:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * paused by invoking XMC_WDT_Stop().
 336:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 337:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 338:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_Init(), XMC_WDT_Stop()
 339:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 340:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_Start(void)
 341:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 342:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->CTR |= (uint32_t)WDT_CTR_ENB_Msk;
 343:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 344:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 345:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 346:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 347:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 348:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 349:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 350:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 351:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Pauses watchdog timer by resetting ENB bit of CTR register.\n
 352:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 353:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Invoke this API to pause the watchdog as needed in the program e.g. debugging through software c
 354:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 355:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 356:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_Init(), XMC_WDT_Stop()
 357:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 358:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_Stop(void)
 359:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 360:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->CTR &= (uint32_t)~WDT_CTR_ENB_Msk;
 361:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 362:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 363:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 364:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 365:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 366:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return uint32_t Current count value of watchdog timer register (TIM).
 367:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *                  Range: [0H to FFFFFFFFH]
 368:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 369:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 370:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Reads current count of timer register (TIM).\n
 371:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 372:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Invoke this API before servicing or feeding the watchdog to check whether count is between lower
 373:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * window bounds.
 374:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 375:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 376:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_Service()
 377:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 378:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE uint32_t XMC_WDT_GetCounter(void)
 379:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 380:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   return WDT->TIM;
 381:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** }
 382:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** 
 383:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** /**
 384:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @param None
 385:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 386:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * @return None
 387:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 388:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Description:</b><br>
 389:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Services or feeds the watchdog by writing the Magic word in SRV register.\n
 390:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par
 391:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * Service watchdog when count value of watchdog timer is between lower and upper window bounds. Su
 392:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * will reset watchdog timer (TIM register) to 0H and generate service indication pulse.
 393:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 394:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Note:</b><br>
 395:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * 1. invoking this API when count value of watchdog timer is less than window lower bound results
 396:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *    wrong servicing and immediately triggers reset request.
 397:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  *
 398:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * \par<b>Related APIs:</b><BR>
 399:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  * XMC_WDT_GetCounter(), XMC_WDT_SetWindowBounds(), XMC_WDT_SetServicePulseWidth()
 400:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****  */
 401:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** __STATIC_INLINE void XMC_WDT_Service(void)
 402:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h **** {
 403:C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc\xmc_wdt.h ****   WDT->SRV = XMC_WDT_MAGIC_WORD;
 1898              	 .loc 6 403 0
 1899 0128 0F4A     	 ldr r2,.L156+12
 1900              	.LVL145:
 1901 012a 1049     	 ldr r1,.L156+16
 1902              	.LBE90:
 1903              	.LBE89:
 795:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Limit speed, in case ADC values not 0 ~ 2^12.*/
 796:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_IQ_REF_HIGH_LIMIT, USER
 1904              	 .loc 1 796 0
 1905 012c D860     	 str r0,[r3,#12]
 1906              	.LBB94:
 1907              	.LBB91:
 1908              	 .loc 6 403 0
 1909 012e 9160     	 str r1,[r2,#8]
 1910              	.LBE91:
 1911              	.LBE94:
 797:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 798:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #elif(MY_FOC_CONTROL_SCHEME == CONSTANT_VQ_DIRECT_FOC)
 799:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* POT ADC values 0 ~ 2^12 represent motor target speed of SPEED_LOW_LIMIT ~ SPEED_HIGH_LIM
 800:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = USER_VQ_REF_LOW_LIMIT + (((USER_VQ_REF_HIGH_LIMIT - USER_VQ_REF_LO
 801:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Limit speed, in case ADC values not 0 ~ 2^12.*/
 802:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.Speed_by_POT_PWM = MIN_MAX_LIMIT(Motor.Speed_by_POT_PWM, USER_VQ_REF_HIGH_LIMIT, USER
 803:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****       #endif
 804:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			/* Service watchdog. Without WDT service regularly , it will reset system.*/
 805:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			XMC_WDT_Service();
 806:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 807:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			Motor.UART_Counter ++;
 1912              	 .loc 1 807 0
 1913 0130 1A6D     	 ldr r2,[r3,#80]
 1914 0132 0132     	 add r2,r2,#1
 808:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			if (Motor.UART_Counter > (3U))
 1915              	 .loc 1 808 0
 1916 0134 032A     	 cmp r2,#3
 1917 0136 0AD8     	 bhi .L150
 1918              	.LVL146:
 1919              	.L155:
 807:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			if (Motor.UART_Counter > (3U))
 1920              	 .loc 1 807 0
 1921 0138 1A65     	 str r2,[r3,#80]
 1922              	.LVL147:
 1923              	.L146:
 809:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			{
 810:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Reset counter.*/
 811:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Motor.UART_Counter = 0;
 812:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #if(UART_ENABLE == USIC_DISABLED_ALL)
 813:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         pot_adc_result = XMC_VADC_GROUP_GetResult(VADC_POT_GROUP,VADC_POT_RESULT_REG);
 814:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* POT ADC LPF. Read RES7 for ADC result (Previous ADC result). */
 815:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         ADC.ADC_POT = (ADC.ADC_POT * ((1<<POTADC_LPF)-1) + pot_adc_result) >> POTADC_LPF;
 816:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 817:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         Speed_in_rpm = (Motor.Speed * SPEED_TO_RPM ) >> SCALE_SPEED_TO_RPM;
 818:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 819:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #else
 820:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Use UART to adjust POT ADC values, and hence motor speed.*/
 821:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Use UART to set POT ADC, by polling.*/
 822:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         UART_Set_POT_ADC ();
 823:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #endif
 824:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			}
 825:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 826:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	}
 827:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 828:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** }
 1924              	 .loc 1 828 0
 1925              	 
 1926 013a 08BD     	 pop {r3,pc}
 1927              	.LVL148:
 1928              	.L154:
 794:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         /* Limit speed, in case ADC values not 0 ~ 2^12.*/
 1929              	 .loc 1 794 0
 1930 013c 101C     	 mov r0,r2
 1931              	.LVL149:
 1932              	.LBB95:
 1933              	.LBB92:
 1934              	 .loc 6 403 0
 1935 013e 0B49     	 ldr r1,.L156+16
 1936 0140 094A     	 ldr r2,.L156+12
 1937              	.LVL150:
 1938              	.LBE92:
 1939              	.LBE95:
 796:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 
 1940              	 .loc 1 796 0
 1941 0142 D860     	 str r0,[r3,#12]
 1942              	.LBB96:
 1943              	.LBB93:
 1944              	 .loc 6 403 0
 1945 0144 9160     	 str r1,[r2,#8]
 1946              	.LBE93:
 1947              	.LBE96:
 807:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			if (Motor.UART_Counter > (3U))
 1948              	 .loc 1 807 0
 1949 0146 1A6D     	 ldr r2,[r3,#80]
 1950 0148 0132     	 add r2,r2,#1
 808:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 			{
 1951              	 .loc 1 808 0
 1952 014a 032A     	 cmp r2,#3
 1953 014c F4D9     	 bls .L155
 1954              	.LVL151:
 1955              	.L150:
 811:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #if(UART_ENABLE == USIC_DISABLED_ALL)
 1956              	 .loc 1 811 0
 1957 014e 0022     	 mov r2,#0
 1958 0150 1A65     	 str r2,[r3,#80]
 822:../PMSM_FOC/ControlModules/pmsm_foc_interface.c ****         #endif
 1959              	 .loc 1 822 0
 1960 0152 FFF7FEFF 	 bl UART_Set_POT_ADC
 1961              	.LVL152:
 1962 0156 F0E7     	 b .L146
 1963              	.LVL153:
 1964              	.L153:
 779:../PMSM_FOC/ControlModules/pmsm_foc_interface.c **** 	if (Motor.Non_RealTime_Counter > NON_REALTIME_RATE)
 1965              	 .loc 1 779 0
 1966 0158 9A64     	 str r2,[r3,#72]
 1967 015a EEE7     	 b .L146
 1968              	.L157:
 1969              	 .align 2
 1970              	.L156:
 1971 015c 00000000 	 .word Motor
 1972 0160 00000000 	 .word ADC
 1973 0164 AEB70000 	 .word 47022
 1974 0168 00000240 	 .word 1073872896
 1975 016c FECAADAB 	 .word -1414673666
 1976              	 .cfi_endproc
 1977              	.LFE209:
 1979              	 .comm Real_Speed_in_rpm,4,4
 1980              	 .comm Speed_in_rpm,4,4
 1981              	 .comm Epsilon,4,4
 1982              	 .section .bss.local_counter.8414,"aw",%nobits
 1983              	 .align 2
 1984              	 .set .LANCHOR0,.+0
 1987              	local_counter.8414:
 1988 0000 00000000 	 .space 4
 1989              	 .text
 1990              	.Letext0:
 1991              	 .file 7 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Infineon/XMC1300_series/Include/XMC1300.h"
 1992              	 .file 8 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1993              	 .file 9 "c:\\dave-ide-4.4.2-64bit\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1994              	 .file 10 "../PMSM_FOC/ControlModules/..\\MIDSys\\../MCUInit/adc.h"
 1995              	 .file 11 "../PMSM_FOC/ControlModules/..\\MIDSys\\pmsm_foc_pwmsvm.h"
 1996              	 .file 12 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/CMSIS/Infineon/XMC1300_series/Include/system_XMC1300.h"
 1997              	 .file 13 "../PMSM_FOC/ControlModules/..\\MCUInit\\../Configuration/pmsm_foc_user_parameter.h"
 1998              	 .file 14 "../PMSM_FOC/ControlModules/pmsm_foc_interface.h"
 1999              	 .file 15 "C:/Users/choeoliv/Desktop/IFKOR FOC DRIVE/Libraries/XMCLib/inc/xmc1_flash.h"
 2000              	 .file 16 "../PMSM_FOC/ControlModules/..\\MIDSys\\../MCUInit/ccu8.h"
 2001              	 .file 17 "../PMSM_FOC/ControlModules/..\\MCUInit\\uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 pmsm_foc_interface.c
    {standard input}:18     .text.Init_Smooth_Transition_To_FOC:00000000 $t
    {standard input}:23     .text.Init_Smooth_Transition_To_FOC:00000000 Init_Smooth_Transition_To_FOC
    {standard input}:222    .text.Init_Smooth_Transition_To_FOC:000000f0 $d
                            *COM*:00000004 Epsilon
    {standard input}:243    .text.VF_ONLY_OpenLoop_RampUp:00000000 $t
    {standard input}:248    .text.VF_ONLY_OpenLoop_RampUp:00000000 VF_ONLY_OpenLoop_RampUp
    {standard input}:503    .text.VF_ONLY_OpenLoop_RampUp:00000118 $d
    {standard input}:522    .text.VF_FOC_OpenLoop_RampUp:00000000 $t
    {standard input}:527    .text.VF_FOC_OpenLoop_RampUp:00000000 VF_FOC_OpenLoop_RampUp
    {standard input}:823    .text.VF_FOC_OpenLoop_RampUp:00000148 $d
    {standard input}:843    .text.VF_Smooth_Transition_To_FOC:00000000 $t
    {standard input}:848    .text.VF_Smooth_Transition_To_FOC:00000000 VF_Smooth_Transition_To_FOC
    {standard input}:1105   .text.VF_Smooth_Transition_To_FOC:00000120 $d
    {standard input}:1121   .text.Stop_Motor:00000000 $t
    {standard input}:1126   .text.Stop_Motor:00000000 Stop_Motor
    {standard input}:1430   .text.Stop_Motor:00000138 $d
    {standard input}:1463   .text.VF_FOC_Brake_Motor_Bootstrap_Charge:00000000 $t
    {standard input}:1468   .text.VF_FOC_Brake_Motor_Bootstrap_Charge:00000000 VF_FOC_Brake_Motor_Bootstrap_Charge
    {standard input}:1576   .text.VF_FOC_Brake_Motor_Bootstrap_Charge:00000078 $d
    {standard input}:1585   .ram_code:00000000 $t
    {standard input}:1590   .ram_code:00000000 Linear_Ramp_Generator
    {standard input}:1688   .ram_code:00000060 $d
    {standard input}:1692   .ram_code:00000064 $t
    {standard input}:1697   .ram_code:00000064 SCurve_Ramp_Generator
    {standard input}:1843   .ram_code:000000fc $d
    {standard input}:1849   .ram_code:00000108 $t
    {standard input}:1854   .ram_code:00000108 Misc_Works_of_IRQ
    {standard input}:1971   .ram_code:0000015c $d
                            *COM*:00000004 Real_Speed_in_rpm
                            *COM*:00000004 Speed_in_rpm
    {standard input}:1983   .bss.local_counter.8414:00000000 $d
    {standard input}:1987   .bss.local_counter.8414:00000000 local_counter.8414
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
Get_ADCPhaseCurrent
Current_Reconstruction
PLL_Imag
PLL_Imag_GetResult
PLL_Vref
PLL_Vref_GetResult
ADC
SVM
Current
Clarke_Transform
Car2Polar
PLL_Estimator
PI_PLL
FOCInput
I_AngleQ31
FOCOutput
Update_Vref_Angle
PWMSVM01_Update
Motor
CCU8_Init
Variables_Init
CCUx_SynStart
XMC_FLASH_ProgramVerifyPage
Update_KpKi
PI_Speed
User_Para
PI_Torque
PI_Flux
__aeabi_ui2f
__aeabi_fcmpgt
UART_Set_POT_ADC
